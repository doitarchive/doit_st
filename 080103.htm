<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.05.2004 -->
<html>
<head>
<title>
DOIT_ST - Tips u. Tricks zur Atari Serie: WD1772 FDC
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="doit@doitarchive.de">
<link rev=made href="mailto:doit@doitarchive.de" title="E-Mail">
<link rel=home href="doitst1h.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080102.htm" target="UDOcon"><img src="udo_lf.gif" alt="Atari ST DMA" border=0 width="24" height="24"></a>
<a href="080104.htm" target="UDOcon"><img src="udo_rg.gif" alt="Blitter" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="WD1772_20FDC">8.1.3 WD1772 FDC</a></h1>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p><tt> WD1772 Floppy Disk Controller </tt>
<br>
<br>
</p>
<p><img src="image/deutsch.gif" border=0 width="35" height="22"></p><br>
<p><img src="image/english.gif" border=0 width="35" height="22"></p><br>
<p>Hier finden Sie einige wenige m&uuml;hsam zusammengesuchte
Informationen zum WD1772 Floppy Controller. M&ouml;glicherweise fehlt
hier eine Menge!
<br>
</p>
<p>Der WD1772 kann mit Stepraten von 2, 3, 5 und 6 msec arbeiten.
Alle Ausgangs Pin des WD1772 k&ouml;nnen einen TTL-Eingang bedienen.
Das Prozessor-Interface ist ein 8-Bit Bidirektionaler Datenbus
f&uuml;r Daten und Kommandos.
<br>
</p>
<p>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 51: WD1772 Pinout</caption>
<tr>
  <td align=left valign=top>Signal</td>
  <td align=left valign=top>Pin</td>
  <td align=left valign=top>Pin</td>
  <td align=left valign=top>Signal</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>CS</td>
  <td align=left valign=top>1</td>
  <td align=left valign=top>28</td>
  <td align=left valign=top>INTRQ</td>
</tr>
<tr>
  <td align=left valign=top>R/W</td>
  <td align=left valign=top>2</td>
  <td align=left valign=top>27</td>
  <td align=left valign=top>DRQ</td>
</tr>
<tr>
  <td align=left valign=top>A0</td>
  <td align=left valign=top>3</td>
  <td align=left valign=top>26</td>
  <td align=left valign=top>DDEN</td>
</tr>
<tr>
  <td align=left valign=top>A1</td>
  <td align=left valign=top>4</td>
  <td align=left valign=top>25</td>
  <td align=left valign=top>WPRT</td>
</tr>
<tr>
  <td align=left valign=top>DAL0</td>
  <td align=left valign=top>5</td>
  <td align=left valign=top>24</td>
  <td align=left valign=top>IP</td>
</tr>
<tr>
  <td align=left valign=top>DAL1</td>
  <td align=left valign=top>6</td>
  <td align=left valign=top>23</td>
  <td align=left valign=top>TR00</td>
</tr>
<tr>
  <td align=left valign=top>DAL2</td>
  <td align=left valign=top>7</td>
  <td align=left valign=top>22</td>
  <td align=left valign=top>WD</td>
</tr>
<tr>
  <td align=left valign=top>DAL3</td>
  <td align=left valign=top>8</td>
  <td align=left valign=top>21</td>
  <td align=left valign=top>WG</td>
</tr>
<tr>
  <td align=left valign=top>DAL4</td>
  <td align=left valign=top>9</td>
  <td align=left valign=top>20</td>
  <td align=left valign=top>MO</td>
</tr>
<tr>
  <td align=left valign=top>DAL5</td>
  <td align=left valign=top>10</td>
  <td align=left valign=top>19</td>
  <td align=left valign=top>nRD</td>
</tr>
<tr>
  <td align=left valign=top>DAL6</td>
  <td align=left valign=top>11</td>
  <td align=left valign=top>18</td>
  <td align=left valign=top>CLK</td>
</tr>
<tr>
  <td align=left valign=top>DAL7</td>
  <td align=left valign=top>12</td>
  <td align=left valign=top>17</td>
  <td align=left valign=top>DIREC</td>
</tr>
<tr>
  <td align=left valign=top>MR</td>
  <td align=left valign=top>13</td>
  <td align=left valign=top>16</td>
  <td align=left valign=top>STEP</td>
</tr>
<tr>
  <td align=left valign=top>GND</td>
  <td align=left valign=top>14</td>
  <td align=left valign=top>15</td>
  <td align=left valign=top>Vcc</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p><b> Beschreibung </b>
<br>
<br>Es folgt eine Beschreibung der Hardwareregister des WD1770/WD1772
<br>
</p>
<dl>
<dt><b>Data Shift Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register assembles serial data from the Read Data input
(RD) during Read operations and transfers serial data to the Write
Data output during write operations.
<br>&nbsp;
<dt><b>Data Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register is used as a holding register during Disk read
and Write operations. In Disk Read operations the assembled data byte
is transferred in parallel to the Data register from the Data Shift
Register. In Disk Write operations information is transferred in
parallel from the the Data Register to the Data Shift Register.
<br>&nbsp;
<br>When executing the Seek command the Data Register holds the
address of the desired Track position. This register is loaded from
the DAL and gated into the DAL under processor control.
<br>&nbsp;
<dt><b>Track Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register holds the track number of the current
Read/Write hed position. It is incremented by one every time the head
is stepped in and decremented by one when the head is stepped out
(towards track 00). The contents of the register are compared with the
recorded track number in the ID field during disk Read, Write and
Verify operations. The track register can be loaded from or
transferred to the DAL. This register should not be loaded when the
device is busy.
<br>&nbsp;
<dt><b>Status Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register holds device Status information. The meaning
of the status bits is a function of the type of command previously
executed. This register can be read into the DAL, but not loaded from
the DAL.
<br>&nbsp;
<dt><b>Timing and Control</b></dt><dd>
<br>&nbsp;
<br>All computer and floppy disk interface controls are generated
through this logic. The internal device timing is generated from an
external crystal clock. The FD1772 has two different modes of
operation according to the state of DDEN. When DDEN = 0., double
density is enabled. When DDEN = 1, single density is enabled.
<br>&nbsp;
<dt><b>AM Detector</b></dt><dd>
<br>&nbsp;
<br>The address mark detector detects ID, data and index address marks
during read and write operations.
<br>&nbsp;
<dt><b>Data Separator</b></dt><dd>
<br>&nbsp;
<br>A digital data separator consisting of a nng shift register and
data window detection logic provides read data and a recovery clock to
the AM detector.
<br>&nbsp;
<dt><b>CRC Logic</b></dt><dd>
<br>&nbsp;
<br>This logic is used to check or to generate the 16-bit Cyclic
Redundancy Check (CRC). The polynominal is: g(x)=x^16+x^12+x^5+1 The
CRC includes all information starting with the address mark and up to
the CRC characters. The CRC register is preset to ones prior to data
being shifted through the circuit.
<br>&nbsp;
<dt><b>Sector Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register holds address of the desired sector postition.
The contents of the register are compared with the recorded sector
number in the ID field during disk Read or Write operations. The
Sector Register contents can be loaded from or transferred to the DAL.
This register should not be loaded when the device is busy.
<br>&nbsp;
<dt><b>Command Register</b></dt><dd>
<br>&nbsp;
<br>This 8-bit register holds the command presently being executed.
This register should not be loaded when the device is busy unless the
new command is a force interrupt. The command register can be loaded
from the DAL, but not read into the DAL.
<br>&nbsp;
<dt><b>Arithmetic/Logic Unit</b></dt><dd>
<br>&nbsp;
<br>The ALU is a serial comperator, incrementer and decrementer and is
used for register modification and comparisons with the disk recorded
ID field.
<br>&nbsp;
</dl>
<p>
<br>
<br>
</p>
<p>Wenn ein Datentransfer zwischen dem WD1772 und der <a href="080108.htm" target="UDOcon">CPU</a> stattfindet
mu&szlig; die Device Adresse anliegen und CS Low werden. Die
Adressbits A1 und A0 zusammen mit dem R/W Signal erlauben eine Lese-
oder Schreiboperation in die Chipregister nach der folgenden Tabelle:
<br>
</p>
<p>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 52: WD1772 R/W Operation</caption>
<tr>
  <td align=left valign=top>A1</td>
  <td align=left valign=top>A0</td>
  <td align=left valign=top>READ</td>
  <td align=left valign=top>WRITE</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>0</td>
  <td align=left valign=top>Status Register</td>
  <td align=left valign=top>Command Register</td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>1</td>
  <td align=left valign=top>Track register</td>
  <td align=left valign=top>Track Register</td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>0</td>
  <td align=left valign=top>Sector register</td>
  <td align=left valign=top>Sector Register</td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>1</td>
  <td align=left valign=top>Data Register</td>
  <td align=left valign=top>Data Register</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p>During Direct Memory Access (DMA) types of data transfers between
the Data Register of the WD1772 and the processor, the Data ReQuest
(DRQ) output is used in Data Transfer control. This signal also
appears as status bit 1 during Read and Write operations.
</p>
<p>On Disk Read operations the Data Request is activated (set high)
when an assembled serial input byte is transferred in parallel to the
Data Register. This bit is cleared when the Data Register is read by
the processor. If the Data Register is read after one or more
characters are lost, by having new data transferred to the register
prior to processor readout, the Lost Data bit is set in the Status
Register. The read operation continues until the end of sector is
reached.
</p>
<p>On Disk Write operations the Data ReQuest is activated when the
Data Registers its contents to the Data Shift Register and requires a
new data byte. It is reset when the Data Register is loaded with new
data by the processor. If new data is not loaded at the time serial
byte is required by the Floppy Disk, a byte of zeroes is written on
the diskette and the Lost Data bit is set in the Status Register.
</p>
<p>At the completion of every command an INTRQ is generated. INTRQ is
reset by either reading the status register or by loading the command
register with a new command. In addition INTRQ is generated if a Force
Interrupt command condition is met.
</p>
<p>The WD1772 has two modes of operation according to the state of
notDDEN (pin 26). When DDEN = 1, single density is selected. In either
case, the CLK input (pin 18) is at 8 MHz.
</p>
<p>GENERAL DISK READ OPERATIONS Sector lengths of 128, 256, 512 or
1024 bytes are obtainable in either FM or MFM formats. For FM formats,
DDEN should be placed to logical &quot;1&quot;. For MFM formats,
notDDEN should be placed to logic &quot;0&quot;. Sector lengths are
determined at format time by hte fourth byte in the ID field.
</p>
<p>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 53: WD1772 Sector Lenght Table</caption>
<tr>
  <td align=left valign=top>SECTOR LENGTH</td>
  <td align=left valign=top>NUMBER OF BYTES</td>
</tr>
<tr>
  <td align=left valign=top>FIELD (HEX)</td>
  <td align=left valign=top>IN SECTOR (DEC)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>00</td>
  <td align=left valign=top>128</td>
</tr>
<tr>
  <td align=left valign=top>01</td>
  <td align=left valign=top>256</td>
</tr>
<tr>
  <td align=left valign=top>02</td>
  <td align=left valign=top>512</td>
</tr>
<tr>
  <td align=left valign=top>03</td>
  <td align=left valign=top>1024</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p>The number of sectors per track as far as the WD1772 is concerned
can be from 1 to 255 sectors. The number of tracks as far as the
WD1772 is concerned is from 0 to 255 tracks.
</p>
<p><b> GENERAL DISK WRITE OPERATION </b>
<br>When writing is to take place on the diskette, the Write Gate (WG)
output is activated, allowing current to flow into the Read/Write
head. As a precaution to erroneous writing the first data must be
loaded into the Data Register in response to a Data ReQuest from the
device before the Write Gate signal can be activated.
</p>
<p>Writing is inhibited when the notWP (Write Protect) input is a
logic low, in which case any Write command is immediately terminated,
an interrupt generated and the Write Protection status bit is set.
</p>
<p>For Write operations, the WD1772 provides Write Gate (pin 21) to
enable a write condition and Write Data (pin 22) which consists of a
series of active high pulses. These pulses contain both Clock and Data
information in FM or MFM. Write Data provides the unique missing clock
patterns for recording Address Marks.
</p>
<p><b> RESTORE (SEEK TRACK 0) </b>
<br>Upon receipt of this command, the Track 00 (notTR00) input is
sampled. If notTR00 is active low indicating the Read/Write head is
positioned over track 0, the Track register is loaded with zeroes and
an interrupt is generated. If notTR00 is not active low, stepping
pulses (pin 16) at a rate specified by the r1, r0 field are issued
until the notTR00 input is activated. At this time, the Track Register
is loaded with zeroes and an interrupt is generated. If the notTR00
input does not go active low after 255 stepping pulses, the WD1772
terminates operation, interrupts and sets the Seek error status bit,
providing the V flag is set. A verification als takes place if the V
flag is set. The h bit allows the Motor On option at the start of
command.
</p>
<p><b> SEEK </b>
<br>This command assumes that the track register contains the track
number of the current position of the Read/Write head and the Data
Register contains the desired track number. The WD1772 will update the
Track Register and issue stepping pulses in the appropiate direction
until the contents of the Track Register are equal to the contents of
the Data Register (the desired Track location). A verification
operation takes place if the V flag is on. The h bit allows the Motor
On option at the start of the command. An interrupt is generated at
the completion of the command. Note: When using mutiple drives, the
track register must be updated for the drive selected before seeks are
issued.
</p>
<p><b> STEP </b>
<br>Upon receipt of this command, the WD1772 issues one stepping pulse
to the disk drive. The stepping motor direction is the same as in the
previous step command. After a delay determined by the r1, r0 field, a
verification takes place if the V flag is on. If the U flag is on, the
Track Register is updated. The h bit allows the Motor On option at the
start of the command. An interrupt is generated at the completion of
the command.
</p>
<p><b>STEP-IN </b>
<br>Upon receipt of this command, the WD1772 issues one stepping pulse
in the direction towards track 76. If the U flag is on, the Track
Register is incremented by one. After a delay determined by the r1, r0
field, a verification takes place if the V flag is on. The h bit alows
the Motor On option at the startof the command. An interrupt is
generated at the completion of the command
</p>
<p>
<br>
<br>
</p>
<p align=center><img src="image/fdc.gif" border=0 width="175" height="320"></p><br>
<div align=center><tt> Abbildung 1 - Atari WD 1772 Floppy Controller </tt>
</div>
<p>
<br>
<br>
</p>
<p><b> WD1770/1772 5 1/4 &quot; Floppy Disk Controller/Formatter
</b>
<br>
</p>
<p><b> DESCRIPTION </b>
<br>The WD1770 is a MOS LSI device which performs the functions of a 5
1/4 &quot; Floppy Disk Controller/Formatter. It is similar to its
predecessor, the WD179x but also contains a digital data separator and
write precompensation circuitry. The drive side of the interface needs
no additional logic except for buffers/receivers. Designed for 5 1/4
&quot; single or double density operation. The device contains a
programmable Motor On signal.
<br>
</p>
<p>The WD1770 is a low cost version of the FD179x Floppy Disk
Controller/Formatter. It is compatible with the 179x, but has a
built-in digital data separator and write precompensation circuits. A
single read line (notRD, pin 19) is the only input required to recover
serial FM or MFM data from the disk drive. The device has been
specifically designed for control of 5 1/4 &quot; floppy disk drives
with data rates of 125 Kbits/sec (single density) and 250 Kbits/sec
(double density). In addition write precompensation of 125 Nsec from
nominal can be enabled at any point through simple software commands.
Another programmable feature, Motor On, has been incorporated to
enable the spindle motor prior to operating a selected drive.
<br>
</p>
<p>Two versions of the WD1770 are available. The standard version is
compatible with the 179x stepping rates, while the WD1772 offers
stepping rates of 2, 3, 5 and 6 msec.
<br>
</p>
<p>The processor interface consists of an 8-bit bidirectional bus for
transfer of status, data and commands. All host communication with the
drive occurs through these data lines. They are capable of driving one
standard TTL load or three &quot;LS&quot; loads.
<br>
<br>
</p>
<pre>
         +------+
  notCS  1      28 INTRQ
 R/notW  2      27 DRQ
     A0  3      26 notDDEN
     A1  4      25 notWPRT
   DAL0  5      24 notIP
   DAL1  6 1772 23 notTR00
   DAL2  7  FDC 22 WD
   DAL3  8      21 WG
   DAL4  9      20 MO
   DAL5 10      19 notRD
   DAL6 11      18 CLK
   DAL7 12      17 DIREC
  notMR 13      16 STEP
    GND 14      15 Vcc
         +------+

</pre>
<p>
<br>
</p>
<p><b> ARCHITECTURE </b>
<br>The Floppy Disk Formatter block diagram is illustrated on page 4.
The primary sections include the parallel processor interface the the
Floppy Disk Interface.
<br>
</p>
<p>Data Shift Register - This 8-bit register assembles serial data
from the Read Data input (notRD) during Read operations and transfers
serial data to the Write Data output during write operations.
<br>
</p>
<p>Data Register - This 8-bit register is used as a holding register
during Disk read and Write operations. In Disk Read operations the
assembled data byte is transferred in parallel to the Data register
from the Data Shift Register. In Disk Write operations information is
transferred in parallel from the the Data Register to the Data Shift
Register.
<br>
</p>
<p>When executing the Seek command the Data Register holds the
address of the desired Track position. This register is loaded from
the DAL and gated into the DAL under processor control.
<br>
</p>
<p>Track Register - This 8-bit register holds the track number of the
current Read/Write hed position. It is incremented by one every time
the head is stepped in and decremented by one when the head is stepped
out (towards track 00). The contents of the register are compared with
the recorded track number in the ID field during disk Read, Write and
Verify operations. The track register can be loaded from or
transferred to the DAL. This register should not be loaded when the
device is busy.
<br>
</p>
<p>Sector Register (SR) - This 8-bit register holds address of the
desired sector postition. The contents of the register are compared
with the recorded sector number in the ID field during disk Read or
Write operations. The Sector Register contents can be loaded from or
transferred to the DAL. This register should not be loaded when the
device is busy.
<br>
</p>
<p>Command Register (CR) - This 8-bit register holds the command
presently being executed. This register should not be loaded when the
device is busy unless the new command is a force interrupt. The
command register can be loaded from the DAL, but not read into the
DAL.
<br>
</p>
<p>Status Register (STR) - This 8-bit register holds device Status
information. The meaning of the status bits is a function of the type
of command previously executed. This register can be read into the
DAL, but not loaded from the DAL.
<br>
</p>
<p>CRC Logic - This logic is used to check or to generate the 16-bit
Cyclic Redundancy Check (CRC). The polynominal is:
g(x)=x^16+x^12+x^5+1 The CRC includes all information starting with
the address mark and up to the CRC characters. The CRC register is
preset to ones prior to data being shifted through the circuit.
<br>
</p>
<p>Arithmetic/Logic Unit (ALU) - The ALU is a serial comperator,
incrementer and decrementer and is used for register modification and
comparisons with the disk recorded ID field.
<br>
</p>
<p>Timing and Control - All computer and floppy disk interface
controls are generated through this logic. The internal device timing
is generated from an external crystal clock. The FD1770 has two
different modes of operation according to the state of notDDEN. When
notDDEN = 0., double density is enabled. When notDDEN = 1, single
density is enabled.
<br>
</p>
<p>AM Detector - The address mark detector detects ID, data and index
address marks during read and write operations.
<br>
</p>
<p>Data Separator - A digital data separator consisting of a nng
shift register and data window detection logic provides read data and
a recovery clock to the AM detector.
<br>
<br>
</p>
<p><b> PROCESSOR INTERFACE </b>
<br>
</p>
<p>The interface to the processor is accomplished through the eight
Data Access Lines (DAL) and associated control signals. The DAL are
used to transfer data, Status and Control words out of, or into the
WD1770. The DAL are three state buffers that are enabled as output
drivers when Chip Select (notCS) and R/notW = 1 are active or act as
input receivers when notCS and R/notW = 0 are active.
<br>
</p>
<p>When transfer of data with the Floppy Disk Controller is required
by the host processor, the device address is decoded and notCS is made
low. The address bits A1 and A0, combined with the signal R/notW
during a Read operation or Write operation are interpreted as selecing
the following registers:
<br>
<br>
</p>
<pre>
     +----+----+-----------------+------------------+
     ! A1 ! A0 ! READ            ! WRITE            !
     +----+----+-----------------+------------------+
     !  0 !  0 ! Status Register ! Command Register !
     !  0 !  1 ! Track register  ! Track Register   !
     !  1 !  0 ! Sector register ! Sector Register  !
     !  1 !  1 ! Data Register   ! Data Register    !
     +----+----+-----------------+------------------+

</pre>
<p>
<br>
</p>
<p>During Direct Memory Access (DMA) types of data transfers between
the Data Register of the WD1770 and the processor, the Data ReQuest
(DRQ) output is used in Data Transfer control. This signal also
appears as status bit 1 during Read and Write operations.
<br>
</p>
<p>On Disk Read operations the Data Request is activated (set high)
when an assembled serial input byte is transferred in parallel to the
Data Register. This bit is cleared when the Data Register is read by
the processor. If the Data Register is read after one or more
characters are lost, by having new data transferred to the register
prior to processor readout, the Lost Data bit is set in the Status
Register. The read operation continues until the end of sector is
reached.
<br>
</p>
<p>On Disk Write operations the Data ReQuest is activated when the
Data Registers its contents to the Data Shift Register and requires a
new data byte. It is reset when the Data Register is loaded with new
data by the processor. If new data is not loaded at the time serial
byte is required by the Floppy Disk, a byte of zeroes is written on
the diskette and the Lost Data bit is set in the Status Register.
<br>
</p>
<p>At the completion of every command an INTRQ is generated. INTRQ is
reset by either reading the status register or by loading the command
register with a new command. In addition INTRQ is generated if a Force
Interrupt command condition is met.
<br>
</p>
<p>The WD1770 has two modes of operation according to the state of
notDDEN (pin 26). When notDDEN = 1, single density is selected. In
either case, the CLK input (pin 18) is at 8 MHz.
<br>
<br>
</p>
<p><b> GENERAL DISK READ OPERATIONS </b>
<br>
</p>
<p>Sector lengths of 128, 256, 512 or 1024 bytes are obtainable in
either FM or MFM formats. For FM formats, notDDEN should be placed to
logical &quot;1&quot;. For MFM formats, notDDEN should be placed to
logic &quot;0&quot;. Sector lengths are determined at format time by
hte fourth byte in the ID field.
<br>
<br>
</p>
<pre>

     +---------------------------------+
     !      SECTOR LENGTH TABLE        !
     +---------------+-----------------+
     ! SECTOR LENGTH ! NUMBER OF BYTES !
     !  FIELD (HEX)  ! IN SECTOR (DEC) !
     +---------------+-----------------+
     !    00         !     128         !
     !    01         !     256         !
     !    02         !     512         !
     !    03         !    1024         !
     +---------------+-----------------+

</pre>
<p>
<br>
</p>
<p>The number of sectors per track as far as the WD1770 is concerned
can be from 1 to 255 sectors. The number of tracks as far as the
WD1770 is concerned is from 0 to 255 tracks.
<br>
<br>
</p>
<p><b> GENERAL DISK WRITE OPERATION </b>
<br>
</p>
<p>When writing is to take place on the diskette, the Write Gate (WG)
output is activated, allowing current to flow into the Read/Write
head. As a precaution to erroneous writing the first data must be
loaded into the Data Register in response to a Data ReQuest from the
device before the Write Gate signal can be activated.
<br>
</p>
<p>Writing is inhibited when the notWP (Write Protect) input is a
logic low, in which case any Write command is immediately terminated,
an interrupt generated and the Write Protection status bit is set.
<br>
</p>
<p>For Write operations, the WD1770 provides Write Gate (pin 21) to
enable a write condition and Write Data (pin 22) which consists of a
series of active high pulses. These pulses contain both Clock and Data
information in FM or MFM. Write Data provides the unique missing clock
patterns for recording Address Marks.
<br>
</p>
<p>The Precomp Enable bit in Write commands allow automatic Write
Precompensation to take place. The outgoing Write Data Stream is
delayed or advanced according to the following table:
<br>
<br>
</p>
<pre>
     +----------+--------+------+
     ! PATTERN  ! MFM    ! FM   !
     +----------+--------+------+
     ! x 1 1 0  ! Early  ! N/A  !
     ! x 0 1 1  ! Late   ! N/A  !
     ! 0 0 0 1  ! Early  ! N/A  !
     ! 1 0 0 0  ! Late   ! N/A  !
     +----------+--------+------+
       ^ ^ ^ ^
       ! ! ! +- Next bit to be sent
       ! ! +--- Current bit sending
       +-+----- Previous bits sent

</pre>
<p>
<br>
</p>
<p>Precompensation is typically enabled on the innermost tracks where
bit shifts usually occur and bit density is at its maximum.
<br>
<br>
</p>
<p><b> COMMAND DESCRIPTION </b>
<br>
</p>
<p>De WD1770 will accept eleven commands. Command words should only
be loaded in the Command Register when the Busy status bit is off
(Status bit 0). The one exception is the force interrupt command.
Whenever a command is being executed, the Busy status bit is set. When
a command is completed, an interrupt is generated and the Busy status
bit is reset. The status register indicates whether the completed
command encountered an error or was fault free. For ease of
discussion, commands are divided into four types. Commands and types
are summarized in tale 1.
<br>
<br>
</p>
<pre>
COMMAND SUMMARY
     +------+----------+-------------------------+
     !      !          !           BITS          !
     ! TYPE ! COMMAND  !  7  6  5  4  3  2  1  0 !
     +------+----------+-------------------------+
     !   1  ! Restore  !  0  0  0  0  h  v r1 r0 !
     !   1  ! Seek     !  0  0  0  1  h  v r1 r0 !
     !   1  ! Step     !  0  0  1  u  h  v r1 r0 !
     !   1  ! Step-in  !  0  1  0  u  h  v r1 r0 !
     !   1  ! Step-out !  0  1  1  u  h  v r1 r0 !
     !   2  ! Rd sectr !  1  0  0  m  h  E  0  0 !
     !   2  ! Wt sectr !  1  0  1  m  h  E  P a0 !
     !   3  ! Rd addr  !  1  1  0  0  h  E  0  0 !
     !   3  ! Rd track !  1  1  1  0  h  E  0  0 !
     !   3  ! Wt track !  1  1  1  1  h  E  P  0 !
     !   4  ! Forc int !  1  1  0  1 i3 i2 i1 i0 !
     +------+----------+-------------------------+

FLAG SUMMARY
     +-------------------------------------------+
     ! TYPE 1 COMMANDS                           !
     +-------------------------------------------+
     ! h =    Motor on Flag (bit 3)              !
     ! h = 0  Enable spin-up Sequence            !
     ! h = 1  Disable spin-up Sequemce           !
     !                                           !
     ! v =    Verify Flag (bit 2)                !
     ! v = 0  No verify                          !
     ! v = 1  Verify on destn track              !
     !                                           !
     ! r1, r0 = Stepping rate (bits 1, 0)        !
     ! r1 r0    WD1770  WD1772                   !
     !  0  0     6 ms    2 ms                    !
     !  0  1    12 ms    3 ms                    !
     !  1  0    20 ms    5 ms                    !
     !  1  1    30 ms    6 ms                    !
     !                                           !
     ! u =    Update Flag (bit 4)                !
     ! u = 0  No update                          !
     ! u = 1  Update Track Register              !
     +-------------------------------------------+

     +-------------------------------------------+
     ! TYPE 2 &amp; 3 COMMANDS                       !
     +-------------------------------------------+
     ! m =    Multiple Sector Flag (bit 4)       !
     ! m = 0  Single sector                      !
     ! m = 1  Multiple sector                    !
     !                                           !
     ! a0=    Data Address Mark (bit 0)          !
     ! a0= 0  Write normal Data Mark             !
     ! a0= 1  Write Deleted Data Mark            !
     !                                           !
     ! E =    30ms Settling Delay (bit 2)        !
     ! E = 0  No delay                           !
     ! E = 1  Add 30ms Delay                     !
     !                                           !
     ! P =    Write Precompensation (bit 1)      !
     ! P = 0  Enable Write Precomp               !
     ! P = 1  Disable Write Precomp              !
     +-------------------------------------------+

     +-------------------------------------------+
     ! TYPE 4 COMMANDS                           !
     +-------------------------------------------+
     ! i3-i0     Interrupt condition (bit 3-0)   !
     ! i0= 1     Don't care                      !
     ! i1= 1     Don't care                      !
     ! i2= 1     Interrupt on index pulse        !
     ! i3= 1     Immediate interrupt             !
     ! 13-i0 = 0 Terminate without interrupt     !
     +-------------------------------------------+

</pre>
<p>
<br>
</p>
<p><b> TYPE 1 COMMANDS </b>
<br>
</p>
<p>The type 1 commands include the Restore, Seek, Step, Step-in and
Step-out commands. Each of the Type 1 commands contains a rate field
(r0, r1), which determines the stepping motor rate.
<br>
</p>
<p>A 4uS (MFM) of 8uS (FM) pulse is provided as an output to the
drive. For every step pulse issued, the drive moves one track location
in a direction determined by the direction output. The chip will step
the drive in the same direction it last stepped, unless the command
changes the direction.
<br>
</p>
<p>The direction signal is active high when stepping in and low when
stepping out. The Direction signal is valid 24uS before the first
stepping pulse is generated.
<br>
</p>
<p>After the last directional step an additional 30 milliseconds of
head settling time takes if the verify flag is set in type 1 commands.
There is also a 30mS head settling time if the E flag is set in any
Type 2 or 3 command.
<br>
</p>
<p>When a Seek, Step or Restore command is executed, an optional
verification of Read/Write head position can be performed by setting
bit 2 (V=1) in the command word to a logic &quot;1&quot;. The
verification operation begins at the end of the 30 millisecond
settling time after the head is loaded against the media. The track
number from the first encountered ID field is compared against the
contents of the Track Register. If the track numbers compare and the
ID field CRC is correct, the verify operations is complete and an
INTRQ is generated with no errors. If there is a match but not a valid
CRC, the CRC error status bit is set (Status bit 3) and the next
encountered ID field is read from the disk for the verification
operation.
<br>
</p>
<p>The WD1770 must find an ID field with correct track number and
correct CRC within 5 revolutions of the media, otherwise the seek
error is set and an INTRQ is generated. If V=0 no verification is
performed.
<br>
</p>
<p>All commands except the Force Interrupt command may be programmed
via the h Flag to delay for spindle motor startup time. If the h Flag
is set and the Motor On line (pin 20) is low when a command is
received, the WD1770 will force Motor On to a logic &quot;1&quot; and
wait 6 revolutions before executing the command. At 300rpm this
guarantees a one second spindle startup time. If after finishing the
command, the device remains idle for 10 revolutions, the Motor On line
will go back to a logic &quot;0&quot;. If a command is issued while
Motor On is high, the command will execute immediately, defeating the
6 revolutions start up. This feature allows consecutive Read or Write
commands without waiting for motor start up each time; the WD1770
assumes the spindle motor is up to speed.
<br>
<br>
</p>
<p><b> RESTORE (SEEK TRACK 0) </b>
<br>
</p>
<p>Upon receipt of this command, the Track 00 (notTR00) input is
sampled. If notTR00 is active low indicating the Read/Write head is
positioned over track 0, the Track register is loaded with zeroes and
an interrupt is generated. If notTR00 is not active low, stepping
pulses (pin 16) at a rate specified by the r1, r0 field are issued
until the notTR00 input is activated. At this time, the Track Register
is loaded with zeroes and an interrupt is generated. If the notTR00
input does not go active low after 255 stepping pulses, the WD1770
terminates operation, interrupts and sets the Seek error status bit,
providing the V flag is set. A verification als takes place if the V
flag is set. The h bit allows the Motor On option at the start of
command.
<br>
<br>
</p>
<p><b> SEEK </b>
<br>
</p>
<p>This command assumes that the track register contains the track
number of the current position of the Read/Write head and the Data
Register contains the desired track number. The WD1770 will update the
Track Register and issue stepping pulses in the appropiate direction
until the contents of the Track Register are equal to the contents of
the Data Register (the desired Track location). A verification
operation takes place if the V flag is on. The h bit allows the Motor
On option at the start of the command. An interrupt is generated at
the completion of the command. Note: When using mutiple drives, the
track register must be updated for the drive selected before seeks are
issued.
<br>
<br>
</p>
<p><b> STEP </b>
<br>Upon receipt of this command, the WD1770 issues one stepping pulse
to the disk drive. The stepping motor direction is the same as in the
previous step command. After a delay determined by the r1, r0 field, a
verification takes place if the V flag is on. If the U flag is on, the
Track Register is updated. The h bit allows the Motor On option at the
start of the command. An interrupt is generated at the completion of
the command.
<br>
<br>
</p>
<p><b> STEP-IN </b>
<br>Upon receipt of this command, the WD1770 issues one stepping pulse
in the direction towards track 76. If the U flag is on, the Track
Register is incremented by one. After a delay determined by the r1, r0
field, a verification takes place if the V flag is on. The h bit alows
the Motor On option at the startof the command. An interrupt is
generated at the completion of the command
<br>
</p>
<p>
<br><b> STEP-IN </b>
<br>Upon receipt of this command, the WD1770 issues one stepping pulse
in the direction towards track 0. If the U flag is on, the Track
Register is decremented by one. After delay determined by the r1, r0
field, a verification takes place if the V flag is on. The h bit
allows the Motor On option at the start of the command.
<br>
<br>
<br>
</p>
<p><b> TYPE 2 COMMANDS </b>
<br>
</p>
<p>The type 2 commands are the read sector and write sector commands.
Prior to loading the type 2 command into the command register, the
computer must load the sector register with the desired sector number.
Upon receipt of the type 2 command, the busy status bit is set. If the
E flag is 1, the command will execute after 30ms delay.
<br>
</p>
<p>When an ID field is located on the disk, the WD1770 compares the
track number on the ID field with the Track register. If there is not
a match, the next encountered ID field is read and a comparison is
again made. If there was a match, the Sector Number of the ID field is
compared with the Sector Register. If there is not a Sector match, the
next encountered ID field is read off the disk and comparisons again
made. If the ID field CRC is correct, the data field is then located
and will be either written into, or read from depending upon the
command. The WD1770 must find an ID field with a track number, sector
number and CRC within four revolutions of the disk, otherwise, the
Record not found status bit is set (status bit 4) and the command is
terminated with an interrupt (INTRQ).
<br>
</p>
<p>Each of the type 2 commands contains an (m) flag which determines
if multiple records (sectors) are to be read or written, depending
upon the command. If m=0, a single record is read or written and an
interrupt is generated at the completion of the command. If m=1,
multiple records are read or written with the sector register
internally updated so that an address verification can occur on the
next record. The WD1770 will continue to read or write multiple
records and update the sector register in numerical ascending sequence
until the sector number exceeds the number of sectors on the track or
until the Force Interrupt command is loaded in the command register,
which terminates the command and generates an interrupt.
<br>
</p>
<p>For example:
<br>If the WD1770 is instructed to read sector 27 and there are only
26 sectors on the track, the sector register exceeds the number
available. The WD1770 will search for 5 disk revolutions, interrupt
out, reset busy and set the record not found status bit.
<br>
</p>
<p>
<br>
</p>
<p><b> READ SECTOR </b>
<br>Upon receipt of the Read Sector command, the busy status bit is
set, and when an ID field is encountered that has the correct track
number, corect sector number and correct CRC, the data field is
presented to the computer. The data address mark of the data field
must be found within 30 bytes in single density and 43 bytes in double
density of the last ID field CRC byte; if not, the ID field is
searched for and verified again followed by the Data Address Mark
search. If after 5 revolutions the DAM cannot be found, the record not
found bit is set and the operation terminated. When the first
character or byte of the data field has been shifted through the DSR,
it is transferred to the DR, and DRQ is generated. When the next byte
is accumulated in the DSR, it is transferred to the DR and another DRQ
is generated. If the computer has not read the previous contents of
the DR before a new character is transferred that character will be
lost and the lost data status bit is set. This sequence continues
until the complete data field has been inputted to the computer. If
there is a CRC error at the end of the data field, the CRC error
status bit is set and the command is terminated (even if it is a
multiple record command).
<br>
</p>
<p>At the end of the Read operation, the type of Data Address Mark
encountered in the data field is recorded in the status register (bit
5) as shown:
<br>
<br>
</p>
<pre>
     +---------------------+
     ! STATUS BIT 5        !
     +---------------------+
     ! 1 Deleted Data Mark !
     ! 0 Data Mark         !
     +---------------------+

</pre>
<p>
<br>
</p>
<p><b> WRITE SECTOR </b>
<br>Upon receipt of the Write Sector command, the Busy status bit is
set. When an ID field is encountered that has the correct track
number, correct sector number and correct CRC, a DRQ is generated. The
WD1770 counts off 11 bytes in single density and 22 bytes in double
density from the CRC field and the Write Gate (WG) output is made
active if the DRQ is serviced (i.e. the DR has been loaded by the
computer). If DRQ has not been serviced, the command is terminated and
the lost data status bit is set. If the DRQ has been serviced, the WG
is made active and six bytes of zeroes in single density and 12 bytes
in double density are then written to the disk. At this time, the Data
Address Mark is then written on the disk as determined by the a0 field
of the command as shown below:
<br>
<br>
</p>
<pre>

     +-----+---------------------------+
     ! a0  ! DATA ADDRESS MARK (BIT 0) !
     +-----+---------------------------+
     !  1  ! Deleted Data Mark         !
     !  0  ! Data Mark                 !
     +-----+---------------------------+
</pre>
<p>
<br>
</p>
<p>The WD1770 then writes the data field and generates DRQ's to the
computer. If the DRQ is not serviced in time for conitinious writing
the lost data status bit is set and a byte of zeroes is written on the
disk. The command is not terminated. After the last data byte has been
written on the disk, the two byte CRC is computed internally and
written on the disk followed by one byte of logic ones in FM or MFM.
The WG output is then activated. INTRQ will set 24uSec (MFM) after the
last CRC byte is written. For partial sector writing, the proper
method is to write data and fill the balance with zeroes.
<br>
</p>
<p>
<br>
<br>
</p>
<p><b> TYPE 3 COMMANDS </b>
<br>
</p>
<p>
<br><b> READ ADDRESS </b>
<br>Upon receipt of the Read Address command, the Busy status bit is
set. The next encountered ID field is then read in from the disk, and
six data bytes of the ID field are assembled and transferred to the
DR, and a DRQ is generated for each byte. The six bytes of the ID
field are shown below. (!nl)#
<br>
</p>
<pre>
     +-------+--------+--------+--------+-----+-----+
     ! TRACK ! SIDE   ! SECTOR ! SECTOR ! CRC ! CRC !
     ! ADDR  ! NUMBER ! ADDR   ! LENGTH !  1  !  2  !
     +-------+--------+--------+--------+-----+-----+
     !   1   !   2    !    3   !   4    !  5  !  6  !
     +-------+--------+--------+--------+-----+-----+

</pre>
<p>
<br>
</p>
<p>Although the CRC characters are transferred to the computer, the
WD1770 checks for validity and the CRC error status bit if there is a
CRC error. The Track Address of the ID field is written into the
sector register so that a comparison can be made by the user. At the
end of the operation an interrupt is generated and the Busy status bit
is reset.
<br>
<br>
</p>
<p><b> READ TRACK </b>
<br>Upon receipt of the Read Track command, the head is loaded and the
Busy status bit is set. Reading starts with the leading edge of the
first encountered index pulse and continues until the next index
pulse. All gap, Header and data bytes are assembled and transferred to
the data register and DRQ's are generated for each byte. The
accumulation of bytes is synchronized to each address mark
encountered. An interrupt is generated at the completion of the
command. This command has several characteristics which makes it
suitable for diagnostic purposes. They are: no CRC checking is
performed; gap information is included in the datastream; and the
address mark detector is on for the duration of the command. Because
the AM detector is always on, write splices or noise may cause the
chip to look for an DM.
<br>
</p>
<p>The ID am, ID field, ID CRC bytes, DAM, data, and data CRC bytes
for each sector will be correct. The Gap Bytes may be read incorrectly
during write-splice time because of synchronization.
<br>
<br>
</p>
<p><b> WRITE TRACK FORMATTING THE DISK </b>
<br>(Refer to section type 3 command for flow diagrams). Formatting
the disk is a relatively simple task when operating programmed I/O or
when operating under DMA with a large amount of memory. Data and gap
information must be provided at the computer interface. Formatting the
disk is accomplished by positioning the R/W head over the desired
track and issuing the Write Track command.
<br>
</p>
<p>Upon receipt of the Write Track command, the Busy status bit is
set. Writing starts with the leading edge of the first encountered
index pulse and continues until the next index pulse, at which time
the interrupt is activated. The Data ReQuest is activated immediately
upon receiving the command, but writing will not start until after the
first byte has been loaded into the Data Register. If the DR has not
been loaded within 3 byte times, the operation is terminated making
the device not busy, the Lost Data Status bit is set, and the
interrupt is activated. If a byte is not present in the DR when
needed, a byte of zeroes is substituted.
<br>
</p>
<p>This sequence continues from one index mark to the next index
mark. Normally, whatever data pattern appears in the data register is
written on the disk with a normal clock pattern. However, if the
WD1770 detects a data pattern of F5 through FE in the data register,
this is interpreted as data address marks with missing clocks or CRC
generation.
<br>
<br>
</p>
<pre>
     +--------------+-----------------------------+--------------------------+
     ! DATA PATTERN !                                            !                                       !
     ! IN DR (HEX)  ! IN FM (not DDEN = 1)           ! In MFM (notDDEN = 0)     !
     +--------------+-----------------------------+--------------------------+
     ! 00 thru F4   ! Wt 00 thru F4 with CLK = FF ! Wt 00 thru F4 in MFM     !
     ! F5           ! Not Allowed                 ! Wt A1 in MFM, Preset CRC !
     ! F6           ! Not Allowed                 ! Wt C2 in MFM             !
     ! F7           ! Generate 2 CRC bytes        ! Generate 2 CRC bytes     !
     ! F8 thru FB   ! Wt F8-FB, Clk=C7,Preset CRC ! Wt F8 thru Fb, in MFM    !
     ! FC           ! Wt FC with Clk=D7           ! Wt FC in MFM             !
     ! FD           ! Wt FD with Clk=FF           ! Wt FD in MFM             !
     ! FE           ! Wt FE, Clk=C7, Preset CRC   ! Wt FE in MFM             !
     ! FF           ! Wt FF with Clk=FF           ! Wt FF in MFM             !
     +--------------+-----------------------------+--------------------------+

</pre>
<p>
<br>
</p>
<p>The CRC generator is initialized when any data byte from F8 to FE
is about to be transferred from the DR to the DSR in FM or by receipt
of F5 in MFM. An F7 pattern will generate two CRC characters in FM or
MFM. As a consequence, the patterns F5 through FE must not appear in
the gaps, data fields or ID fields. Also, CRC's must be generated by
an F7 pattern.
<br>
</p>
<p>Disks may be formatted in IBM 3740 or system 34 formats with
sector lengths of 128, 256, 512 or 1024 bytes.
<br>
<br>
<br>
</p>
<p><b> TYPE 4 COMMANDS </b>
<br>
</p>
<p>The forced interrupt command is generally used to terminate a
multiple sector read or write command or to insure Type 1 status in
the status register. This command can be loaded into the command
register at any time. If there is a current command under execution
(Busy status bit set) the command will be terminated and the busy
status bit reset.
<br>
</p>
<p>The lower four bits of the command determine the conditional
interrupt as follows:
<br>
</p>
<p>i0 = Don't care
<br>i1 = Don't care
<br>i2 = Every index puls
<br>i3 = Immediate interrupt
<br>
<br>The conditional interrupt is enabled when bit positions of the
command (i3-i0) are set to a &quot;1&quot;. Then, when the condition
for interrupt is met, the INTRQ line will go high signifying that the
condition specified has occurred. If i3-i0 are all set to zero (HEX
D0), no interrupt will occur, but any command presently under
execution will be immediately terminated. When using the immediate
interrupt condition (i3=1) an interrupt will be immediately generated
and the current command terminated. Reading the status or writing to
the command register will not automatically clear the interrupt. The
HEX D0 is the only command that will enable the immediate interrupt
(HEX D6) to clear on a subsequent load command register or read status
register operation. Follow a HEX D6 with D0 command.
<br>
</p>
<p>Wait 16uSec (double density) or 32uSec (single density) before
issuing a new command after issuing the forced interrupt. Loading a
new command sooner than this will nullify the forced interrupt.
<br>
</p>
<p>Forced interrupt stops any command at the end of an internal
micro-instruction and generates INTRQ when the specified condition is
met. Forced interrupt will wait until ALU operations in progress are
complete (CRC calculations, compares, etc.).
<br>
<br>
</p>
<p><b> STATUS REGISTER </b>
<br>Upon receipt of any command, except the Force interrupt command
the Busy status bit is set and the rest of the status bits are updated
or cleared for the new command. If the Force Interrupt Command is
received when there is a current command under execution, the Busy
status bit is reset and the rest of the status bits are unchanged. If
the Forced interrupt command is received when there is not a current
command under execution, the Busy status bit is reset and the rest of
the status bits are updated or cleared. In this case, Status reflects
the type 1 commands.
<br>
</p>
<p>The user has the option of reading the status register through
program control or using the DRQ with DMA or interrupt methods. When
the Data register is read the DRQ bit in the status register and the
DRQ line are automatically reset. A write to the Data Register also
causes both DRQ's to reset.
<br>
</p>
<p>The busy bit is the status may be monitored with a user program to
determine when a command is complete, in lieu of using the INTRQ line.
When using the INTRQ, a busy status check is not recommended because a
read of the status register to determine the condition of busy will
reset the INTRQ line.
<br>
</p>
<p>The format of the Status register is shown below:
<br>
<br>
</p>
<pre>
     +---------------------------------------+
     !                 (BITS)                !
     !  7    6    5    4    3    2    1    0 !
     +----+----+----+----+----+----+----+----+
     ! s7 ! s6 ! s5 ! s4 ! s3 ! s2 ! s1 ! s0 !
     +----+----+----+----+----+----+----+----+

</pre>
<p>
<br>
</p>
<p><b> RECOMMENDED - 128 BYTES/SECTOR </b>
<br>
</p>
<p>Shown below is the recommended single-density format with 128
bytes/sector. In order to format a diskette, the user must issue the
Write Track command and load the data register with the following
values. For every byte to be written there is one Data Request.
<br>
<br>
</p>
<pre>
    +----------+------------------------------+
    ! NUMBER   !                              !
    ! OF BYTES ! HEX VALUE OF BYTE WRITTEN    !
    +----------+------------------------------+
    !  40      ! FF (or 00)                   !
    ! +---- 1) !                              !
    ! !   6    ! 00                           !
    ! !   1    ! FE (ID field Address Mark)   !
    ! !   1    ! .. Track number              !
    ! !   1    ! .. Side number (0 or 1)      !
    ! !   1    ! .. Sector number (1 thru 1A) !
    ! !   1    ! 00 (Sector length)           !
    ! !   1    ! F7 (2 CRC's written)         !
    ! !  11    ! FF (or 00)                   !
    ! !   6    ! 00                           !
    ! !   1    ! FB (Data Address Mark)       !
    ! ! 128    ! .. Data (IBM uses E5)        !
    ! !   1    ! F7 (2 CRC's written)         !
    ! !  10    ! FF (or 00)                   !
    ! +----    !                              !
    ! 369 2)   ! FF (or 00)                   !
    +----------+------------------------------+

</pre>
<p>
<br>
</p>
<p>1) Write bracketed field 16 times.
<br>2) Continue writing until WD1770 interrupts out, approx. 369
bytes.
<br>
<br>
</p>
<p><b> 256 BYTES/SECTOR </b>
<br>Shown below is the recommended dual-density format with 256
bytes/sector. In order to format a diskette the user must issue the
Write Track command and load the data register with the following
values. For every byte to be written there is one data request.
<br>
<br>
</p>
<pre>
    +----------+------------------------------+
    ! NUMBER   !                              !
    ! OF BYTES ! HEX VALUE OF BYTE WRITTEN    !
    +----------+------------------------------+
    !  60      ! 4E                           !
    ! +---- 1) !                              !
    ! !  12    ! 00                           !
    ! !   3    ! F5 (Writes A1)               !
    ! !   1    ! FE (ID field Address Mark)   !
    ! !   1    ! .. Track number (0 thru 4C)  !
    ! !   1    ! .. Side number (0 or 1)      !
    ! !   1    ! .. Sector number (1 thru 1A) !
    ! !   1    ! 01 (Sector length)           !
    ! !   1    ! F7 (2 CRC's written)         !
    ! !  22    ! 4E                           !
    ! !  12    ! 00                           !
    ! !   3    ! F5 (Writes A1)               !
    ! !   1    ! FB (Data Address Mark)       !
    ! ! 256    ! .. Data                      !
    ! !   1    ! F7 (2 CRC's written)         !
    ! !  24    ! 4E                           !
    ! +----    !                              !
    ! 668 2)   ! 4E                           !
    +----------+------------------------------+

</pre>
<p>
<br>
</p>
<p>1) Write bracketed field 16 times.
<br>2) Continue writing until WD1770 interrupts out, approx. 668
bytes.
<br>
<br>
</p>
<p><b> NON-STANDARD FORMATS </b>
<br>Variations in the recommended formats are possible to a limited
extent if the following requirements are met.
<br>1) Sector length must be 128, 256, 512 or 1024 bytes.
<br>2) Gap 2 cannot be varied from the recommended format.
<br>3) 3 bytes of A1 must be used in MFM.
<br>
<br>In addition, the index Address Mark is not required for operation
by the WD1770. Gap 1, 3 and 4 lengths can be as short as 2 bytes for
WD1770 operation, however PLL lock up time, motor speed variation,
write splice area, etc. will add more bytes to each gap to achieve
proper operation. It is recommended that the recommended format be
used for highest system reliability.
<br>
<br>
</p>
<pre>
     +----------+-------------+-------------+
     !          !             !             !
     +----------+-------------+-------------+
     ! Gap 1    ! 16 bytes FF ! 32 bytes 4E !
     !          !             !             !
     ! Gap 2    ! 11 bytes FF ! 22 bytes 4E !
     !          !             !             !
     !   1)     !  6 bytes 00 ! 12 bytes 00 !
     !   1)     !             !  3 bytes A1 !
     !          !             !             !
     ! Gap 3 2) ! 10 bytes FF ! 24 bytes 4E !
     !          !  4 bytes 00 !  8 bytes 00 !
     !          !  3 bytes A1 !             !
     !          !             !             !
     ! Gap 4    ! 16 bytes FF ! 16 bytes 4E !
     +----------+-------------+-------------+

</pre>
<p>
<br>
</p>
<p>1) Byte counts must be exact
<br>2) Byte counts are minimum, except exactly 3 bytes of A1 must be
written.
<br>
</p>
<p>
<br>
</p>
<p><b> STATUS REGISTER DESCRIPTION </b>
<br>
<br>
</p>
<pre>
     +-----+---------------+-------------------------------------------------+
     !BIT  ! NAME          ! MEANING                                         !
     +-----+---------------+-------------------------------------------------+
     !  s7 ! MOTOR ON      ! This bit reflects the status of the Motor On    !
     !     !               ! output                                          !
     +-----+---------------+-------------------------------------------------+
     !  s6 ! WRITE PROTECT ! On read record: not used. On read track: not    !
     !     !               ! used. On any write: it indicates a Write        !
     !     !               ! Protect. This bit is reset when updated.        !
     +-----+---------------+-------------------------------------------------+
     !  s5 ! RECORD TYPE   ! When set, this bit indicates that the Motor     !
     !     ! SPIN-UP       ! Spin-Up sequence has completed (6 revolutions)  !
     !     !               ! on type 1 commands. Type 2 &amp; 3 commands, this   !
     !     !               ! bit indicates record Type. 0 = Data Mark, 1 =   !
     !     !               ! Deleted Data Mark.                              !
     +-----+---------------+-------------------------------------------------+
     !  s4 ! RECORD NOT    ! When set, it indicates that the desired track,  !
     !     ! FOUND (RNF)   ! sector, or side were not found. This bit is     !
     !     !               ! reset when updated.                             !
     +-----+---------------+-------------------------------------------------+
     !  s3 ! CRC ERROR     ! If s4 is set, an error is found in one or more  !
     !     !               ! ID fields; otherwise it indicates error in data !
     !     !               ! field. This bit is reset when updated.          !
     +-----+---------------+-------------------------------------------------+
     ! s2  ! LOST DATA/    ! When set, it indicates the computer did not     !
     !     ! TRACK 00      ! respond to DRQ in one byte time. This bit is    !
     !     !               ! reset to zero when update. On type 1 commands,  !
     !     !               ! this bit reflects the status of the TRACK 00    !
     !     !               ! pin.                                            !
     +-----+---------------+-------------------------------------------------+
     !  s1 ! DATA REQUEST/ ! This bit is a copy of the DRQ output. When set, !
     !     ! INDEX         ! it indicates the DR is full on a Read Operation !
     !     !               ! or the DR is empty on a write operation. This   !
     !     !               ! bit is reset to zero when updated. On type 1    !
     !     !               ! commands, this bit indicates the status of the  !
     !     !               ! index pin.                                      !
     +-----+---------------+-------------------------------------------------+
     !  s0 ! BUSY          ! When set, command is under execution. When      !
     !     !               ! reset, no command is under execution.           !
     +-----+---------------+-------------------------------------------------+






                           TYPE 1 COMMAND FLOW
               !
               !
               !-------&lt;--------+
               !                !
        +------+------+         !
       / has a type 1  \ no     !
      !  command been   !-----&gt;-+
       \               /
        +------+------+
               !yes
   +-----------+-----------+
   ! set busy, reset drq,  !
   ! seek err, drq, intrq  !
   +-----------+-----------+
               !
            +--+--+
           /  is   \  no
          ! h  =  0 !--------&gt;-------+
           \   ?   /                 !
            +--+--+                  !
               !yes                  !
+--------------+--------------+      !
! set MO, wait 6 index pulses !      !
+--------------+--------------+      !
               !                     !
               !-------&lt;-------------+
               !
           +---+---+
          /   is    \ yes      +-----------+
         ! command a !----&gt;----!    set    !-&gt;-+
          \step-in ?/          ! direction !   !
           +---+---+           +-----------+   !
               !no                             !
          +----+----+                          !
         /    is     \ yes     +-----------+   !
        !  command a  !---&gt;----!   reset   !-&gt;-+
         \ stepout ? /         ! direction !   !
          +----+----+          +-----------+   !
               !no                             !
           +---+---+                           !
          /   is    \ yes                      !
         ! command a !-----------------------&gt;-+
          \ step ?  /                          !
           +---+---+                           !
               !no                             !
           +---+---+                        +--+--+
          /   is    \ yes              yes /  is   \
         ! command a !-----+        +-&lt;---!  u = 1  !
          \  seek   /      !        !      \   ?   /
           +---+---+       !        !       +--+--+
   restore     !no         !        !          !no
         +-----+-----+     !        !          !
         ! FF to TR  !     !        !          !
         +-----+-----+     !        !          !
               !           !        !          !
         +-----+-----+     !        !          !
         !  0 to DR  !-&lt;---+        !          !
         +-----+-----+              !          !
               !                    !          !
             +-+-+                +-+-+      +-+-+
             ! A !                ! B !      ! C !
              \ /                  \ /        \ /

              +---+
              ! A !
               \ /
                !
+-----------&gt;---!
!               !
!         +-----+-----+
!         ! DR to DSR !
!         +-----+-----+
!               !
!            +--+--+
!           /  is   \ yes
!          ! TR =DSR !-------------------&gt;--------+
!           \   ?   /                             !
!            +--+--+                              !
!               !no                               !
!            +--+--+                              !
!           /   is  \ yes                         !
!          ! DSR&lt; TR !---------&gt;----+             !
! +---+     \   ?   /               !             !
! ! B !      +--+--+                !             !
!  \ /          !no                 !             !
!   !  +--------+--------+  +-------+-------+     !
!   !  ! reset direction !  ! set direction !     !
!   !  +--------+--------+  +-------+-------+     !
!   !           !                   !             !
!   +------&gt;----+------&lt;------------+             !
!               !                                 !
!           +---+---+                             !
!          /    is   \ yes                        !
!         ! direction !------&gt;--+                 !
! +---+    \  = 1 ?  /          !                 !
! ! C !     +---+---+           !                 !
!  \ /          !no             !                 !
!   !      +----+----+     +----+----+            !
!   !      ! inc TR  !     ! dec TR  !            !
!   !      +----+----+     +----+----+            !
!   !           !               !                 !
!   +------&gt;----+-----&lt;---------+                 !
!               !                                 !
!          +----+----+                            !
!         / is head at\ yes  +---------+          !
!        ! track 0 and !---&gt;-! 0 to TR !-------&gt;--+
!        !  direction  !     +---------+          !
!         \  is 0  ?  /                           !
!          +----+----+                            !
!               !no                               !
!   +-----------+-----------+                     !
!   ! issue one step pulse  !                     !
!   +-----------+-----------+                     !
!               !                                 !
!   +-----------+-----------+                     !
!   ! delay acc. to r1, r0  !                     !
!   +-----------+-----------+                     !
!               !                                 !
!        +------+------+                          !
!   no  / is command a  \ yes                     !
+-&lt;----!  step, step-in  !---------&gt;-----+----&lt;---+
        \ or step-out ? /                !
         +-------------+               +-+-+
                                       ! D !
                                        \ /


                         +---+
                         ! D !
                          \ /
                           !
                         +-+-+
                        /  is \ no
                       ! V = 1 !-----&gt;-----+
                        \  ?  /            !
                         +-+-+      /------+------\
                           !yes    ! intrq, reset  !
+-------------&gt;------------+       !  busy status  !
!                          !        \-------------/
!                     +----+----+
!                    /   have 6  \ yes
!                   ! index holes !------&gt;--+
!                    \ passed ?  /          !
!                     +----+----+    /------+-------\
!                          !no      ! intrq, reset   !
!                     +----+----+   ! busy, set seek !
!                 no /  has ID   \  ! error          !
+----&lt;--------------!  am been    !  \--------------/
!                    \ detected  /
!                     +----+----+
!                          !yes
!                     +----+----+
!                 no / does TR = \
+----&lt;--------------! track nr of !
!                    \  ID field /
!                     +----+----+
!                          !yes
!     +-------+       +----+----+
!     !  SET  !  yes / is there  \
+-&lt;---!  CRC  !-&lt;---!    a crc    !
      ! ERROR !      \ CRC error /
      +-------+       +----+----+
                           !no
                     +-----+-----+
                     ! reset CRC !
                     +-----+-----+
                           !
                      /----+-----\
                     !   intrq,   !
                     ! reset busy !
                      \----------/


TYPE 2
                                 !
                                 !
                                 +---&lt;-------+
                                 !           !
                             +---+---+       !
                            / is type \ no   !
                           ! 2 command !---&gt;-+
                            \ received/
                             +---+---+
                                 !yes
                  +--------------+--------------+
                  !     set busy, reset drq,    !
                  ! lost data, record not found !
                  !    status bit 5 &amp; 6 intrq   !
                  +--------------+--------------+
                                 !
                               +-+-+
                           no /  is \
              +--------&lt;-----! h = 1 !
              !               \  ?  /
              !                +-+-+
              !                  !yes
              !         +--------+--------+
              !         !  set MO, wait   !
              !         ! 6 index pulses  !
              !         +--------+--------+
              !                  !
              +-------------&gt;----+
                                 !
                               +-+-+
                              /  is \ no
                             ! E = 1 !---&gt;-+
                              \  ?  /      !
                               +-+-+       !
                                 !yes      !
                     +------&gt;----+         !
                     !           !         !
                     !       +---+---+     !
                     !   no /   has   \    !
            +---+    +-&lt;---!   30 mS   !   !
            ! 4 !           \ expired /    !
             \ /             +---+---+     !
              !                  !yes      !
              +-------------&gt;----+----&lt;----+
                                 !
                             +---+---+
                        yes /   is    \
              +----&lt;-------!  command  !
              !             \ a write /
           +--+--+           +---+---+
          /   is  \              !no
     yes !  write  ! no          !
+---&lt;----! protect !----------&gt;--+
!         \  on ? /              !
!          +--+--+             +-+-+
!                              ! 1 !
!       /-----------------\     \ /
+----&gt;-! intrq, reset busy !
       ! set write protect !
        \-----------------/

                               +-+-+
                               ! 1 !
                                \ /
                                 !
+----------------------&gt;---------+
!                                !
!                           +----+----+
!                          /  have 5   \ yes
!                         ! index holes !---------&gt;-----+
!                          \ passed ?  /                !
!                           +----+----+      /----------+----------\
!                                !no        !  intrq, reset busy    !
!                          +-----+-----+    ! set record not found  !
!                      no /  has ID am  \    \---------------------/
+------&lt;-----------------!     been      !
!                         \  detected ? /
!                          +-----+-----+
!                                !yes
!                          +-----+-----+
!                      no /  does TR =  \
+------&lt;-----------------! track address !
!                         \ of ID field /
!                          +-----+-----+
!                                !yes
!                          +-----+-----+
!                      no /  does SR =  \
+-------&lt;----------------!  sector addr  !
!                         \ of ID field /
!                          +-----+-----+
!                                !yes
!                   +------------+------------+
!                   ! bring in sector length  !
!                   !    field, store in      !
!                   !   internal register     !
!                   +------------+------------+
!                                !
!                            +---+---+
!     +--------------+  yes / is there\ no
+-&lt;---!   set CRC    !-&lt;---!   a crc   !-----&gt;--+
      ! status error !      \ error ? /         !
      +--------------+       +---+---+    +-----+-----+
                                          ! reset CRC !
                                          +-----+-----+
                                                !
                                            +---+---+
                                       yes /   is    \
                                 +--&lt;-----! command a !
                                 !         \ write ? /
                                 !          +---+---+
                                 !              !no
                               +-+-+          +-+-+
                               ! 3 !          ! 2 ! read
                                \ /            \ /

            +-+-+    read sector
            ! 2 !    sequence
             \ /
              !
         +----+----+
        / has data  \ no
       ! AM occurred !----------&gt;-------+
        \ in time ? /                   !
         +----+----+                    !
              !yes                      !
   +----------+----------+            +-+-+
   ! put recording type  !            ! 1 !
   ! in status reg bit 3 !             \ /
   +----------+----------+
              !
              +-----&lt;-------+
              !             !
          +---+---+         !
         /has first\ no     !
        ! byte been !----&gt;--+
        ! assembled !
         \ in DSR ?/
          +---+---+
              !yes
 +------&gt;-----+
 !            !
 !       +----+----+
 !       ! set DRQ !
 !       +----+----+
 !            !
 !            +-----&lt;-------+
 !            !             !
 !        +---+---+         !
 !       / has next\ no     !
 !      ! byte been !----&gt;--+
 !      ! assembled !
 !       \ in DSR ?/
 !        +---+---+
 !            !yes
 !       +----+----+
 !      /  has DR   \ no    +--------+--------+
 !     !  been read  !----&gt;-!  set data lost  !
 !      \  DR = 0 ? /       +--------+--------+
 !       +----+----+                 !
 !            !yes                   !
 !            +-------&lt;--------------+
 !            !
 !       +----+----+             +---+
 !   no / have all  \            ! 5 !
 +-&lt;---!  bytes been !            \ /
        \ inputted  /              !
         +----+----+     +------&gt;--+
              !yes       !         !
            +-+-+        !       +-+-+
           / CRC \ no    !      /  is \ no
          ! error !----&gt;-+     ! M = 1 !----------&gt;----+
           \  ?  /              \  ?  /                !
            +-+-+                +-+-+                 !
              !yes                 !yes                !
              !             +------+------+            !
       /------+------\      ! inc sectreg !            !
      ! intrq, reset  !     +------+------+            !
      ! busy, set crc !            !                   !
      !    error      !          +-+-+        /--------+--------\
       \-------------/           ! 4 !       ! intrq, reset busy !
                                  \ /         \-----------------/


               +---+   write sector
               ! 3 !   sequence
                \ /
                 !
     +-----------+----------+
     ! delay 2 bytes of gap !
     +----------------------+
     !        set drq       !
     +----------------------+
     ! delay 9 bytes of gap !
     +-----------+----------+
                 !
            +----+----+
           /   has DR  \
          ! been loaded !
           \  (DRQ= 0) /
            +----+----+
                 !yes
     +-----------+----------+
     ! delay 1 byte of gap  !--------------+
     +-----------+----------+              !
                                        +--+--+
                                    no /   is  \
                 +------&lt;-------------! notDDEN !
                 !                     \ = 0 ? /
                 !                      +--+--+
         +-------+-------+                 !yes
         ! turn on wg &amp;  !        +--------+--------+
         ! write 6x 00   !        ! delay 11 bytes  !
         +-------+-------+        +--------+--------+
                 !                         !
       +---------+---------+       +-------+-------+
       !   write data AM   !--&lt;----! turn on wg &amp;  !
       !  according to a0  !       ! write 12x 00  !
       ! bit of write cmd  !       +---------------+
       +---------+---------+
                 !
+----------&gt;-----+
!                !
!      +---------+---------+
!      ! DR to DSR,set DRQ !
!      +-------------------+
!      ! write byte to DSR !
!      +---------+---------+
!                !
!            +---+---+
!           /   has   \ no   +---------------+
!          !  dr been  !---&gt;-! set data lost !
!          !   loaded  !     !  write 1x 00  !
!           \ (drq= 0)/      +-------+-------+
!            +---+---+               !
!                !yes                !
!                +--------&lt;----------+
!                !
!           +----+----+
!       no / have all  \ yes
+---&lt;-----!  bytes been !-----&gt;--+
           \ assembled /         !
            +----+----+   +------+------+
                          !  write crc  !
                          +-------------+
                          ! write 1x FF !
                          +-------------+
                          ! turn off wg !
                          +------+------+
                                 !
                               +-+-+
                               ! 5 !
                                \ /

TYPE 3
            !
            +---&lt;--------+
            !            !
         +--+--+         !
        /is this\ no     !
       ! a write !----&gt;--+
        \ track /
         +--+--+
            !yes
+-----------+-----------+
! set busy, reset drq,  !
! lost data (bit 4,5)   !
+-----------+-----------+
            !
          +-+-+
         /  is \ no
        ! h = 1 !-------&gt;-----+
         \  ?  /              !
          +-+-+               !
            !yes              !
   +--------+--------+        !
   ! set MO, wait 6  !        !
   !  index pulses   !        !
   +--------+--------+        !
            !                 !
            +-----&lt;-----------+
            !
          +-+-+
         /  is \ no
        ! E = 1 !---------&gt;------+
         \  ?  /                 !
          +-+-+                  !
            !yes                 !
            +----&lt;-------+       !
            !            !       !
        +---+---+        !       !
       /   has   \ no    !       !
      !  30msec   !---&gt;--+       !
       \ expired /               !
        +---+---+                !
            !yes                 !
            +-------&lt;------------+
            !                                +-------&gt;--+----&lt;-------+
        +---+---+                            !          !            !
       /    is   \ yes      /-------------\  !    +-----+----+       !
      !   notWPRT !-----&gt;--! intrq, reset  ! !   /     has    \ no   !
       \  = 0 ?  /         ! busy set wprt ! !   ! index pulse !---&gt;-+
        +---+---+           \-------------/  !    \ occurred  /
            !no                              !     +----+----+     +---+
    +-------+-------+                        !          !yes       ! A !
    !    set DRQ    !                        !          !           \ /
    +-------+-------+                        !          !            !
            !                                !          !---&lt;--------+
    +-------+-------+                        !          !
    ! delay 3 byte  !                        !    +-----+-----+
    !     times     !                        !    ! DR to DSR !
    +-------+-------+                        !    +-----+-----+
            !                                !          !
         +--+--+        /----------------\   !    +-----+-----+
        /  has  \ no   ! intrq, set lost  !  !    !  set DRQ  !
       ! DRQ been!---&gt;-! data, reset busy !  !    +-----+-----+
        \service/       \----------------/   !          !
         +--+--+                             !        +-+-+
            !yes                             !        ! B !
            +----------------------&gt;---------+         \ /

                              +---+
                              ! B !
                               \ /
                                !
                             +--+--+
                   no (FM)  /   is  \  yes (MFM)
     +-------&lt;-------------! notDDEN !----------------&gt;--------+
     !                      \ = 0 ? /                          !
     !                       +--+--+                           !
  +--+--+                                                   +--+--+
 /   is  \ yes  +-----------+       +---------------+  yes /   is  \
! DSR=$F7 !---&gt;-! wt 2x CRC !-&gt;-+-&lt;-! wt A1 in MFM, !-&lt;---! DSR=$F5 !
 \   ?   /      ! CLK = FF  !   !   ! missing CLK,  !      \   ?   /
  +--+--+       +-----------+   !   !   init CRC    !       +--+--+
     !no                        !   +---------------+          !no
  +--+--+                       !                           +--+--+
 /   is  \ yes  +-----------+   !   +---------------+  yes /   is  \
! DSR=$FC !---&gt;-! write FC, !-&gt;-+-&lt;-! wt C2 in MFM, !-&lt;---! DSR=$F6 !
 \       /      ! CLK = F7  !   !   !    with       !      \   ?   /
  +--+--+       +-----------+   !   ! missing CLK   !       +--+--+
     !no                        !   +---------------+          !no
  +--+--+       +-----------+   !                           +--+--+
 /is DSR \ yes  ! wt FD,FE, !   !   +---------------+  yes /   is  \
! FD,FE or!---&gt;-! F8-FB,CLK !-&gt;-+-&lt;-!    generate   !-&lt;---! DSR=$F7 !
 \ F8-FB /      !=C7,initCRC!   !   !  2 bytes CRC  !      \       /
  +--+--+       +-----------+   !   +---------------+       +--+--+
     !no                        !                              !no
+----+----+                     !                         +----+----+
! wt DSR, !-------------&gt;-------+----&lt;--------------------! wt DSR  !
! CLK=$FF !                     !                         ! in MFM  !
+---------+                     +----&lt;--------------+     +---------+
                                !                   !
                            +---+---+               !
      /------------\   yes /  phys   \              !
     ! intrq, reset !-&lt;---! index mark!             !
     !  busy flag  !       \    ?    /              !
      \------------/        +---+---+               !
                                !                   !
                            +---+---+               !
                       yes / has DSR \ no   +-------+-------+
              +---&lt;-------!   been    !---&gt;-!   wt 1x 00    !
              !            \ loaded ?/      ! set data lost !
            +-+-+           +-------+       +---------------+
            ! A !
             \ /

</pre>
<p>
<br>
</p>
<p>Programming information from the data sheets for the Western
Digital 1770-00 and 1772-00 floppy disk drive controllers. David
Gahris, dgahris@eece.maine.edu, typed and edited this on 10 Mar 1995.
<br>
</p>
<p>Unless I note otherwise, this file applies to both the 1770-00 and
the 1772-00, and I do not deal with other chips in the 1770 family,
such as the 1773-00 or the 1770-02. I call the 1770 and the 1772
collectively the 177x. Except as noted, &quot;clock cycles&quot; are
<a href="080108.htm" target="UDOcon">CPU</a> clock cycles at exactly 1 MHz.
<br>
<br>
<br>
</p>
<p><b> OUTLINE OF CONTENTS: </b>
<br>
<br>Registers
<br>Commands
<br>Interrupts
<br>Disk Formatting
<br>Miscellaneous
<br>
</p>
<p>
<br>
<br><b> REGISTERS: </b>
<br>
</p>
<p>The names are self-explanatory. All registers are 8 bits wide.
After the <a href="080108.htm" target="UDOcon">CPU</a> writes to any register, it cannot read that register for
16 cycles.
<br>
</p>
<p>r0 (write) - Command Register - When the 177x is busy, it ignores
<a href="080108.htm" target="UDOcon">CPU</a> writes to this register UNLESS the new command is a force
interrupt.
<br>
</p>
<p>r0 (read) - Status Register - The value in this register depends
on the previous 177x command. If the 177x receives a Force Interrupt
command while it is executing another command, the FDDC will clear the
Busy bit (Status bit 0: see later in this paragraph), and leave all
other Status bits unchanged. If the 177x receives a Force Interrupt
command while it is not executing a command, the 177x will update the
entire Status Register as though it had just executed a Type I
command. (For an explanation of Type I, Type II, Type III, and Type IV
commands, see the section on commands.) When the <a href="080108.htm" target="UDOcon">CPU</a> is connected
(directly or indirectly) to the 177x's interrupt output, it is a bad
idea to check the Busy bit because a <a href="080108.htm" target="UDOcon">CPU</a> read of the Status Register
clears the 177x's interrupt output. After the <a href="080108.htm" target="UDOcon">CPU</a> writes to the
Command Register, it should not attempt to read the Busy bit for 24
cycles. The <a href="080108.htm" target="UDOcon">CPU</a> should not follow a Command Register write with a read
of Status bits 1-7 until 32 clock cycles have elapsed.
<br>
</p>
<p>Bits:
<br>Bit 7 - Motor On. This bit is high when the drive motor is on, and
low when the motor is off.
<br>
</p>
<p>Bit 6 - Write Protect. This bit is not used during reads. During
writes, this bit is high when the disk is write protected.
<br>
</p>
<p>Bit 5 - Spin-up / Record Type. For Type I commands, this bit is
low during the 6-revolution motor spin-up time. This bit is high after
spin-up. For Type II and Type III commands, Bit 5 low indicates a
normal data mark. Bit 5 high indicates a deleted data mark.
<br>
</p>
<p>Bit 4 - Record Not Found. This bit is set if the 177x cannot find
the track, sector, or side which the <a href="080108.htm" target="UDOcon">CPU</a> requested. Otherwise, this
bit is clear.
<br>
</p>
<p>Bit 3 - CRC Error. This bit is high if a sector CRC on disk does
not match the CRC which the 177x computed from the data. The CRC
polynomial is x^16+x^12+x^5+1. If the stored CRC matches the newly
calculated CRC, the CRC Error bit is low. If this bit and the Record
Not Found bit are set, the error was in an ID field. If this bit is
set but Record Not Found is clear, the error was in a data field.
<br>
</p>
<p>Bit 2 - Track Zero / Lost Data. After Type I commands, this bit is
0 if the mechanism is at track zero. This bit is 1 if the head is not
at track zero. After Type II or III commands, this bit is 1 if the <a href="080108.htm" target="UDOcon">CPU</a>
did not respond to Data Request (Status bit 1) in time for the 177x to
maintain a continuous data flow. This bit is 0 if the <a href="080108.htm" target="UDOcon">CPU</a> responded
promptly to Data Request.
<br>
</p>
<p>Bit 1 - Index / Data Request. On Type I commands, this bit is high
during the index pulse that occurs once per disk rotation. This bit is
low at all times other than the index pulse. For Type II and III
commands, Bit 1 high signals the <a href="080108.htm" target="UDOcon">CPU</a> to handle the data register in
order to maintain a continuous flow of data. Bit 1 is high when the
data register is full during a read or when the data register is empty
during a write. &quot;Worst case service time&quot; for Data Request
is 23.5 cycles.
<br>
</p>
<p>Bit 0 - Busy. This bit is 1 when the 177x is busy. This bit is 0
when the 177x is free for <a href="080108.htm" target="UDOcon">CPU</a> commands.
<br>
</p>
<p>r1 (r/w) - Track Register - The outermost track on the disk is
numbered 0. During disk reading, writing, and verifying, the 177x
compares the Track Register to the track number in the sector ID
field. When the 177x is busy, it ignores <a href="080108.htm" target="UDOcon">CPU</a> writes to this register.
The highest legal track number is 240.
<br>
</p>
<p>r2 (r/w) - Sector Register - During disk reading and writing, the
177x compares the Sector Register to the sector number in the sector
ID field. When the 177x is busy, it ignores <a href="080108.htm" target="UDOcon">CPU</a> writes to this
register. Valid sector numbers range from 1 to 240, inclusive.
<br>
</p>
<p>r3 (r/w) - Data Register
<br>
</p>
<p>
<br>
<br>
</p>
<p><b> COMMANDS: </b>
<br>
</p>
<p>The 177x accepts 11 commands. Western Digital divides these
commands into four categories, labeled I,II, III, and IV.
<br>
</p>
<p>Type I commands are Restore, Seek, Step, Step In, and Step Out.
<br>
<br>The following table is a bit map of the values to store in the
Command Register.
<br>
</p>
<pre>Command      Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
--------     -----     --     --     --     --     --     --     -----
Restore      0         0      0      0      h      V      r1     r0
Seek         0         0      0      1      h      V      r1     r0
Step         0         0      1      u      h      V      r1     r0
Step in      0         1      0      u      h      V      r1     r0
Step out     0         1      1      u      h      V      r1     r0

</pre>
<p>
<br>
</p>
<p>Flags:
<br>
</p>
<p>u (Update Track Register) - If this flag is set, the 177x will
update the track register after executing the command. If this flag is
cleared, the 177x will not update the track register.
<br>
</p>
<p>h (Motor On) - If the value of this bit is 1, the controller will
disable the motor spin-up sequence. Otherwise, if the motor is off
when the chip receives a command, the chip will turn the motor on and
wait 6 revolutions before executing the command. At 300 RPM, the
6-revolution wait guarantees a one-second start time. If the 177x is
idle for 9 consecutive disk revolutions, it turns off the drive motor.
If the 177x receives a command while the motor is on, the controller
executes the command immediately.
<br>
</p>
<p>V (Verify) - If this flag is set, the head settles after command
execution. The settling time is 15 000 cycles for the 1772 and 30 000
cycles for the 1770. The FDDC will then verify the track position of
the head. The 177x reads the first ID field it finds and compares the
track number in that ID field against the Track Register. If the track
numbers match but the ID field CRC is invalid, the 177x sets the CRC
Error bit in the status register and reads the next ID field. If the
177x does not find a sector with valid track number AND valid CRC
within 5 disk rotations, the chip sets the Seek Error bit in the
status register.
<br>
<br>r (Step Time) - This bit pair determines the time between track
steps according to the following table:
<br>
<br>
</p>
<pre>
r1       r0            1770                                        1772
--       --            ----                                        ----
0        0             6000 <a href="080108.htm" target="UDOcon">CPU</a> clock cycles                       6000 cycles
0        1             12000 cycles                                12000 cycles
1        0             20 000 cycles                               2000 cycles
1        1             30 000 cycles                               3000 cycles

</pre>
<p>
<br>
</p>
<p>Restore:
<br>If the FDDC receives this command when the drive head is at track
zero, the chip sets its Track Register to $00 and ends the command. If
the head is not at track zero, the FDDC steps the head carriage until
the head arrives at track 0. The 177x then sets its Track Register to
$00 and ends the command. If the chip's track-zero input does not
activate after 255 step pulses AND the V bit is set in the command
word, the 177x sets the Seek Error bit in the status register and ends
the command.
<br>
<br>Seek:
<br>The <a href="080108.htm" target="UDOcon">CPU</a> must load the desired track number into the Data Register
before issuing this command. The Seek command causes the 177x to step
the head to the desired track number and update the Track Register.
<br>
<br>Step:
<br>The 177x issues one step pulse to the mechanism, then delays one
step time according to the r flag.
<br>
<br>Step in:
<br>The 177x issues one step pulse in the direction toward Track 76
and waits one step time according to the r flag. [Transcriber's Note:
Western Digital assumes in this paragraph that disks do not have more
than 77 tracks.]
<br>
</p>
<p>Step out:
<br>The 177x issues one step pulse in the direction toward Track 0 and
waits one step time according to the r flag.
<br>
<br>
</p>
<p>Type II commands are Read Sector and Write Sector.
<br>
<br>
</p>
<pre>
Command          Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
------------     -----     --     --     --     --     --     --     -----
Read Sector      1         0      0      m      h      E      0      0
Write Sector     1         0      1      m      h      E      P      a0

</pre>
<p>
<br>Flags:
<br>
</p>
<p>m (Multiple Sectors) - If this bit = 0, the 177x reads or writes
(&quot;accesses&quot;) only one sector. If this bit = 1, the 177x
sequentially accesses sectors up to and including the last sector on
the track. A multiple-sector command will end prematurely when the <a href="080108.htm" target="UDOcon">CPU</a>
loads a Force Interrupt command into the Command Register.
<br>
</p>
<p>h (Motor On) - If the value of this bit is 1, the controller will
disable the motor spin-up sequence. Otherwise, if the motor is off
when the chip receives a command, the chip will turn the motor on and
wait 6 revolutions before executing the command. At 300 RPM, the
6-revolution wait guarantees a one- second start time. If the 177x is
idle for 9 consecutive disk revolutions, it turns off the drive motor.
If the 177x receives a command while the motor is on, the controller
executes the command immediately.
<br>
</p>
<p>E (Settling Delay) - If this flag is set, the head settles before
command execution. The settling time is 15 000 cycles for the 1772 and
30 000 cycles for the 1770.
<br>
</p>
<p>P (Write Precompensation) - On the 1770-02 and 1772-00, a 0 value
in this bit enables automatic write precompensation. The FDDC delays
or advances the write bit stream by one-eighth of a cycle according to
the following table.
<br>
<br>
</p>
<pre>
Previous          Current bit           Next bit
bits sent         sending               to be sent       Precompensation
---------         -----------           ----------       ---------------
x       1         1                     0                Early
x       0         1                     1                Late
0       0         0                     1                Early
1       0         0                     0                Late

</pre>
<p>
<br>
</p>
<p>Programmers typically enable precompensation on the innermost
tracks, where bit shifts usually occur and bit density is maximal. A 1
value for this flag disables write precompensation.
<br>
</p>
<p>a0 (Data Address Mark) - If this bit is 0, the 177x will write a
normal data mark. If this bit is 1, the 177x will write a deleted data
mark.
<br>
<br>Read Sector:
<br>The controller waits for a sector ID field that has the correct
track number, sector number, and CRC. The controller then checks for
the Data Address Mark, which consists of 43 copies of the second byte
of the CRC. If the controller does not find a sector with correct ID
field and address mark within 5 disk revolutions, the command ends.
Once the 177x finds the desired sector, it loads the bytes of that
sector into the data register. If there is a CRC error at the end of
the data field, the 177x sets the CRC Error bit in the Status Register
and ends the command regardless of the state of the &quot;m&quot;
flag.
<br>
<br>Write Sector:
<br>The 177x waits for a sector ID field with the correct track
number, sector number, and CRC. The 177x then counts off 22 bytes from
the CRC field. If the <a href="080108.htm" target="UDOcon">CPU</a> has not loaded a byte into the Data Register
before the end of this 22-byte delay, the 177x ends the command.
Assuming that the <a href="080108.htm" target="UDOcon">CPU</a> has heeded the 177x's data request, the
controller writes 12 bytes of zeroes. The 177x then writes a normal or
deleted Data Address Mark according to the a0 flag of the command.
Next, the 177x writes the byte which the <a href="080108.htm" target="UDOcon">CPU</a> placed in the Data
Register, and continues to request and write data bytes until the end
of the sector. After the 177x writes the last byte, it calculates and
writes the 16-bit CRC. The chip then writes one $ff byte. The 177x
interrupts the <a href="080108.htm" target="UDOcon">CPU</a> 24 cycles after it writes the second byte of the
CRC.
<br>
</p>
<p>
<br>Type III commands are Read Address, Read Track, and Write Track.
<br>
<br>
</p>
<pre>
Command          Bit 7     B6     B5     B4     B3     B2     B1     Bit 0
------------     -----     --     --     --     --     --     --     -----
Read Address     1         1      0      0      h      E      0      0
Read Track       1         1      1      0      h      E      0      0
Write Track      1         1      1      1      h      E      P      0

</pre>
<p>
<br>Flags:
<br>
</p>
<p>h (Motor On) - If the value of this bit is 1, the controller will
disable the motor spin-up sequence. Otherwise, if the motor is off
when the chip receives a command, the chip will turn the motor on and
wait 6 revolutions before executing the command. At 300 RPM, the
6-revolution wait guarantees a one- second start time. If the 177x is
idle for 9 consecutive disk revolutions, it turns off the drive motor.
If the 177x receives a command while the motor is on, the controller
executes the command immediately.
<br>
</p>
<p>E (Settling Delay) - If this flag is set, the head settles before
command execution. The settling time is 15 000 cycles for the 1772 and
30 000 cycles for the 1770.
<br>
</p>
<p>P (Write Precompensation) - On the 1770-02 and 1772-00, a 0 value
in this bit enables automatic write precompensation. The FDDC delays
or advances the write bit stream by one-eighth of a cycle according to
the following table.
<br>
<br>
</p>
<pre>
Previous          Current bit           Next bit
bits sent         sending               to be sent       Precompensation
---------         -----------           ----------       ---------------
x       1         1                     0                Early
x       0         1                     1                Late
0       0         0                     1                Early
1       0         0                     0                Late

</pre>
<p>
<br>
</p>
<p>Programmers typically enable precompensation on the innermost
tracks, where bit shifts usually occur and bit density is maximal. A 1
value for this flag disables write precompensation.
<br>
<br>Read Address:
<br>The 177x reads the next ID field it finds, then sends the <a href="080108.htm" target="UDOcon">CPU</a> the
following six bytes via the Data Register:
<br>
<br>
</p>
<pre>
Byte #     Meaning                |     Sector length code     Sector length
------     ------------------     |     ------------------     -------------
1          Track                  |     0                      128
2          Side                   |     1                      256
3          Sector                 |     2                      512
4          Sector length code     |     3                      1024
5          CRC byte 1             |
6          CRC byte 2             |

</pre>
<p>
<br>
</p>
<p>[Transcriber's Note: | is the vertical bar character.]
<br>
</p>
<p>The 177x copies the track address into the Sector Register. The
chip sets the CRC Error bit in the status register if the CRC is
invalid.
<br>
</p>
<p>Read Track:
<br>This command dumps a raw track, including gaps, ID fields, and
data, into the Data Register. The FDDC starts reading with the leading
edge of the first index pulse it finds, and stops reading with the
next index pulse. During this command, the FDDC does not check CRCs.
The address mark detector is on during the entire command. (The
address mark detector detects ID, data and index address marks during
read and write operations.) Because the address mark detector is
always on, write splices or noise may cause the chip to look for an
address mark. [Transcriber's Note: I do not know how the programmer
can tell that the AM detector has found an address mark.] The chip may
read gap bytes incorrectly during write-splice time because of
synchronization.
<br>
<br>Write Track:
<br>This command is the means of formatting disks. The drive head must
be over the correct track BEFORE the <a href="080108.htm" target="UDOcon">CPU</a> issues the Write Track
command. Writing starts with the leading edge of the first index pulse
which the 177x finds. The 177x stops writing when it encounters the
next index pulse. The 177x sets the Data Request bit immediately after
receiving the Write Track command, but does not start writing until
the <a href="080108.htm" target="UDOcon">CPU</a> loads the Data Register. If the <a href="080108.htm" target="UDOcon">CPU</a> does not send the 177x a
byte within three byte times after the first index pulse, the 177x
ends the command. The 177x will write all data values from $00 to $f4
(inclusive) and from $f8 to $ff (inclusive) unaltered. Data values
$f5, $f6, and $f7, however, have special meanings. The value $f5 means
to write an $a1 to the disk. The $a1 value which the 177x writes to
the disk will lack an MFM clock transition between bits 4 and 5. This
missing clock transition indicates that the next normally written byte
will be an address mark. In addition, a Data Register value of $f5
will reset the 177x's CRC generator. A Data Register value of $f6 will
not reset the CRC generator but will write a pre- address-mark value
of $c2 to the disk. The written $c2 will lack an MFM clock transition
between bits 3 and 4. A Data Register value of $f7 will write a
two-byte CRC to the disk.
<br>
<br>
<br>The Type IV command is Force Interrupt.
<br>
</p>
<p>Force Interrupt:
<br>Programmers use this command to stop a multiple-sector read or
write command or to ensure Type I status in the Status Register. The
format of this command is %1101(I3)(I2)00. If flag I2 is set, the 177x
will acknowledge the command at the next index pulse. If flag I3 is
set, the 177x will immediately stop what it is doing and generate an
interrupt. If neither I2 nor I3 are set, the 177x will not interrupt
the <a href="080108.htm" target="UDOcon">CPU</a>, but will immediately stop any command in progress. After the
<a href="080108.htm" target="UDOcon">CPU</a> issues an immediate interrupt command ($d8), it MUST write $d0
(Force Interrupt, I2 clear, I3 clear) to the Command Register in order
to shut off the 177x's interrupt output. After any Force Interrupt
command, the <a href="080108.htm" target="UDOcon">CPU</a> must wait 16 cycles before issuing any other command.
If the <a href="080108.htm" target="UDOcon">CPU</a> does not wait, the 177x will ignore the previous Force
Interrupt command. Because the 177x is microcoded, it will acknowledge
Force Interrupt commands only between micro- instructions.
<br>
<br>
<br>
</p>
<p><b> INTERRUPTS: </b>
<br>
</p>
<p>The 177x interrupts the <a href="080108.htm" target="UDOcon">CPU</a>: *each time it finishes a command, *if
a Force Interrupt condition is true, or *if the FDDC tries to write to
a write-protected disk. The 177x's interrupt output pin resets when
the <a href="080108.htm" target="UDOcon">CPU</a> reads the status register or writes to the command register,
except after a Force Interrupt (immediate) command. See the section on
the Force Interrupt command.
<br>
<br>
</p>
<p><b> DISK FORMATTING: </b>
<br>
</p>
<p>The 177x formats disks according to the IBM 3740 or System/34
standard. See the Write Track command for the <a href="080108.htm" target="UDOcon">CPU</a> formatting method.
The recommended physical format for 256-byte sectors is as follows.
<br>
</p>
<p>
<br>
</p>
<pre>

Number of Bytes     Value of Byte      Comments
---------------     -------------      --------
60                  $4e                Gap 1 and Gap 3.  Start and end of index
                                       pulse.
12                  $00                Gap 3.  Start of bytes repeated for each
                                       sector.
3                   $a1                Gap 3.  Start of ID field.  See section
                                       on Write Track command.
1                   $fe                ID address mark
1                   track #            $00 through $4c (0 through 76)
1                   side #             0 or 1
1                   sector #           $01 through $10 (1 through 16)
1                   length code        See section on Read Address command.
2                   CRC                End of ID field.  See section on Write
                                       Track command.
22                  $4e                Gap 2.
12                  $00                Gap 2.  During Write Sector commands the
                                       drive starts writing at the start
                                       of this.
3                   $a1                Gap 2.  Start of data field.  See
                                       section on Write Track command.
1                   $fb                data address mark
256                 data               Values $f5, $f6, and $f7 invalid.  See
                                       section on Write Track command.  IBM
                                       uses $e5.
2                   CRC                End of data field.  See section on Write
                                       Track command.
24                  $4e                Gap 4.  End of bytes repeated for each
                                       sector.  During Write Sector
                                       commands the drive stops writing shortly
                                       after the beginning of this.
668                 $4e                Continue writing until the 177x
                                       generates an interrupt.  The listed byte
                                       count is approximate.

</pre>
<p>
<br>Variations in the recommended formats are possible if the
following requirements are met:
<br>
<br>(1) Sector size must be 128, 256, 512, or 1024 bytes.
<br>(2) All address mark indicators ($a1) must be 3 bytes long.
<br>(3) The $4e section of Gap 2 must be 22 bytes long. The $00
section of Gap 2 must be 12 bytes long.
<br>(4) The $4e section of Gap 3 must be at least 24 bytes long. The
$00 section of Gap 3 must be at least 8 bytes long.
<br>(5) Gaps 1 and 4 must be at least 2 bytes long. These gaps should
be longer to allow for PLL lock time, motor speed variations, and
write splice time.
<br>
</p>
<p>The 177x does not require an Index Address Mark.
<br>
<br>
<br>
</p>
<p><b> MISCELLANEOUS: </b>
<br>
</p>
<p>The chip steps the drive head in the same direction it last
stepped unless the command changes the direction. Each step pulse
takes 4 cycles. The 177x begins outputting a direction signal to the
drive 24 cycles before the first stepping pulse. The 177x is designed
for a head data rate of 250 kilobits per second. If the <a href="080108.htm" target="UDOcon">CPU</a> does not
give the 177x a byte by the time the 177x needs to write to the disk,
the 177x writes a zero byte instead. The minimum cycle time of the raw
head data input is 3 <a href="080108.htm" target="UDOcon">CPU</a> clock cycles. The head data output has a
cycle time of 4, 6, or 8 <a href="080108.htm" target="UDOcon">CPU</a> clock cycles. The head data output pulse
width is .82 clock cycles for an early bit, .69 cycles for a normal
bit, and .57 cycles for a late bit. See the Commands section for
information on write precompensation. The 1772-02 is 100%
software-compatible with the 1772-00. During DMA between the 177x and
<a href="080108.htm" target="UDOcon">CPU</a> RAM, the DRQ (Data Request) pin of the 177x controls data
transfer. The DRQ pin is high when the Data Request bit in the Status
Register is high, and the DRQ pin is low when the Data Request bit is
low.
<br>
</p>
<p>
<br>
<br>
</p>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img.gif" border=0 width="50" height="40"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de/">Robert Schaffner</a> (<a href="mailto:doit@doitarchive.de">doit@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Mai 2004</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080102.htm" target="UDOcon"><img src="udo_lf.gif" alt="Atari ST DMA" border=0 width="24" height="24"></a>
<a href="080104.htm" target="UDOcon"><img src="udo_rg.gif" alt="Blitter" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>

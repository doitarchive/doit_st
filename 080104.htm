<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.05.2004 -->
<html>
<head>
<title>
DOIT_ST - Tips u. Tricks zur Atari Serie: Blitter
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="doit@doitarchive.de">
<link rev=made href="mailto:doit@doitarchive.de" title="E-Mail">
<link rel=home href="doitst1h.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080103.htm" target="UDOcon"><img src="udo_lf.gif" alt="WD1772 FDC" border=0 width="24" height="24"></a>
<a href="080105.htm" target="UDOcon"><img src="udo_rg.gif" alt="MMU" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="Blitter">8.1.4 Blitter</a></h1>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p><tt> Der Blitter Chip </tt>
<br>
<br>
</p>
<p><img src="image/deutsch.gif" border=0 width="35" height="22"></p><br>
<p><img src="image/english.gif" border=0 width="35" height="22"></p><br>
<p>In einigen Modellen kann ein Blitterchip nachger&uuml;stet werden.
<br>Allerdings ist das eine fragliche Investition da man z.B mit dem
k&auml;uflichen NVDI Softwarebeschleuniger genau das gleiche, wenn
nicht besseres, erreicht.
<br>
</p>
<p>Es gibt 1040 STE Modelle die offensichtlich keinen Blitter haben.
Der L&ouml;tplatz U101 ist jedenfalls leer. Nicht mal ein Sockel.
<br>
</p>
<p>Bei diesen neueren STE wurde der Blitter mit im COMBEL integriert,
so da&#186; daf&#166;r kein extra Chip mehr n&Uuml;tig ist.
<br>
</p>
<p>
<br>
</p>
<p><b> Expand your System </b>
<br>
</p>
<p>In some Atari modells an blitter can be added to the system.
<br>Some modells only with plug in the chip and solder two jumper, in
other computers you have to add a chip socked.
<br>
</p>
<dl>
<dt><b>520 STFM</b></dt><dd>
<br>&nbsp;
<br>Some 520STFM, motherboard C070789-001 REV D, as example, contain
an empty socked U66. That's for an 68 pin PLCC chip.
<br>&nbsp;
<br>On the REV D board the space for a blitter socket is at front
right, next to the cut-out. I installed a blitter on mine, but can't
remember whether I needed to change a couple of solder pad bridges or
not. I got it and the socket from Best Electronics, which came with
instructions. The main chore is solder-suckering out all the pesky
little holes :-)
<br>&nbsp;
</dl>
<p>
<br>
<br>
</p>
<p><b> Blitter Description General</b>
<br>
</p>
<p>The blitter is an Atari chip for moving/combining areas of memory
without use performance from the <a href="080108.htm" target="UDOcon">CPU</a>. It is especially useful for
programs ow was used a lot of graphics, but it also doasn't work with
some software.
</p>
<p>Best way while using NVDI, deactivate the Blitter chip!
<br>
</p>
<p>The chip was only installed in a some late ST's modells, but
become a standard in later STe computers. Attempting to access the
blitter addressing space without a blitter chip installed will result
in a bus error.
<br>
</p>
<p>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 54: 68 pin PLCC Blitter Chip Pinout</caption>
<tr>
  <td align=left valign=top>Pin</td>
  <td align=left valign=top>Bus Signal</td>
  <td align=left valign=top>Pin</td>
  <td align=left valign=top>Bus Signal</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>Vcc</td>
  <td align=left valign=top>35</td>
  <td align=left valign=top>GND</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>2</td>
  <td align=left valign=top>A21</td>
  <td align=left valign=top>36</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>3</td>
  <td align=left valign=top>A22</td>
  <td align=left valign=top>37</td>
  <td align=left valign=top>BG</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>4</td>
  <td align=left valign=top>A23</td>
  <td align=left valign=top>38</td>
  <td align=left valign=top>RESET</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>5</td>
  <td align=left valign=top>Vss</td>
  <td align=left valign=top>39</td>
  <td align=left valign=top>BERR</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>6</td>
  <td align=left valign=top>D15</td>
  <td align=left valign=top>40</td>
  <td align=left valign=top>BGACK</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>7</td>
  <td align=left valign=top>D14</td>
  <td align=left valign=top>41</td>
  <td align=left valign=top>INT</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>8</td>
  <td align=left valign=top>D13</td>
  <td align=left valign=top>42</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>9</td>
  <td align=left valign=top>D12</td>
  <td align=left valign=top>43</td>
  <td align=left valign=top>FC2</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>10</td>
  <td align=left valign=top>D11</td>
  <td align=left valign=top>44</td>
  <td align=left valign=top>FC1</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>11</td>
  <td align=left valign=top>D10</td>
  <td align=left valign=top>45</td>
  <td align=left valign=top>FC0</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>12</td>
  <td align=left valign=top>D9</td>
  <td align=left valign=top>46</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>13</td>
  <td align=left valign=top>D8</td>
  <td align=left valign=top>47</td>
  <td align=left valign=top>A1</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>14</td>
  <td align=left valign=top>D7</td>
  <td align=left valign=top>48</td>
  <td align=left valign=top>A2</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>15</td>
  <td align=left valign=top>D6</td>
  <td align=left valign=top>49</td>
  <td align=left valign=top>A3</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>16</td>
  <td align=left valign=top>D5</td>
  <td align=left valign=top>50</td>
  <td align=left valign=top>A4</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>17</td>
  <td align=left valign=top>D4</td>
  <td align=left valign=top>51</td>
  <td align=left valign=top>A5</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>18</td>
  <td align=left valign=top>D3</td>
  <td align=left valign=top>52</td>
  <td align=left valign=top>A6</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>19</td>
  <td align=left valign=top>D2</td>
  <td align=left valign=top>53</td>
  <td align=left valign=top>A7</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>20</td>
  <td align=left valign=top>D1</td>
  <td align=left valign=top>54</td>
  <td align=left valign=top>A8</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>21</td>
  <td align=left valign=top>D0</td>
  <td align=left valign=top>55</td>
  <td align=left valign=top>A9</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>22</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top>56</td>
  <td align=left valign=top>A10</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>23</td>
  <td align=left valign=top>AS</td>
  <td align=left valign=top>57</td>
  <td align=left valign=top>A11</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>24</td>
  <td align=left valign=top>UDS</td>
  <td align=left valign=top>58</td>
  <td align=left valign=top>A12</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>25</td>
  <td align=left valign=top>LDS</td>
  <td align=left valign=top>59</td>
  <td align=left valign=top>A13</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>26</td>
  <td align=left valign=top>R/W</td>
  <td align=left valign=top>60</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>27</td>
  <td align=left valign=top>DTACK</td>
  <td align=left valign=top>61</td>
  <td align=left valign=top>A14</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>28</td>
  <td align=left valign=top>BG</td>
  <td align=left valign=top>62</td>
  <td align=left valign=top>A15</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>29</td>
  <td align=left valign=top>BGACK</td>
  <td align=left valign=top>63</td>
  <td align=left valign=top>A16</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>30</td>
  <td align=left valign=top>BR</td>
  <td align=left valign=top>64</td>
  <td align=left valign=top>A17</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>31</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top>65</td>
  <td align=left valign=top>A18</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>32</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top>66</td>
  <td align=left valign=top>A19</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>33</td>
  <td align=left valign=top>Vss</td>
  <td align=left valign=top>67</td>
  <td align=left valign=top>A20</td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>34</td>
  <td align=left valign=top>CLK</td>
  <td align=left valign=top>68</td>
  <td align=left valign=top>N/C</td>
  <td align=left valign=top></td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p align=center><img src="image/blitter.gif" border=0 width="318" height="294"></p><br>
<div align=center><tt> Abbildung 1 - Atari PLCC Blitter </tt>
<br>
</div>
<p>
<br>
<br>
</p>
<p>
<br>
</p>
<pre>
                                  **** (!nl)
                                  **** (!nl)
                                  **** (!nl)
                                 ****** (!nl)
                                ** ** ** (!nl)
                               **  **  ** (!nl)
                             **    **    ** (!nl)
 (!nl)
                      User Manual for the <a href="0305.htm" target="UDOcon">Atari ST</a> (!nl)
 (!nl)
                 Bit-Block Transfer Processor (BLiTTER) (!nl)
                  (!nl)


!end_center
(!nl)

                            TABLE OF CONTENTS (!nl)


Introduction ............................    1 (!nl)
 (!nl)
Bit-Block Transfers .....................    2 (!nl)
Bit-Block Transfer ......................    3 (!nl)
 (!nl)
Functional Description ..................    3 (!nl)
 (!nl)
Programming Model .......................    5 (!nl)
Register Map ............................    5 (!nl)
Bit-Block Addresses .....................    5 (!nl)
Source X Increment ......................    6 (!nl)
Source Y Increment ......................    6 (!nl)
Destination Address .....................    6 (!nl)
Destination X Increment .................    6 (!nl)
Destination Y Increment .................    6 (!nl)
X Count .................................    7 (!nl)
Y Count .................................    7 (!nl)
Bit-Block Alignments ....................    7 (!nl)
Endmask 1, 2, 3 .........................    7 (!nl)
Skew ....................................    7 (!nl)
FXSR ....................................    7 (!nl)
NSFR ....................................    8 (!nl)
Logic Operations ........................    8 (!nl)
Logic Operations ........................    8 (!nl)
Halftone Operations .....................    8 (!nl)
Halftone RAM ............................    8 (!nl)
Line Number .............................    8 (!nl)
Smudge ..................................    9 (!nl)
Halftone Operations .....................    9 (!nl)
Bus Accesses ............................    9 (!nl)
Hog .....................................    9 (!nl)
Busy ....................................    9 (!nl)
 (!nl)
Appendix A -- Programming Example .......   10 (!nl)
        (!nl)
Appendix B -- References ................   17 (!nl)
</pre>
<div align=center>
<br>
<br>
<br>
</div>
<div align=center>THE SCOPE OF THIS DOCUMENT is limited to a functional description
of the <a href="0305.htm" target="UDOcon">Atari ST</a> BLiTTER. This document is not a data sheet for system
inte- gration, rather it is a user manual for system programming. For
more information, please refer to the texts listed at the end of this
document.
<br>
<br>
<br>
</div>
<div align=center><b>*** INTRODUCTION </b>
<br>
</div>
<div align=center>The <a href="0305.htm" target="UDOcon">Atari ST</a> Bit-Block Transfer Processor (BLiTTER) is a hardware
imple- mentation of the bit-block transfer (BitBlt) algorithm. BitBlt
can be simply described as a procedure that moves bit-aligned data
from a source location to a destination location through a given logic
operation. The BitBlt primitive can be used to perform such operations
as:
<br>
<br>o Area seed filling
<br>o Rotation by recursive subdivision
<br>o Slice and smear magnification
<br>o Brush line drawing using Bresenham DDA
<br>o Text transformations (eg. bold, italic, outline)
<br>o Text scrolling
<br>o Window updating
<br>o Pattern filling
<br>
<br>
</div>
<div align=center>And general memory-to-memory block copying [1].
<br>
<br>The heart of BitBlt was first formally defined by Newman and
Sproull in their description of the function RasterOp [2]. As defined,
RasterOp performed its block transfers on a bit-by-bit basis and was
limited to a small subset of possible source and destination Boolean
combinations. Enhancements to RasterOp such as processing bits in
parallel or intro- ducing a halftone pattern into the transfer were
literally left as exercises for the reader.
<br>
</div>
<div align=center>In an effort to improve the functionality and performance of the
original algorithm, the prescribed enhancements were incorporated into
the definition of RasterOp and implemented in hardware as the RasterOp
Chip [3]. However the RasterOp Chip lacked the two-dimensionality of
the original function and suffered from a performance bottleneck
caused by the loading and reloading of source, destination, and
halftone data (ie. it could not DMA).
<br>
</div>
<div align=center>While efforts were being made to improve the performance of
RasterOp, the formal definition of RasterOp was further refined and
became the basis of the BitBlt copyLoop primitive in the Smalltalk-80
graphics kernel [4]. Because of its comprehensive interface
definition, the BitBlt primitive was inefficient and required
special-case optimizations that violated its general-purpose nature.
Clearly a hardware solution was necessary to increase the performance
of the BitBlt copyLoop without sacrificing its functionality.
<br>
</div>
<div align=center>The <a href="0305.htm" target="UDOcon">Atari ST</a> BLiTTER is a hardware solution to the performance
problems of BitBlt. The BLiTTER is a DMA device that implements the
full BitBlt copyLoop definition with the addition of a few minor
extensions. Single word or multi-word increments and decrements are
provided for transfers to destinations in <a href="0305.htm" target="UDOcon">Atari ST</a> video display
memory. A center mask, which would otherwise be a constant all ones,
is also provided for an additional level of texture. The remainder of
this document is directly based on the original functional description
of the <a href="0305.htm" target="UDOcon">Atari ST</a> BLiTTER.
<br>
<br>
<br>
</div>
<div align=center><b> *** BIT-BLOCK TRANSFERS </b>
<br>
</div>
<div align=center>As previously stated, a bit-block transfer can be described as a
procedure that moves bit-aligned data from a source location to a
destination location through a given logic operation. There are
sixteen logic combination rules associated with the merging of source
and destination data. Note that this set contains all possible
combinations between source and destination. The following table
contains the valid BitBlt combination rules:
<br>
<br>
</div>
<pre>
          LOGIC OPERATIONS

                     _______________________________________
                    |    |                                  |
          MSB LSB   | OP | COMBINATION RULE                 |
                    |    |                                  |
          0 0 0 0   | 0  | all zeros                        |
          0 0 0 1   | 1  | source AND destination           |
          0 0 1 0   | 2  | source AND NOT destination       |
          0 0 1 1   | 3  | source                           |
          0 1 0 0   | 4  | NOT source AND destination       |
          0 1 0 1   | 5  | destination                      |
          0 1 1 0   | 6  | source XOR destination           |
          0 1 1 1   | 7  | source OR destination            |
          1 0 0 0   | 8  | NOT source AND NOT destination   |
          1 0 0 1   | 9  | NOT source XOR destination       |
          1 0 1 0   | A  | NOT destination                  |
          1 0 1 1   | B  | source OR NOT destination        |
          1 1 0 0   | C  | NOT source                       |
          1 1 0 1   | D  | NOT source OR destination        |
          1 1 1 0   | E  | NOT source OR NOT destination    |
          1 1 1 1   | F  | all ones                         |
                    |____|__________________________________|

</pre>
<div align=center>
<br>
</div>
<div align=center>Adjustments to block extents and several other transfer parameters
are determined prior to the invocation of the actual block transfer.
These adjustments and parameters include clipping, skew, end masks,
and overlap.
<br>
</div>
<div align=center>Clipping. The source and destination block extents are adjusted to
conform with a specified clipping rectangle. Since both source and
destination blocks are of equal dimension, the destination block
extent is clipped to the extent of the source block (or vice versa).
Note that the block transfer need not be performed if the resultant
extent is zero.
<br>
</div>
<div align=center>Skew. The source-to-destination horizontal bit skew is calculated.
<br>
</div>
<div align=center>End Masks. The left and right partial word masks are determined.
The masks are merged if the destination is one word in width.
<br>
</div>
<div align=center>Overlap. The block locations are checked for possible overlap in
order to avoid the destruction of source data before it is
transferred.
<br>
</div>
<div align=center>In non-overlapping transfers the source block scanning direction
is inconsequential and can by default be from upper left to lower
right. In overlapping transfers the source scanning direction is also
from upper left to lower right if the source-to-destination transfer
direction is up and/or to the left (ie. source address is greater than
or equal to destination address). However, if the overlapping
source-to-destination transfer direction is down and/or to the right
(ie. source address is less than destination address), then the source
data is scanned from lower right to upper left.
<br>
</div>
<div align=center>After the transfer parameters are determined the bit-block
transfer operation can be invoked, transferring source to destination
through the logic operation (HALFTONE and HOP will be described in the
next section):
<br>
<br>
<br>
</div>
<div align=center><b> *** BIT-BLOCK TRANSFER </b>
<br>
<br>
</div>
<pre>
                _________  _____________           ________________
               |         ||             |         |                |
               |  SOURCE ||  SOURCE     |         |  DESTINATION   |
               |_________||_____________|         |________________|
                    |________________|&lt;&lt; SKEW |                  |
                                  |                              |
           ______________      ___|____       ________________   |
          |              |    |        |     |                |  |
          |   HALFTONE   |----|  HOP   |-----|    LOGIC OP    |--|
          |______________|    |________|     |________________|  |
                                                       |         |
                                                   ____|____     |
                                                  |         |    |
                                                  | ENDMASK |____|
                                                  |_________|
                                                       |
                                              _________|_________
                                             |                   |
                                             |  NEW DESTINATION  |
                                             |___________________|

</pre>
<div align=center>
<br>
<br>
</div>
<div align=center><b> *** FUNCTIONAL DESCRIPTION </b>
<br>
</div>
<div align=center>Please refer to the bit-block transfer diagram in the previous
section. To understand how the components of a block transfer work,
let's look at the simplest possible transfer. Take the case where we
wish to fill a block of memory with either all zeros or all ones (OP =
0 or OP = F). In this case only the LOGIC OP block, which generates
the ones or zeros, and the ENDMASK block are in the data path. If the
end mask contains all ones, the BLiTTER will simply write one word
after the other to the dest- ination address without ever reading the
destination.
<br>
</div>
<div align=center>As the writes take place the destination address will be adjusted
according to the values in the DESTINATION X INCREMENT, DESTINATION Y
INCREMENT, X COUNT, and Y COUNT registers. These registers define the
size and shape of the block to be transferred. The X and Y COUNT
registers define the size of the block. The X COUNT register specifies
the number of word-size writes required to update one line of the
destination. The Y COUNT register specifies the number of these lines
in the block. The DESTINATION X INCREMENT register is a signed (2's
complement) 16-bit quantity which is added to the destination address
to calculate the address of the next destination word of the line. On
the last write of the line the DESTINATION Y INCREMENT is added to
calculate the address of the first word of the next line.
<br>
</div>
<div align=center>The end mask determines which bits of the destination word will be
up- dated. Bits of the destination which correspond to ones in the end
mask will be updated. Bits of the destination which correspond to
zeros in the end mask will remain unchanged. Note that if any bits of
the destination are to be left unchanged, a read-modify-write is
required. In order to improve performance a read will only be
performed if it is required. There are three ENDMASK registers
numbered 1 through 3. ENDMASK 1 is used only for the first write of
the line. ENDMASK 3 is used only for the last write of the line.
ENDMASK 2 is used for all other writes.
<br>
</div>
<div align=center>Now let's consider a more complicated case, suppose we want to XOR
a destination block with a 16 x 16 halftone pattern. First we load the
HALFTONE RAM with the halftone pattern. Select halftone only using the
HOP register and select source XOR destination using the OP register.
The LINE NUMBER register is used to specify which of the 16 words of
HALFTONE RAM is used for the current line. This register will be
incremented or decremented at the end of each line according to the
sign of the DES- TINATION Y INCREMENT register. Set the DESTINATION X
and Y INCREMENT and X and Y COUNT registers to the appropriate values
and start the transfer. This same procedure can be followed to do the
combination using any logic operation by simply changing the value in
the OP register. Similarly the combination can be performed using a
source block instead of the HALFTONE RAM or using the logical AND of a
source block and the HALFTONE RAM by changing the value of the HOP
register. A source block is the same size as the destination block but
may have different increments and address defined by the SOURCE X and
Y INCREMENT and SOURCE ADDRESS registers.
<br>
</div>
<div align=center>Finally, let's look at the case when the source and destination
blocks are not bit-aligned. In this case we may need to read the first
two source words into the 32-bit source buffer and use the 16 bits
that line up with the appropriate bits of the destination, as
specified by the SKEW reg- ister. When the next source word is read,
the lower 16 bits of the source buffer is transferred to the upper 16
bits and the lower is replaced by the new data. This process is
reversed when the source is being read from the right to the left
(SOURCE X INCREMENT negative). Since there are cases when it may be
necessary for an extra source read to be performed at the beginning of
each line to &quot;prime&quot; the source buffer and cases when it may
not be necessary due to the choice of end mask, a bit has been
provided which forces the extra read. The FXSR (aka. pre-fetch) bit in
the SKEW register indicates, when set, that an extra source read
should be performed at the beginning of each line to &quot;prime&quot;
the source buffer. Similarly the NFSR (aka post-flush) bit, when set,
will prevent the last source read of the line. This read may not be
necessary with certain combinations of end masks and skews. If the
read is suppressed, the lower to upper half buffer transfer still
occurs. Also in this case, a read- modify-write cycle is performed on
the destination for the last write of each line regardless of the
value of the corresponding ENDMASK register.
<br>
<br>
<br>
</div>
<div align=center><b> *** PROGRAMMING MODEL </b>
<br>
</div>
<div align=center>The BLiTTER contains a set of registers that specify bit-block
addresses, bit-block alignments, logic and halftone operations, and
bus accesses. The register set-up time remains practically constant
and is large relative to small block transfers, whereas large
bit-blocks are dominated by the execution time of the transfer itself.
<br>
</div>
<div align=center>
<br>
<br>
</div>
<div align=center><b>*** REGISTER MAP </b>
<br>
</div>
<div align=center>The following is a map of the BLiTTER programmable registers (note
that all unused bits read back as zeros):
<br>
<br>
</div>
<pre>

          FF 8A00   |oooooooo||oooooooo|     HALFTONE RAM
          FF 8A02   |oooooooo||oooooooo|
          FF 8A04   |oooooooo||oooooooo|
                    :        ::        :
          FF 8A1E   |oooooooo||oooooooo|
          FF 8A20   |oooooooo||ooooooo-|     SOURCE X INCREMENT
          FF 8A22   |oooooooo||ooooooo-|     SOURCE Y INCREMENT
          FF 8A24   |--------||oooooooo|     SOURCE ADDRESS
          FF 8A26   |oooooooo||ooooooo-|
          FF 8A28   |oooooooo||oooooooo|     ENDMASK 1
          FF 8A2A   |oooooooo||oooooooo|     ENDMASK 2
          FF 8A2C   |oooooooo||oooooooo|     ENDMASK 3
          FF 8A2E   |oooooooo||ooooooo-|     DESTINATION X INCREMENT
          FF 8A30   |oooooooo||ooooooo-|     DESTINATION Y INCREMENT
          FF 8A32   |--------||oooooooo|     DESTINATION ADDRESS
          FF 8A34   |oooooooo||ooooooo-|
          FF 8A36   |oooooooo||oooooooo|     X COUNT
          FF 8A38   |oooooooo||oooooooo|     Y COUNT

          FF 8A3A   |------oo|               HOP
          FF 8A3B   |----oooo|               OP

          FF 8A3C   |ooo-oooo|
                    ||| |__|_____________ LINE NUMBER
                    |||__________________ SMUDGE
                     ||__________________ HOG
                     |___________________ BUSY

          FF 8A3D   |oo--oooo|
                    ||  |__|_____________ SKEW
                    ||___________________ NFSR
                     |____________________ FXSR

</pre>
<div align=center>
<br>
</div>
<div align=center><b>*** BIT-BLOCK ADDRESSES </b>
<br>
</div>
<div align=center>This subsection describes registers that specify bit-block
origins, address increments, and extents.
<br>
<br>
</div>
<div align=center><b> SOURCE ADDRESS </b>
<br>
</div>
<div align=center>This 23-bit register contains the current address of the source
field (only word addresses may be specified). It may be accessed using
either word or longword instructions. The value read back is always
the address of the next word to be used in a source operation. It will
be updated by the amounts specified in the SOURCE X INCREMENT and the
SOURCE Y INCREMENT registers as the transfer progresses.
<br>
<br>
</div>
<div align=center><b> SOURCE X INCREMENT </b>
<br>
</div>
<div align=center>This is a signed 15-bit register, the least significant bit is
ignored, specifying the offset in bytes to the address of the next
source word in the current line. This value will be sign-extended and
added to the SOURCE ADDRESS register at the end of a source word
fetch, whenever the X COUNT register does not contain a value of one.
If the X COUNT register is loaded with a value of one this register is
not used. Byte instructions can not be used to read or write this
register.
<br>
<br>
</div>
<div align=center><b> SOURCE Y INCREMENT </b>
<br>
</div>
<div align=center>This is a signed 15-bit register, the least significant bit is
ignored, specifying the offset in bytes to the address of the first
source word in the next line. This value will be sign-extended and
added to the SOURCE ADDRESS register at the end of the last source
word fetch of each line (when the X COUNT register contains a value of
one). If the X COUNT register is loaded with a value of one this
register is used exclusively. Byte instructions can not be used to
read or write this register.
<br>
<br>
</div>
<div align=center><b> DESTINATION ADDRESS </b>
<br>
</div>
<div align=center>This 23-bit register contains the current address of the
destination field (only word addresses may be specified). It may be
accessed using either word or long-word instructions. The value read
back is always the address of the next word to be modified in the
destination field. It will be updated by the amounts specified in the
DESTINATION X INCREMENT and the DESTINATION Y INCREMENT registers as
the transfer progresses.
<br>
</div>
<div align=center>
<br>
</div>
<div align=center><b> DESTINATION X INCREMENT </b>
<br>
</div>
<div align=center>This is a signed 15-bit register, the least significant bit is
ignored, specifying the offset in bytes to the address of the next
destination word in the current line. This value will be sign-extended
and added to the DESTINATION ADDRESS register at the end of a
destination word write, whenever the X COUNT register does not contain
a value of one. If the X COUNT register is loaded with a value of one
this register is not used. Byte instructions can not be used to read
or write this register.
<br>
<br>
</div>
<div align=center><b> DESTINATION Y INCREMENT </b>
</div>
<div align=center>This is a signed 15-bit register, the least significant bit is
ignored, specifying the offset in bytes to the address of the first
destination word in the next line. This value will be sign-extended
and added to the DESTINATION ADDRESS register at the end of the last
destination word write of each line (when the X COUNT register
contains a value of one). If the X COUNT register is loaded with a
value of one this register is used exclusively. Byte instructions
cannot be used on this register.
<br>
<br>
</div>
<div align=center><b> X COUNT </b>
<br>
</div>
<div align=center>This 16-bit register specifies the number of words contained in
one destination line. The minimum number is one and the maximum is
65536 designated by zero. Byte instructions can not be used to read or
write this register. Reading this register returns the number of
destination words yet to be written in the current line, NOT
necessarily the value initially written to the register. Each time a
destination word is written the value will be decremented until it
reaches zero, at which time it will be returned to its initial value.
<br>
<br>
</div>
<div align=center><b> Y COUNT </b>
</div>
<div align=center>This 16-bit register specifies the number of lines in the
destination field. The minimum number is one and the maximum is 65536
designated by zero. Byte instructions can not be used to read or write
this register. Reading this register returns the number of destination
lines yet to be written, NOT necessarily the value initially written
to the register. Each time a destination line is completed the value
will be decremented until it reaches zero, at which time the tranfer
is complete.
<br>
<br>
<br>
</div>
<div align=center><b> *** BIT-BLOCK ALIGNMENTS </b>
<br>
</div>
<div align=center>This subsection describes registers that specify bit-block end
masks, source-to-destination skew, and source data fetching.
<br>
</div>
<div align=center>ENDMASK 1, 2, 3
<br>
</div>
<div align=center>These 16-bit registers are used to mask destination writes. Bits
of the destination word which correspond to ones in the current
ENDMASK register will be modified. Bits of the destination word which
correspond to zeros in the current ENDMASK register will remain
unchanged. The current ENDMASK register is determined by position in
the line. ENDMASK 1 is used only for the first write of a line.
ENDMASK 3 is used only for the last write of a line. ENDMASK 2 is used
in all other cases. In the case of a one word line ENDMASK 1 is used.
Byte instructions can not be used to read or write these registers.
<br>
<br>
</div>
<div align=center><b> SKEW </b>
<br>
</div>
<div align=center>The least significant four bits of the byte-wide register at FF
8A3D specify the source skew. This is the amount the data in the
source data latch is shifted right before being combined with the
halftone mask and destination data.
<br>
<br>
</div>
<div align=center><b> FXSR </b>
<br>
</div>
<div align=center>FXSR stands for Force eXtra Source Read. When this bit is set one
extra source read is performed at the start of each line to initialize
the remainder portion source data latch.
<br>
<br><b> NFSR </b>
<br>
</div>
<div align=center>NFSR stands for No Final Source Read. When this bit is set the
last source read of each line is not performed. Note that use of this
and/or the FXSR bit the requires an adjustment to the SOURCE Y
INCREMENT and SOURCE ADDRESS registers.
<br>
<br>
<br>
</div>
<div align=center><b> *** LOGIC OPERATIONS </b>
<br>
</div>
<div align=center>This subsection describes registers that specify the logic
combinations of source and destination bit-block data.
<br>
</div>
<div align=center>The least significant four bits of the byte-wide register at FF
8A3B specify the source/destination combination rule according to the
following table:
<br>
<br>
</div>
<pre>
           _______________________________________
          |    |                                  |
          | OP | COMBINATION RULE                 |
          |    |                                  |
          | 0  | all zeros                        |
          | 1  | source AND destination           |
          | 2  | source AND NOT destination       |
          | 3  | source                           |
          | 4  | NOT source AND destination       |
          | 5  | destination                      |
          | 6  | source XOR destination           |
          | 7  | source OR destination            |
          | 8  | NOT source AND NOT destination   |
          | 9  | NOT source XOR destination       |
          | A  | NOT destination                  |
          | B  | source OR NOT destination        |
          | C  | NOT source                       |
          | D  | NOT source OR destination        |
          | E  | NOT source OR NOT destination    |
          | F  | all ones                         |
          |____|__________________________________|

</pre>
<div align=center>
<br>
<br>
</div>
<div align=center><b> *** HALFTONE OPERATIONS </b>
<br>
</div>
<div align=center>This subsection describes registers that specify the halftone
pattern memory, halftone word index, and combinations of source and
halftone data.
<br>
<br>
</div>
<div align=center><b> HALFTONE RAM </b>
<br>
</div>
<div align=center>This RAM holds a 16x16 halftone pattern mask. Each word is valid
for one line of the destination field and is repeated every 16 lines.
The current word is pointed to by the value in the LINE NUMBER
register. These registers may be read, but can not be accessed using
byte-wide instructions.
<br>
<br>
</div>
<div align=center><b> LINE NUMBER </b>
<br>
</div>
<div align=center>The least significant four bits of the byte-wide register at FF
8A3C specify the current halftone mask. The current value times two
plus FF 8A00 gives the address of the current halftone mask. This
value is incremented or decremented at the end of each line and will
wrap through zero. The sign of the DESTINATION Y INCREMENT determines
if the line number is incremented or decremented (increment if
positive, decrement if negative).
<br>
<br>
</div>
<div align=center><b> SMUDGE </b>
<br>
</div>
<div align=center>The SMUDGE bit, when set, causes the least significant four bits
of the skewed source data to be used as the address of the current
halftone pattern. Note that the halftone operation is still valid when
SMUDGE is set.
<br>
<br>
</div>
<div align=center><b> HALFTONE OPERATIONS </b>
<br>
</div>
<div align=center>The least significant two bits of the byte-wide register at FF
8A3A specify the source/halftone combination rule according to the
following table:
<br>
<br>
</div>
<pre>
           _____________________________
          |    |                        |
          | HOP| COMBINATION RULE       |
          |    |                        |
          | 0  | all ones               |
          | 1  | halftone               |
          | 2  | source                 |
          | 3  | source AND halftone    |
          |____|________________________|

</pre>
<div align=center>
<br>
</div>
<div align=center><b> *** BUS ACCESSES </b>
<br>
</div>
<div align=center>This subsection describes registers that specify bus access
control and BLiTTER start/status.
<br>
<br>
</div>
<div align=center><b> HOG </b>
<br>
</div>
<div align=center>The HOG bit, when cleared, causes the processor and the blitter to
share the bus equally. In this mode each will get 64 bus cycles while
the other is halted. When set, the bit will cause the processor to be
halted until the transfer is complete. In either case the BLiTTER will
yield to other DMA devices. Bus arbitration may allow the processor to
execute one or more instructions even in hog mode. Therefore, don't
assume that the instruction following the one which sets the BUSY bit
will be executed only after the transfer is complete. The BUSY bit may
be polled to achieve this kind of synchronization.
<br>
<br>
</div>
<div align=center><b> BUSY </b>
<br>
</div>
<div align=center>The BUSY bit is set after all the other registers have been
initialized to begin the transfer operation. It will remain set until
the transfer is complete. The interrupt line is a duplicate of this
bit. See the Programming Example for more details on how to use the
BUSY bit.
<br>
</div>
<div align=center>
<br>
<br>
</div>
<div align=center><b> Appendix A - Programming Example </b>
<br>
</div>
<div align=center>In order to maintain software compatibility with new or upgraded
Atari STs equipped with the BLiTTER, software developers need only
follow guidelines set forth by the VDI and &quot;LINE A&quot;
documents. Revised TOS ROMs will work in concert with the BLiTTER,
enhancing the performance of many VDI and &quot;LINE A&quot;
operations. This occurs in a manner transparent to an executing
program. Thus no special actions need be taken to utilize the
performance advantages of the BLiTTER.
<br>
</div>
<div align=center>As a rule of thumb, never make a VDI or &quot;LINE A&quot; call
from within an interrupt context since unpredictable and potentially
catastrophic results will occur should one BLiTTER operation interrupt
another BLiTTER operation.
<br>
</div>
<div align=center>The following program has not been optimized and is presented here
for exemplary purposes only.
<br>
<br>
</div>
<pre>
     * (c) 1987 Atari Corporation
     *    All Rights Reserved.

     * BLiTTER BASE ADDRESS

          BLiTTER   equ  $FF8A00

     * BLiTTER REGISTER OFFSETS

     Halftone  equ  0
     Src_Xinc  equ  32
     Src_Yinc  equ  34
     Src_Addr  equ  36
     Endmask1  equ  40
     Endmask2  equ  42
     Endmask3  equ  44
     Dst_Xinc  equ  46
     Dst_Yinc  equ  48
     Dst_Addr  equ  50
     X_Count   equ  54
     Y_Count   equ  56
     HOP       equ  58
     OP        equ  59
     Line_Num  equ  60
     Skew      equ  61

     * BLiTTER REGISTER FLAGS

     fHOP_Source    equ  1
     fHOP_Halftone  equ  0

     fSkewFXSR      equ  7
     fSkewNFSR      equ  6

     fLineBusy      equ  7
     fLineHog       equ  6
     fLineSmudge    equ  5

     * BLiTTER REGISTER MASKS

     mHOP_Source    equ  $02
     mHOP_Halftone  equ  $01

     mSkewFXSR      equ  $80
     mSkewNFSR      equ  $40

     mLineBusy      equ  $80
     mLineHog       equ  $40
     mLineSmudge    equ  $20

     *         E n D m A s K   d A t A
     *
     * These tables are referenced by PC relative instructions.  Thus,
     * the labels on these tables must remain within 128 bytes of the
     * referencing instructions forever.  Amen.
     *
     * 0: Destination  1: Source   &lt;&lt;&lt; Invert right end mask data &gt;&gt;&gt;

     lf_endmask:
          dc.w $FFFF

     rt_endmask:
          dc.w $7FFF
          dc.w $3FFF
          dc.w $1FFF
          dc.w $0FFF
          dc.w $07FF
          dc.w $03FF
          dc.w $01FF
          dc.w $00FF
          dc.w $007F
          dc.w $003F
          dc.w $001F
          dc.w $000F
          dc.w $0007
          dc.w $0003
          dc.w $0001
          dc.w $0000

     * TiTLE:  BLiT_iT
     *
     * PuRPoSE:
     *    Transfer a rectangular block of pixels located at an
     *    arbitrary X,Y position in the source memory form to
     *    another arbitrary X,Y position in the destination memory
     *    form using replace mode (boolean operator 3).
     *    The source and destination rectangles should not overlap.
     *
     * iN:
     *    a4   pointer to 34 byte input parameter block
     *
     * Note: This routine must be executed in supervisor mode as
     *    access is made to hardware registers in the protected region
     *    of the memory map.
     *
     *
     *    I n p u t   p a r a m e t e r   b l o c k   o f f s e t s

     SRC_FORM  equ  0    ; Base address of source memory form .l
     SRC_NXWD  equ  4    ; Offset between words in source plane .w
     SRC_NXLN  equ  6    ; Source form width .w
     SRC_NXPL  equ  8    ; Offset between source planes .w
     SRC_XMIN  equ  10   ; Source blt rectangle minimum X .w
     SRC_YMIN  equ  12   ; Source blt rectangle minimum Y .w

     DST_FORM  equ  14   ; Base address of destination memory form .l
     DST_NXWD  equ  18   ; Offset between words in destination plane.w
     DST_NXLN  equ  20   ; Destination form width .w
     DST_NXPL  equ  22   ; Offset between destination planes .w
     DST_XMIN  equ  24   ; Destination blt rectangle minimum X .w
     DST_YMIN  equ  26   ; Destination blt rectangle minimum Y .w

     WIDTH     equ  28   ; Width of blt rectangle .w
     HEIGHT    equ  30   ; Height of blt rectangle .w
     PLANES    equ  32   ; Number of planes to blt .w

     BLiT_iT:

          lea  BLiTTER,a5          ; a5-&gt; BLiTTER register block

     *
     * Calculate Xmax coordinates from Xmin coordinates and width
     *
          move.w    WIDTH(a4),d6
          subq.w    #1,d6               ; d6&lt;- width-1

          move.w    SRC_XMIN(a4),d0     ; d0&lt;- src Xmin
          move.w    d0,d1
          add.w     d6,d1               ; d1&lt;- src Xmax=src Xmin+width-1

          move.w    DST_XMIN(a4),d2     ; d2&lt;- dst Xmin
          move.w    d2,d3
          add.w     d6,d3               ; d3&lt;- dst Xmax=dstXmin+width-1

     *
     * Endmasks are derived from source Xmin mod 16 and source Xmax
     *    mod 16
     *
          moveq.l   #$0F,d6   ; d6&lt;- mod 16 mask

          move.w    d2,d4          ; d4&lt;- DST_XMIN
          and.w     d6,d4          ; d4&lt;- DST_XMIN mod 16
          add.w     d4,d4          ; d4&lt;- offset into left end mask tbl

          move.w    lf_endmask(pc,d4.w),d4        ; d4&lt;- left endmask

          move.w    d3,d5          ; d5&lt;- DST_XMAX
          and.w     d6,d5          ; d5&lt;- DST_XMAX mod 16
          add.w     d5,d5          ; d5&lt;- offset into right end mask tbl

          move.w    rt_endmask(pc,d5.w),d5   ; d5&lt;-inverted right end mask
          not.w     d5                       ; d5&lt;- right end mask

     *
     * Skew value is (destination Xmin mod 16 - source Xmin mod 16)
     * &amp;&amp; 0x000F.  Three discriminators are used to determine the
     * states of FXSR and NFSR flags:
     *
     *    bit 0     0: Source Xmin mod 16 =&lt; Destination Xmin mod 16
     *              1: Source Xmin mod 16 &gt;  Destination Xmin mod 16
     *
     *    bit 1     0: SrcXmax/16-SrcXmin/16 &lt;&gt; DstXmax/16-DstXmin/16
     *                   Source span              Destination span
     *              1: SrcXmax/16-SrcXmin/16 == DstXmax/16-DstXmin/16
     *
     *    bit 2     0: multiple word Destination span
     *              1: single word Destination span
     *
     *    These flags form an offset into a skew flag table yielding
     *    correct FXSR and NFSR flag states for the given source and
     *    destination alignments
     *

          move.w    d2,d7     ; d7&lt;- Dst Xmin
          and.w     d6,d7     ; d7&lt;- Dst Xmin mod16
          and.w     d0,d6     ; d6&lt;- Src Xmin mod16
          sub.w     d6,d7     ; d7&lt;- Dst Xmin mod16-Src Xmin mod16
     *                        ; if Sx&amp;F &gt; Dx&amp;F then cy:1 else cy:0
          clr.w     d6        ; d6&lt;- initial skew flag table index
          addx.w    d6,d6     ; d6[bit0]&lt;- intraword alignment flag

          lsr.w     #4,d0     ; d0&lt;- word offset to src Xmin
          lsr.w     #4,d1     ; d1&lt;- word offset to src Xmax
          sub.w     d0,d1     ; d1&lt;- Src span - 1

          lsr.w     #4,d2     ; d2&lt;- word offset to dst Xmin
          lsr.w     #4,d3     ; d3&lt;- word offset to dst Xmax
          sub.w     d2,d3     ; d3&lt;- Dst span - 1
          bne       set_endmasks   ; 2nd discriminator is one word dst

     * When destination spans a single word, both end masks are merged
     * into Endmask1.  The other end masks will be ignored by the BLiTTER

          and.w     d5,d4          ; d4&lt;- single word end mask
          addq.w    #4,d6          ; d6[bit2]:1 =&gt; single word dst

     set_endmasks:

          move.w    d4,Endmask1(a5)     ; left end mask
          move.w    #$FFFF,Endmask2(a5) ; center end mask
          move.w    d5,Endmask3(a5)     ; right end mask

          cmp.w     d1,d3          ; the last discriminator is the
          bne       set_count      ; equality of src and dst spans

          addq.w    #2,d6          ; d6[bit1]:1 =&gt; equal spans

     set_count:
          move.w    d3,d4
          addq.w    #1,d4          ; d4&lt;- number of words in dst line
          move.w    d4,X_Count(a5) ; set value in BLiTTER

     * Calculate Source starting address:
     *
     *   Source Form address              +
     *  (Source Ymin * Source Form Width) +
     * ((Source Xmin/16) * Source Xinc)

          move.l    SRC_FORM(a4),a0     ; a0-&gt; start of Src form
          move.w    SRC_YMIN(a4),d4     ; d4&lt;- offset in lines to Src Ymin
          move.w    SRC_NXLN(a4),d5     ; d5&lt;- length of Src form line
          mulu      d5,d4               ; d4&lt;- byte offset to (0, Ymin)
          add.l     d4,a0               ; a0-&gt; (0, Ymin)

          move.w    SRC_NXWD(a4),d4;    d4&lt;- offset between consecutive
          move.w    d4,Src_Xinc(a5)     ;      words in Src plane

          mulu      d4,d0          ; d0&lt;- offset to word containing Xmin
          add.l     d0,a0          ; a0-&gt; 1st src word (Xmin, Ymin)

     * Src_Yinc is the offset in bytes from the last word of one Source
     * line to the first word of the next Source line

          mulu      d4,d1               ; d1&lt;- width of src line in bytes
          sub.w     d1,d5               ; d5&lt;- value added to ptr at end
          move.w    d5,Src_Yinc(a5)     ; of line to reach start of next

     * Calculate Destination starting address

          move.l    DST_FORM(a4),a1     ; a1-&gt; start of dst form
          move.w    DST_YMIN(a4),d4     ; d4&lt;- offset in lines to dst Ymin
          move.w    DST_NXLN(a4),d5     ; d5&lt;- width of dst form

          mulu      d5,d4     ; d4&lt;- byte offset to (0, Ymin)
          add.l     d4,a1     ; a1-&gt; dst (0, Ymin)

          move.w    DST_NXWD(a4),d4     ; d4&lt;- offset between consecutive
          move.w    d4,Dst_Xinc(a5)     ;  words in dst plane

          mulu      d4,d2               ; d2&lt;- DST_NXWD * (DST_XMIN/16)
          add.l     d2,a1               ; a1-&gt; 1st dst word (Xmin, Ymin)

     * Calculate Destination Yinc

          mulu      d4,d3               ; d3&lt;- width of dst line - DST_NXWD
          sub.w     d3,d5               ; d5&lt;- value added to dst ptr at
          move.w    d5,Dst_Yinc(a5)     ;  end of line to reach next line

     * The low nibble of the difference in Source and Destination alignment
     * is the skew value.  Use the skew flag index to reference FXSR and
     * NFSR states in skew flag table.

          and.b     #$0F,d7                  ; d7&lt;- isolated skew count
          or.b      skew_flags(pc,d6.w),d7 ; d7&lt;- necessary flags and skew
          move.b    d7,Skew(a5)              ; load Skew register

          move.b    #mHOP_Source,HOP(a5)     ; set HOP to source only
          move.b    #3,OP(a5)           ; set OP to &quot;replace&quot; mode

          lea       Line_Num(a5),a2     ; fast refer to Line_Num register
          move.b    #fLineBusy,d2       ; fast refer to LineBusy flag
          move.w    PLANES(a4),d7       ; d7 &lt;- plane counter
          bra       begin

     *    T h e   s e t t i n g   o f   s k e w   f l a g s
     *
     *
     * QUALIFIERS   ACTIONS           BITBLT DIRECTION: LEFT -&gt; RIGHT
     *
     * equal Sx&amp;F&gt;
     * spans Dx&amp;F FXSR NFSR
     *
     * 0     0     0    1 |..ssssssssssssss|ssssssssssssss..|
     *   |......dddddddddd|dddddddddddddddd|dd..............|
     *
     * 0     1     1    0 |..dddddddddddddd|dddddddddddddd..|
     *   |......ssssssssss|ssssssssssssssss|ss..............|
     *
     * 1     0     0    0 |..ssssssssssssss|ssssssssssssss..|
     *                    |...ddddddddddddd|ddddddddddddddd.|
     *
     * 1     1     1    1 |...sssssssssssss|sssssssssssssss.|
     *                    |..dddddddddddddd|dddddddddddddd..|


     skew_flags:

          dc.b mSkewNFSR           ; Source span &lt; Destination span
          dc.b mSkewFXSR           ; Source span &gt; Destination span
          dc.b 0                   ; Spans equal Shift Source right
          dc.b mSkewNFSR+mSkewFXSR ; Spans equal Shift Source left

     * When Destination span is but a single word ...

          dc.b 0         ; Implies a Source span of no words
          dc.b mSkewFXSR ; Source span of two words
          dc.b 0         ; Skew flags aren't set if Source and
          dc.b 0         ; Destination spans are both one word

     next_plane:
          move.l    a0,Src_Addr(a5)     ; load Source pointer to this plane

          move.l    a1,Dst_Addr(a5)     ; load Dest ptr to this plane
          move.w    HEIGHT(a4),Y_Count(a5)   ; load the line count

          move.b    #mLineBusy,(a2)     ; &lt;&lt;&lt; start the BLiTTER &gt;&gt;&gt;

          add.w     SRC_NXPL(a4),a0     ; a0-&gt; start of next src plane
          add.w     DST_NXPL(a4),a1     ; a1-&gt; start of next dst plane


     * The BLiTTER is usually operated with the HOG flag cleared.
     * In this mode the BLiTTER and the ST's cpu share the bus equally,
     * each taking 64 bus cycles while the other is halted.  This mode
     * allows interrupts to be fielded by the cpu while an extensive
     * BitBlt is being processed by the BLiTTER.  There is a drawback in
     * that BitBlts in this shared mode may take twice as long as BitBlts
     * executed in hog mode.  Ninety percent of hog mode performance is
     * achieved while retaining robust interrupt handling via a method
     * of prematurely restarting the BLiTTER.  When control is returned
     * to the cpu by the BLiTTER, the cpu immediately resets the BUSY
     * flag, restarting the BLiTTER after just 7 bus cycles rather than
     * after the usual 64 cycles.  Interrupts pending will be serviced
     * before the restart code regains control.  If the BUSY flag is
     * reset when the Y_Count is zero, the flag will remain clear
     * indicating BLiTTER completion and the BLiTTER won't be restarted.
     *
     * (Interrupt service routines may explicitly halt the BLiTTER
     * during execution time critical sections by clearing the BUSY flag.
     * The original BUSY flag state must be restored however, before
     * termination of the interrupt service routine.)

     restart:
          bset.b    d2,(a2)        ; Restart BLiTTER and test the BUSY
          nop                      ; flag state.  The &quot;nop&quot; is executed
          bne  restart             ; prior to the BLiTTER restarting.
     *                             ; Quit if the BUSY flag was clear.

     begin:
          dbra d7,next_plane
          rts

</pre>
<div align=center>
<br>
<br>
</div>
<div align=center><b> Appendix B - References </b>
<br>
</div>
<div align=center>[1] Rob Pike, Leo Guibas, and Dan Ingalls, 'SIGGRAPH'84 Course
Notes: Bitmap Graphics', AT&amp;T Bell Laboratories 1984.
<br>
<br>
</div>
<div align=center>[2] William Newman and Robert Sproull, 'Principles of Interactive
Computer Graphics', McGraw-Hill 1979, Chapter 18.
<br>
<br>
</div>
<div align=center>[3] John Atwood, '16160 RasterOp Chip Data Sheet', Silicon
Compilers 1984. See also 'VL16160 RasterOp Graphics/Boolean Operation
ALU', VLSI Technology 1986.
<br>
<br>
</div>
<div align=center>[4] Adele Goldberg and David Robson, 'Smalltalk-80: The Language
and its Implementation', Addison-Wesley 1983, Chapter 18.
<br>
</div>
<div align=center>
<br>
<br>
</div>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img.gif" border=0 width="50" height="40"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de/">Robert Schaffner</a> (<a href="mailto:doit@doitarchive.de">doit@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Mai 2004</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080103.htm" target="UDOcon"><img src="udo_lf.gif" alt="WD1772 FDC" border=0 width="24" height="24"></a>
<a href="080105.htm" target="UDOcon"><img src="udo_rg.gif" alt="MMU" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>

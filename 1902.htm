<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.05.2004 -->
<html>
<head>
<title>
DOIT_ST - Tips u. Tricks zur Atari Serie: Bildformate
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="doit@doitarchive.de">
<link rev=made href="mailto:doit@doitarchive.de" title="E-Mail">
<link rel=home href="doitst1h.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="19.htm" target="UDOcon"><img src="udo_up.gif" alt="Anhang" border=0 width="24" height="24"></a>
<a href="1901.htm" target="UDOcon"><img src="udo_lf.gif" alt="Der Anfang.." border=0 width="24" height="24"></a>
<a href="1903.htm" target="UDOcon"><img src="udo_rg.gif" alt="BEST-Electronics" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="Bildformate">25.2 Bildformate</a></h1>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p><tt> Bildformate an Atari Computern </tt>
<br>
<br>
</p>
<p><img src="image/english.gif" border=0 width="35" height="22"></p><br>
<div align=center>
<br>
<br><b> ST Picture Formats </b>
<br>
<br>Compiled by:
<br>Dave Baggett
<br>(arpanet: dmb@TIS.COM)
<br>
<br>(Please report errors or additions)
<br>
<br>CONTRIBUTORS
</div>
<div align=center>Phil Blanchfield Jason Blochowiak David Brooks Neil Forsyth
<br>Stefan Hoehn Ken MacLeod Jim McCabe Darek Mihocka David Mumper
<br>George Seto Joe Smith Greg Wageman Roland Waldi* Gerry Wheeler
<br>
</div>
<div align=center>
<br>
</div>
<p>
<br>
<br>
</p>
<dl>
<dt><b>Contents</b></dt><dd>
<br>&nbsp;
<br>NEOchrome *.NEO
<br>NEOchrome Animation *.ANI
<br>DEGAS *.PI? ? = 1, 2, 3
<br>DEGAS Elite *.PI? ? = 1, 2, 3
<br>DEGAS Elite (Compressed) *.PC? ? = 1, 2, 3
<br>Tiny *.TN? ? = 1, 2, 3, Y
<br>Spectrum 512 *.SPU
<br>Spectrum 512 (Compressed) *.SPC
<br>Art Director *.ART
<br>C.O.L.R. Object Editor Mural *.MUR
<br>Doodle *.DOO
<br>Animatic Film *.FLM
<br>GEM Bit Image *.IMG
<br>Image *.IMG
<br>STAD *.PAC
<br>Imagic Film/Picture *.IC? ? = 1, 2, 3
<br>IFF *.IFF
<br>MacPaint
<br>&nbsp;
<dt><b>Introductory <a href="0205.htm" target="UDOcon">Information</a></b></dt><dd>
<br>&nbsp;
<br>word = 2 bytes
<br>long = 4 bytes
<br>palette = Hardware color palette, stored as 16 words. First word
is
<br>color register zero (background), last word is color register
<br>15. Each word has the form:
<br>
<br>&nbsp;
<br>Bit: (MSB) 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 (LSB)
<br>- - - - - - - - - - - - - - - -
<br>Described below: 0 0 0 0 0 R2 R1 R0 0 G2 G1 G0 0 B2 B1 B0
<br>
<br>&nbsp;
<br>R2 = MSB of red intensity
<br>R0 = LSB of red intensity
<br>
<br>&nbsp;
<br>G2 = MSB of green intensity
<br>G0 = LSB of green intensity
<br>
<br>&nbsp;
<br>B2 = MSB of blue intensity
<br>B0 = LSB of blue intensity
<br>
<br>&nbsp;
<br>Intensity ranges from 0 (color not present) to 7 (highest
intensity).
<br>
<br>&nbsp;
<br>Example: { red = 7, green = 3, blue = 5 } -&gt; 0735 (hex)
<br>
<br>&nbsp;
<br>Caveat: It is wise to mask off the upper four bits of each palette
entry, since a few programs store special information there (most
notably Art Studio).
<br>
<br>&nbsp;
<dt><b>The Formats</b></dt><dd>
<br>
<br>
<br>
<br>&nbsp;
<dt><b>NEOchrome&gt; *.NEO</b></dt><dd>
<br>&nbsp;
<br>1 long resolution (0 = low res, 1 = medium res, 2 = high res)
<br>16 words palette
<br>12 bytes filename (usually &quot; . &quot;)
<br>1 byte unused (?) (usually either 80 hex or 0)
<br>1 byte color animation limits (4 most significant bits are
<br>left/lower limit; 4 least significant bits are
<br>right/upper limit).
<br>1 byte color animation enabled? High bit set if yes.
<br>1 byte color animation speed and direction
<br>x = 0 means animation stopped
<br>x &lt; 0 means colors cycle to the left (decreasing)
<br>x &gt; 0 means colors cycle to the right (ascending)
<br>Number of vblanks between cycles is |x| - 1
<br>19 longs reserved for expansion
<br>16000 words picture data (screen memory)
<br>---
<br>32128 bytes total
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>NEOchrome Animation&gt; *.ANI</b></dt><dd>
<br>&nbsp;
<br>NOTE: To get this feature on versions 0.9 and later select the
Grabber
<br>icon and click both mouse buttons in the eye of the second R in
the
<br>word GRABBER.
<br>Interestingly enough, some versions of NEO only require you
<br>to press the right button, not both. Hmmm...
<br>
<br>&nbsp;
<br>1 long magic number BABEEBEA (hex) (seems to be ignored)
<br>1 word width of image in bytes (always divisible by 8)
<br>1 word height of image in scan lines
<br>1 word size of image in bytes + 10 (!)
<br>1 word x coordinate of image (must be divisible by 16) - 1
<br>1 word y coordinate of image - 1
<br>1 word number of frames
<br>1 word animation speed (# vblanks to delay between frames)
<br>1 long reserved; should be zero
<br>--
<br>22 bytes total for header
<br>
<br>&nbsp;
<br>? words image data (words of screen memory) for each frame, in
order
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>DEGAS&gt;</b></dt><dd> *.PI1 (low resolution)
<br>*.PI2 (medium resolution)
<br>*.PI3 (high resolution)
<br>
<br>&nbsp;
<br>1 word resolution (0 = low res, 1 = medium res, 2 = high res)
<br>Other bits may be used in the future; use a simple bit
<br>test rather than checking for specific word values.
<br>16 words palette
<br>16000 words picture data (screen memory)
<br>---
<br>32034 bytes total
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>DEGAS Elite&gt;</b></dt><dd> *.PI1 (low resolution)
<br>*.PI2 (medium resolution)
<br>*.PI3 (high resolution)
<br>
<br>&nbsp;
<br>1 word resolution (0 = low res, 1 = medium res, 2 = high res)
<br>Other bits may be used in the future; use a simple bit
<br>test rather than checking for specific word values.
<br>16 words palette
<br>16000 words picture data (screen memory)
<br>4 words left color animtion limit table (starting color numbers)
<br>4 words right color animation limit table (ending color numbers)
<br>4 words animation channel direction flag (0 = left, 1 = off, 2 =
right)
<br>4 words 128 - animation channel delay in 1/60's of a second. [0 -
128]
<br>(I.e., subtract word from 128 to get 1/60th's of a second.)
<br>---
<br>32066 bytes total
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>DEGAS Elite&gt; (Compressed)</b></dt><dd> *.PC1 (low resolution)
<br>*.PC2 (medium resolution)
<br>*.PC3 (high resolution)
<br>
<br>&nbsp;
<br>1 word resolution (same as Degas, but high order bit is set;
<br>i.e., hex 8000 = low res, hex 8001 = medium res,
<br>hex 8002 = high res). Other bits may be used in the
<br>future; use a simple bit test rather than checking
<br>for specific word values.
<br>16 words palette
<br>&lt; 32000 bytes control bytes
<br>4 words left color animtion limit table (starting color numbers)
<br>4 words right color animation limit table (ending color numbers)
<br>4 words animation channel direction flag (0 = left, 1 = off, 2 =
right)
<br>4 words 128 - animation channel delay in 1/60's of a second. [0 -
128]
<br>(I.e., subtract word from 128 to get 1/60th's of a second.)
<br>---
<br>&lt; 32066 bytes total
<br>
<br>&nbsp;
<br>Control byte meanings:
<br>
<br>&nbsp;
<br>For a given control byte, x:
<br>
<br>0 &lt;= x &lt;= 127 Use the next x + 1 bytes literally (no
repetition)
<br>-127 &lt;= x &lt;= -1 Use the next byte -x + 1 times
<br>-128 No operation (not used)
<br>
<br>Compression Scheme:
<br>
<br>Each scan line is compressed separately; i.e., all data for a
given scan line appears before any data for the next scan line. The
scan lines are specified from top to bottom (i.e., 0 is first). For
each scan line, all the data for a given bit plane appears before any
data for the next higher order bit plane. To clarify: The first data
in the file will be the data for the highest order bit plane of scan
line zero, followed by the data for the next lower order bit plane of
scan line zero, etc., until all bit planes have been specified for
scan line zero. The next data in the file will be the data for the
highest order bit plane of scan line one, followed by the data for the
next lower order bit plane of scan line one, etc., until all bit
planes have been specified for all scan lines.
<br>
<br>
<br>&nbsp;
<br>Caveats:
<br>
<br>
<br>&nbsp;
<br>DEGAS Elite's picture loading routine places some restrictions on
compressed DEGAS files:
<br>
<br>&nbsp;
<br>o Elite uses a 40-byte buffer to store data being decompressed.
<br>
<br>&nbsp;
<br>o Whenever a control command is encountered, bytes are stuffed
<br>in this buffer.
<br>
<br>&nbsp;
<br>o The buffer is only emptied when there are EXACTLY 40
<br>characters in it.
<br>
<br>&nbsp;
<br>The important conclusion here is that
<br>
<br>&nbsp;
<br>No control command may cause the buffer to have more than 40
<br>bytes in it. In other words, all control commands must end on
<br>or before the 40-byte boundary.
<br>
<br>&nbsp;
<br>Any picture violating the last condition will cause Elite to get a
bus
<br>error when the picture is loaded.
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Tiny&gt; *.TNY</b></dt><dd>
<br>&nbsp;
<br>*.TN1 (low resolution)
<br>*.TN2 (medium resolution)
<br>*.TN3 (high resolution)
<br>
<br>&nbsp;
<br>Several people have reported sightings of mutated Tiny pictures
that do not follow the standard format, so let's be careful out there.
What is described here is the format that David Mumper's original
TNYSTUFF.PRG produces.
<br>
<br>&nbsp;
<br>1 byte resolution (same as NEO, but +3 indicates rotation
<br>information also follows)
<br>
<br>If resolution &gt; 2 {
<br>1 byte left and right color animation limits. High 4 bits
<br>hold left (start) limit; low 4 bits hold right (end)
<br>limit
<br>1 byte direction and speed of color animation (negative value
<br>indicates left, positive indicates right, absolute value
<br>is delay in 1/60's of a second.
<br>1 word color rotation duration (number of iterations)
<br>}
<br>
<br>&nbsp;
<br>16 words palette
<br>1 word number of control bytes
<br>1 word number of data words
<br>3-10667 bytes control bytes
<br>1-16000 words data words
<br>---
<br>42-32044 bytes total
<br>
<br>Control byte meanings:
<br>
<br>&nbsp;
<br>For a given control byte, x:
<br>
<br>x &lt; 0 Absolute value specifies the number of unique words to
<br>take from the data section (from 1 to 127)
<br>x = 0 1 word is taken from the control section which specifies
<br>the number of times to repeat the next data word (from
<br>128 to 32767)
<br>x = 1 1 word is taken from the control section which specifies
<br>the number of unique words to be taken from the data
<br>section (from 128 - 32767)
<br>x &gt; 1 Specifies the number of times to repeat the next word
<br>taken from the data section (from 2 to 127)
<br>
<br>&nbsp;
<br>Format of expanded data:
<br>
<br>&nbsp;
<br>The expanded data is not simply screen memory bitmap data;
instead, the
<br>data is divided into four sets of vertical columns. (This results
in
<br>better compression.) A column consists of one specific word taken
<br>from each scan line, going from top to bottom. For example, column
1
<br>consists of word 1 on scanline 1 followed by word 1 on scanline 2,
etc.,
<br>followed by word 1 on scanline 200.
<br>The columns appear in the following order:
<br>
<br>&nbsp;
<br>1st set contains columns 1, 5, 9, 13, ..., 69, 73, 77 in order
<br>2nd set contains columns 2, 6, 10, 14, ..., 70, 74, 78 in order
<br>3rd set contains columns 3, 7, 11, 15, ..., 71, 75, 79 in order
<br>4th set contains columns 4, 8, 12, 16, ..., 72, 76, 80 in order
<br>
<br>&nbsp;
<br>Note that Tiny partitions the screen this way regardless of
resolution; i.e.,
<br>these aren't bitplanes. For example, medium resoltion only has two
bitplanes,
<br>but Tiny still divides medium resolution pictures into four parts.
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Spectrum 512&gt; *.SPU</b></dt><dd>
<br>80 words first scan line of picture (unused) - should be zeroes
<br>15920 words picture data (screen memory) for scan lines 1 through
199
<br>9552 words 3 palettes for each scan line (the top scan line is
<br>not included because Spectrum 512 can't display it)
<br>---
<br>51104 bytes total
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Spectrum 512&gt; (Compressed) *.SPC</b></dt><dd>
<br>&nbsp;
<br>1 word 5350 (hex) (&quot;SP&quot;)
<br>1 word 0 (reserved for future use)
<br>1 long length of data bit map
<br>1 long length of color bit map
<br>&lt;= 32092 bytes compressed data bit map
<br>&lt;= 17910 bytes compressed color bit map
<br>---
<br>&lt; 50014 bytes total
<br>
<br>&nbsp;
<br>Data compression:
<br>
<br>Compression is via a modified run length encoding (RLE) scheme,
<br>similar to DEGAS compressed and Tiny. The data map is stored as a
<br>sequence of records. Each record consists of a header byte
followed by
<br>one or more data bytes. The meaning of the header byte is as
follows:
<br>
<br>For a given header byte, x:
<br>
<br>0 &lt;= x &lt; 127 Use the next x + 1 bytes literally (no
repetition)
<br>-128 &lt;= x &lt; 0 Use the next byte -x + 2 times
<br>
<br>The data appears in the following order:
<br>
<br>1. Picture data, bit plane 0, scan lines 1 - 199
<br>2. Picture data, bit plane 1, scan lines 1 - 199
<br>3. Picture data, bit plane 2, scan lines 1 - 199
<br>4. Picture data, bit plane 3, scan lines 1 - 199
<br>
<br>Decompression of data ends when 31840 data bytes have been used.
<br>
<br>Color map compression:
<br>
<br>Each 16-word palette is compressed separately. There are three
<br>palettes for each scan line (597 total). The color map is stored
as a
<br>sequence of records. Each record starts with a 1-word bit vector
which
<br>specifies which of the 16 palette entries are included in the data
<br>following the bit vector (1 = included, 0 = not included; i.e.,
stays
<br>the same). The least significant bit of the bit vector refers to
<br>palette entry zero, while the most significant bit refers to
palette
<br>entry 15. Bit 15 must be zero, since Spectrum 512 does not use
palette
<br>entry 15. Bit 0 should also be zero, since Spectrum 512 always
makes the
<br>background color black.
<br>The words specifying the values for the palette entries indicated
in
<br>the bit vector follow the bit vector itself, in order (0 - 15).
<br>Yes, it is hideously complex.
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Art Director&gt; *.ART</b></dt><dd>
<br>16000 words picture data (screen memory)
<br>16 words palette
<br>15 * 16 words 15 more palettes for animation
<br>---
<br>32512 bytes total
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>C.O.L.R. Object Editor Mural&gt; *.MUR</b></dt><dd>
<br>16000 words picture data (screen memory)
<br>(palettes are stored in separate files)
<br>---
<br>32000 bytes total
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Doodle *.DOO</b></dt><dd>
<br>16000 words picture data (screen memory)
<br>---
<br>32000 bytes total
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Animatic Film&gt; *.FLM</b></dt><dd>
<br>1 word number of frames
<br>16 words palette
<br>1 word speed (0 - 99; value is 99 - # vblanks to delay between
frames)
<br>1 word direction (0 = forwards, 1 = backwards)
<br>1 word end action (what to do after the last frame)
<br>0 = pause, then repeat from beginning
<br>1 = immediately repeat from beginning
<br>2 = reverse (change direction)
<br>1 word width of film in pixels
<br>1 word height of film in pixels
<br>1 word Animatic version number (major)
<br>1 word Animatic version number (minor)
<br>1 long magic number 27182818 (hex)
<br>3 longs reserved for expansion (should be all zeros)
<br>--
<br>32 words total for header
<br>
<br>
<br>? words image data (words of screen memory) for each frame, in
order
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>GEM Bit Image&gt; *.IMG</b></dt><dd>
<br>2 words upper left x,y of bit image
<br>2 words lower right x,y of bit image
<br>1 word device page width
<br>1 word device page height
<br>1 word device pixel width in microns
<br>1 word device pixel height in microns
<br>1 word NBITSPPXL, (bits per pixel, planes, for color information)
<br>7 words reserved (0)
<br>--
<br>32 bytes total for header
<br>
<br>? bytes data
<br>
<br>Format of data
<br>
<br>Run-length packet:
<br>+0 [1] run length (1..127)
<br>+1 [1] color index (1..255)
<br>
<br>Extended packet:
<br>+0 [1] -1 (opcode, $FF)
<br>+1 [1] extended run length (i.e. *128 pixels)
<br>+2 [1] color index
<br>
<br>Raster packet:
<br>+0 [1] -2 (opcode, $FE)
<br>+1 [1] NPXL, # of pixels in stream
<br>+2 [..] packed color indices [NPXL*NBITSPPXL bits]
<br>
<br>Raster-run packet:
<br>+0 [1] ? (opcode)
<br>+1 [1] pattern repeat count
<br>+2 [1] NPXL, # of pixels in stream
<br>+3 [..] packed color indices
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Image&gt; *.IMG</b></dt><dd>
<br>1 word version number of image file
<br>1 word length of header in words [8]
<br>1 word number of color planes
<br>1 word pattern length in bytes [2]
<br>1 word pixel width in 1/1000 mm
<br>1 word pixel height in 1/1000 mm
<br>1 word line width in pixels
<br>1 word number of lines
<br>--
<br>16 bytes total for header
<br>
<br>? bytes data
<br>
<br>For each byte x in the data section,
<br>
<br>x = 0 Pattern/scanline run.
<br>Read the next byte, n (unsigned).
<br>
<br>If n &gt; 0 then:
<br>Read a number of bytes equal to the &quot;pattern
<br>length&quot; word in the header. Repeat this
<br>pattern n times.
<br>
<br>If n = 0 then:
<br>Scanline run. Data for the next scanline
<br>is to be used multiple times. Read the
<br>following record:
<br>
<br>1 word unused (?) [255]
<br>1 word number of times to use
<br>next scanline data
<br>
<br>&nbsp;
<br>The data for the next scanline follows,
<br>compressed normally.
<br>
<br>x = 80 (hex) Uncompressed bit string. The next byte
<br>determines the number of bytes (?) to use
<br>literally. The literal data bytes follow.
<br>
<br>otherwise Monochrome run. The value of x determines
<br>what to draw. The high bit specifies the color.
<br>The low 7 bits, taken as an unsigned quantity,
<br>specify the length of the run (the number
<br>of pixels to draw).
<br>
<br>
<br>
<br>&nbsp;
<dt><b>STAD&gt; *.PAC</b></dt><dd>
<br>4 bytes &quot;pM86&quot; (vertically packed) or &quot;pM85&quot;
(horizontally packed)
<br>1 byte id byte
<br>1 byte pack byte (most frequently occuring byte in bitmap)
<br>1 byte &quot;special&quot; byte
<br>--
<br>7 bytes total for header
<br>
<br>? bytes data
<br>
<br>The data is encoded as follows. For each byte x in the data
section:
<br>
<br>x = id byte Read one more byte, n. Use pack byte
<br>n + 1 times.
<br>x = &quot;special&quot; byte Read two more bytes, d, and n (in
order).
<br>Use byte d n times.
<br>otherwise Use byte x literally.
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>Imagic Film/Picture&gt;</b></dt><dd> *.IC1 (low resolution)
<br>*.IC2 (medium resolution)
<br>*.IC3 (high resolution)
<br>
<br>4 bytes &quot;IMDC&quot;
<br>1 word resolution (0 = low res, 1 = medium res, 2 = high res)
<br>16 words palette
<br>1 word date (GEMDOS format)
<br>1 word time (GEMDOS format)
<br>8 bytes name of base picture file (for delta compression), or
zeroes
<br>1 word length of data (?)
<br>1 long registration number
<br>8 bytes reserved
<br>1 byte compressed? (0 = no, 1 = yes)
<br>
<br>If compressed {
<br>1 byte delta-compressed? (-1 = no, &gt; -1 = yes)
<br>1 byte ?
<br>1 byte escape byte
<br>}
<br>--
<br>65 bytes total for header (68 bytes if compressed)
<br>
<br>? bytes data
<br>
<br>Compressed data may be either stand-alone or delta-compressed
(relative to the base picture named in the header). Delta compression
involves storing only how the picture differs from the base picture
(i.e., only portions of the screen that have changed are stored). This
is used to to encode animated sequences efficiently.
<br>
<br>Compressed data, stand-alone:
<br>
<br>For each byte x in the data section:
<br>
<br>x = escape byte Read one more byte, n. (n is unsigned).
<br>
<br>If n &gt;= 2, use the next byte n times.
<br>If n = 1, keep reading bytes until a
<br>byte k not equal to 1 is encountered.
<br>Then read the next byte d.
<br>If the number of 1 bytes encountered is o,
<br>use d (256 * o + k) times. I.e.,
<br>
<br>if (n == 1) {
<br>o = 0;
<br>while (n == 1) {
<br>o++;
<br>n = next byte;
<br>}
<br>
<br>k = n;
<br>d = next byte;
<br>
<br>Use d (256 * o + k) times.
<br>}
<br>else {
<br>d = next byte;
<br>Use d (n) times.
<br>}
<br>
<br>x != escape byte Use x literally.
<br>
<br>Compressed data, delta compressed:
<br>
<br>For each byte x in the data section:
<br>
<br>x = escape byte Read one more byte, n. (n is unsigned).
<br>
<br>If n &gt;= 3, use the next byte n times.
<br>If n = 1, do the same as for n = 1 in
<br>stand-alone compression (above).
<br>If n = 2, then set n = next byte.
<br>If n = 0, end of picture.
<br>If n &gt;= 2, take n bytes from base
<br>picture.
<br>If n = 1, do the same as for n = 1
<br>in stand-alone compression (above),
<br>but take (256 * o + k) bytes from
<br>base picture.
<br>
<br>x != escape byte Use x literally.
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>IFF Format&gt; *.IFF</b></dt><dd>
<br>4 bytes &quot;FORM&quot;
<br>8 bytes form chunk: 1 long = length (8)
<br>4 bytes = ID (&quot;ILBM&quot;)
<br>4 bytes &quot;BMHD&quot;
<br>20 bytes BMHD chunk: 1 long = length (20)
<br>(BitMap 1 word = x width (pixel)
<br>HeaDer) 1 word = y height (pixel)
<br>1 word = x-offset (pixel)
<br>1 word = y-offset (pixel)
<br>1 byte = # bitplanes
<br>1 byte = mask (0=no, 1=impl., 2=transparent,
<br>3=lasso)
<br>1 byte = compressed (1) or expanded (0)
<br>1 byte = 0
<br>1 word = transparent color (for mask=2)
<br>1 byte = x-aspect
<br>1 byte = y-aspect
<br>1 word = page width
<br>1 word = page height
<br>4 bytes &quot;CMAP&quot;
<br>3n+8 bytes CMAP chunk: 1 long = length (3n + 8 for n colors)
<br>(Color 3 words = R,G,B color 0
<br>MAP) ...
<br>3 words = R,G,B color n
<br>4 bytes &quot;CRNG&quot;
<br>8 bytes CRNG chunk: 1 long = length (8)
<br>(Color 1 word = 0
<br>RaNGe) 1 word = animation speed
<br>1 word = active (1) or inactive (0)
<br>4 bytes &quot;BODY&quot;
<br>? bytes body chunk: picture expanded/compressed
<br>
<br>Format of body data
<br>
<br>An expanded picture is simply a bitmap. The compressed data
consists
<br>of records of single control bytes followed by data.
<br>
<br>For a given control byte, x:
<br>
<br>0 &lt;= x &lt;= 127 Use the next x + 1 bytes literally (no
repetition)
<br>-128 &lt;= x &lt;= -1 Use the next byte -x + 1 times
<br>
<br>The (decompressed) body data appears in the following order:
<br>
<br>line 1 plane 0 ... line 1 plane 1 ... ... line 1 plane m
<br>[line 1 mask (if appropriate)]
<br>line 2 plane 0 ... line 2 plane 1 ... ... line 2 plane m
<br>[line 2 mask (if appropriate)]
<br>...
<br>line x plane 0 ... line x plane 1 ... ... line x plane m
<br>[line x mask (if appropriate)]
<br>
<br>&nbsp;
<br>The FORM chunk identifies the type of data:
<br>
<br>&nbsp;
<br>&quot;ILBM&quot; = interleaved bit map
<br>&quot;8SVX&quot; = 8-bit sample voice
<br>&quot;SMUS&quot; = simple music score
<br>&quot;FTXT&quot; = formatted text (Amiga)
<br>
<br>Note:
<br>The R,G,B ranges of AMIGA and ST are different (AMIGA 0...15, ST
0...7),
<br>as is the maximum number of bitplanes (AMIGA: 5, ST: 4).
<br>
<br>Animation speed of 16384 means 1 full rotation in 1/60's of a
second.
<br>
<br>&nbsp;
<br>
<br>
<br>
<br>&nbsp;
<dt><b>MacPaint&gt;</b></dt><dd>
<br>Word has it that this is wrong. Someone please send me an accurate
<br>description!
<br>
<br>header {
<br>1 long version number (if zero, entire header is ignored)
<br>38 * 2 longs pattern data (anyone know how to use this?)
<br>83 longs reserved
<br>} (total 160 longwords for header)
<br>&lt; 51200 bytes compressed bitmap data
<br>---
<br>&lt; 51716 bytes total
<br>
<br>Bitmap compression:
<br>
<br>The bitmap data is for a 576 pixel by 720 pixel monochrome image.
<br>The data is stored as a sequence of records. Each record consists
of a
<br>control byte followed by one or more data bytes. The meaning of
the
<br>control byte is as follows:
<br>
<br>For a given control byte, x:
<br>
<br>0 &lt; x &lt; 127 Use the next x + 1 bytes literally (no
repetition)
<br>-128 &lt;= x &lt;= 0 Use the next byte -x + 1 times
<br>
<br>There are 72 bytes per scan line. Each bit represents one pixel; 0
= white,
<br>1 = black.
<br>
<br>
<br>
<br>&nbsp;
<br>* Roland Waldi contributed extensive information on the following
formats:
<br>GEM, IMG, Doodle, STAD, Imagic Film/Picture, Art Director, IFF
<br>
<br>&nbsp;
</dl>
<p>
<br>
<br>
</p>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img.gif" border=0 width="50" height="40"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de/">Robert Schaffner</a> (<a href="mailto:doit@doitarchive.de">doit@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Mai 2004</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="19.htm" target="UDOcon"><img src="udo_up.gif" alt="Anhang" border=0 width="24" height="24"></a>
<a href="1901.htm" target="UDOcon"><img src="udo_lf.gif" alt="Der Anfang.." border=0 width="24" height="24"></a>
<a href="1903.htm" target="UDOcon"><img src="udo_rg.gif" alt="BEST-Electronics" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>

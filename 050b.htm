<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.05.2004 -->
<html>
<head>
<title>
DOIT_ST - Tips u. Tricks zur Atari Serie: Milan PCI Hardware 2
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="doit@doitarchive.de">
<link rev=made href="mailto:doit@doitarchive.de" title="E-Mail">
<link rel=home href="doitst1h.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="05.htm" target="UDOcon"><img src="udo_up.gif" alt="Milan Hardware" border=0 width="24" height="24"></a>
<a href="050a.htm" target="UDOcon"><img src="udo_lf.gif" alt="Milan PCI Hardware 1" border=0 width="24" height="24"></a>
<a href="050c.htm" target="UDOcon"><img src="udo_rg.gif" alt="Milan SCSI Hardware" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="Milan_20PCI_20Hardware_202">5.11 Milan PCI Hardware 2</a></h1>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p><tt> Sonder-Edition PCI-BIOS MILAN </tt>
<br>
<br>
</p>
<p><img src="image/deutsch.gif" border=0 width="35" height="22"></p><br>
<p>
<br>
<br>
</p>
<p>Sonder-Edition PCI-BIOS Stand: 09. 07.1998
<br>
</p>
<p>Von:
<br>Markus Fichtenbauer
<br>Torsten Lang
<br>Michael Schwingen
<br>
<br>
</p>
<p><b> Der PCI-Bus (Part 1) </b>
<br>
<br>Heute ist es soweit: Mit dem Milan und dem Hades stehen den
ATARI-Anwendern inzwischen zwei Rechner zur Verf&uuml;gung, die einen
PCI-Bus besitzen. Schon bald soll ein Falcon-PCI-Adapter erscheinen,
und eines Tages wird auch der franz&ouml;sische Phenix mit PCI-Bus zu
erhalten sein. Alles deutet also darauf hin, da&szlig; PCI-Karten nun
auch f&uuml;r das TOS angepasst werden. Erfreulicherweise ist die
Entwicklung in diesem Bereich soweit vorangeschritten, da&szlig; ein
gemeinsames PCI-Bios entwickelt wurde, das erm&ouml;glicht, da&szlig;
einmal angepasste Treiber auf allen o.g. Systemen laufen werden. In
unserem mehrteiligen Kurs wollen wir Sie &uuml;ber die Funktionsweise
des PCI-Busses und anschliessend die Programmierung des TOS PCI-Bios
informieren.
<br>
<br>
</p>
<p><b> Allgemeines: </b>
<br>
<br>
</p>
<p>Der Peripheral Components Interconnect (PCI) Bus wurde
urspr&uuml;nglich f&uuml;r IBM-kompatible PCs entwickelt, da dringend
die Notwendigkeit eines schnellen, prozessorunabh&auml;ngigen
Bussystems bestand. Seither hat sich dieser Bus auch &uuml;r andere
Rechnerwelten etabliert (wie z.B. die aktuellen Macintosh-Modelle auf
Basis des PowerPC, diverse Workstations mit DECs Alpha-Prozessor oder
aber auch die aktuelle UltraSparc von SUN). Auch die Entwickler des
Hades und des Milan haben an diese wirklich universelle Schnittstelle
gedacht. Diese Entwicklung f&uuml;hrte dahin, da&szlig; man nun
tats&auml;chlich dieselben Erweiterungskarten auf unterschiedlichen
Rechnerplattformen nutzen kann - sofern jeweils Treiber &uuml;r das
betreffende System ver&uuml;gbar sind. Daher ist es l&auml;ngst an der
Zeit, sich einmal n&auml;her mit dem PCI-Bus zu besch&auml;ftigen.
Diese erste Folge soll einen &uuml;berblick der M&ouml;glichkeiten des
PCI-Bus schaffen, die zweite Folge beschreibt dann die einzelnen
Register f&uuml;r die Initialisierung und Konfiguration von
PCI-Karten, und die abschlie&szlig;ende dritte Folge befa&szlig;t sich
dann mit der Portierung und Implementierung des vom PC her bekannten
PCI-BIOS f&uuml;r ATARI-kompatible Rechner am Beispiel von Hades und
Milan. Der PCI-Bus ist f&uuml;r 32 Bit breite Daten bei maximal 33 MHz
spezifiziert und ist optional auf 64 Bit und/oder 66 MHz erweiterbar.
Der Takt darf aber im Prinzip einen beliebigen Wert zwischen 0 und 33
MHz annehmen. Bei 33 MHz und 32 Bit Datenbreite sind theoretische
&Uuml;bertragungsraten von bis zu 132 MB/s m&ouml;glich, und in der
Praxis sind tats&auml;chlich Werte nahe diesem theoretischen Maximum
erreichbar. Nach der elektrischen Spezifikation k&uuml;nnen an einem
PCI-Bus bis zu vier Slots neben dem Hostsystem untergebracht sein.
&uuml;ber eine PCI-Bridge l&auml;&szlig;t sich dann noch ein weiterer
Bus anh&auml;ngen. Falls dies wieder ein PCI-Bus ist, kann man das
Spiel auch mehrfach wiederholen. Jedes PCI-Ger&auml;t kann mehrere
unabh&auml;ngige Funktionen beinhalten (multifunction devices), die
sich auch unabh&auml;ngig &uuml;ber den Bus ansprechen lassen. Die
meisten derzeit erh&auml;ltlichen Ger&auml;te sind allerdings
sogenannte 'single function devices'. Multi function devices verhalten
sich prinzipiell wie mehrere single function devices, nur, da&szlig;
eben die Configuration Bereiche der einzelnen Funktionen dieser Karten
anders angesprochen werden. Bei den Multifunktionskarten kann man zwei
von Grund auf verschiedene Versionen unterscheiden:
<br>
</p>
<dl>
<dt><b>1.</b></dt><dd> Nur ein einziger Bus - die Konfigurationsbereiche solcher
PCI-Karten liegen jeweils 256 Bytes auseinander (d.h. die
Adressleitungen spiegeln einfach Register (Bit 0-7) und
Funktionsnummer (Bit 8-15) der Karte wieder.
<br>&nbsp;
<dt><b>2.</b></dt><dd> PCI2PCI-Bridge mit single function devices oder multi function
devices vom Typ 1 am zweiten Bus - so etwas kommt z.B. bei Kombikarten
wie Ethernet + SCSI vor. Da die Busnummer hier &uuml;ber die
Adressleitungen A16-23 ausgew&auml;hlt werden w&uuml;rde, lassen sich
solche Karten beim Hades wahrscheinlich nicht oder nur
eingeschr&auml;nkt verwenden (weil die Konfigurationsbereiche ja auf
wenige KB beschr&auml;nkt sind).
<br>&nbsp;
</dl>
<p>
<br>
<br>
</p>
<p><b> Die PCI-Hardware: </b>
<br>
<br>
</p>
<p>F&uuml;r die grundlegenden Funktionen des PCI-Bus werden insgesamt
47 Pins f&uuml;r Slave-Adapter sowie 49 Pins f&uuml;r Master-Adapter
ben&ouml;tigt. Dazu kommen die Anschl&uuml;sse der
Versorgungsspannung. Auf eine Aufz&auml;hlung aller Signale finden Sie
ganz am Anfang dieses Artikels, eine genaue Beschreibung aller Signale
erfolgt hier noch nicht, da diese den Artikel sichtlich sprengen
w&uuml;rden. Deshalb sollen nur die wichtigsten, in den Abbildungen
verwendeten Signale n&auml;her erl&auml;utert werden:
<br>
</p>
<dl>
<dt><b>AD 80..31</b></dt><dd> - Address/Data
<br>
<br>&nbsp;
<br>Adressen und Daten werden gemultiplext &uuml;bertragen. Die
einzelnen Bytes des 32-Bit-Wortes werden &uuml;ber die Leitungen
/C/BE[0..3] freigegeben.
<br>&nbsp;
<dt><b>/C/BE 0..3</b></dt><dd> - Command/Byte Enable
<br>
<br>&nbsp;
<br>Enth&auml;lt in der Adressphase das Buskommando (verschiedene
Lese- und Schreibarten) und in der Datenphase das Signal Byte Enable
f&uuml;r die Datenleitungen.
<br>&nbsp;
<dt><b>IDSEL</b></dt><dd> - Initialization Device Select
<br>
<br>&nbsp;
<br>Chip Select f&uuml;r Initialisierung und Konfiguration der
PCI-Karte.f&uuml;r jeden PCI-Slot ist eine eigene Leitung vorhanden.
<br>&nbsp;
<dt><b>/REQ</b></dt><dd> - Request, wird nur f&uuml;r Busmastering verwendet
<br>
<br>&nbsp;
<br>Busanforderung, f&uuml;r jeden Slot ist eine Leitung vorhanden.
<br>&nbsp;
<dt><b>/GNT</b></dt><dd> - Grant, wird nur f&uuml;r Busmastering verwendet.
<br>
<br>&nbsp;
<br>Buszuteilung,f&uuml;r jeden Slot ist eine Leitung vorhanden.
<br>&nbsp;
<dt><b>/INTA</b></dt><dd> - Interrupt Request A
<br>
<br>&nbsp;
<br>Anforderung eines Interrupts bei single function devices.
<br>&nbsp;
<dt><b>/INTB, C, D</b></dt><dd> - Interrupt Request B, C, D
<br>&nbsp;
<br>Diese Interruptleitungen d&uuml;rfen nur von Ger&auml;ten mit
mehreren Funktionseinheiten (multi function devices) verwendet werden.
Die restlichen Signale dienen mehr oder weniger der Steuerung
w&auml;hrend den verschiedenen Adress- und Datenphasen und deren
Synchronisation. N&auml;heres findet man in der PCI Local Bus
Specification und den PCI System Design Guides, einen guten
&uuml;berblick kann man sich aber auch mittels der Elrad-Hefte 3/97
und 4/97 verschaffen. Da wir hier nicht neue PCI-Karten entwickeln
m&ouml;chten, sondern aus dem PC-Bereich bereits vorhandene Karten
auch dem Hades, Milan und anderen kompatiblen ATARI-Rechnern
schmackhaft machen m&uuml;chten, verzichten wir hier auf weitere
Hardware-Details, dief&uuml;r Treiber-Anpassungen nicht relevant sind.
Die korrekte Verarbeitung der Signale sollte ja ohnehin von den in den
Rechnern vorhandenen PCI-Bridges &uuml;bernommen werden. Wer aber
trotzdem (oder gerade deswegen) eigene Karten entwickeln m&uuml;chte,
sollte sich Datenbl&auml;tter der PCI-Bridges von AMCC[4] und PLX[5]
besorgen. Wer das PCI-Busprotokoll selbst implementieren m&ouml;chte,
ben&ouml;tigt da&uuml;r relativ schnelle CPLDs oder FPGAs. Hersteller
wie Xilinx[6] oder Lattice[7] bieten da&uuml;r auch Beispiel-Sourcen
an.
<br>&nbsp;
</dl>
<p>
<br>
<br>
</p>
<p><b> DMA am PCI-Bus: </b>
<br>
<br>
</p>
<p>Grunds&auml;tzlich kann jedes beliebige PCI-Ger&auml;t als
Busmaster auftreten. Als Busmaster kann dieses PCI-Ger&auml;t dann
selbst&auml;ndig Daten aus seinem eigenen Speicherbereich in den
Systemspeicher des Host-Rechners &uuml;bertragen. Diese Art der
Hintergrundverarbeitung entlastet den Prozessor des Host-Rechners sehr
stark. Deshalb sollten alle PCI-Ger&auml;te, die gro&szlig;e
Datenmengen zu transportieren haben, oder aber schnelle Transfers
erfordern, als Busmaster auftreten k&uuml;nnen. Die DMA-F&auml;higkeit
des PCI-Bus benutzen z.B. SCSI-Controller oder auch moderne
Netzwerkkarten, um Daten schnell in den oder aus dem Hauptspeicher zu
transportieren. Die Vorteile bei Verwendung eines
busmasterf&auml;higen PCI-Ger&auml;tes zeigen sich ganz besonders bei
'echten' Multitasking-Betriebssystemen, da dort die gesparte
Rechenzeit anderen Prozessen zur Verf&uuml;gung gestellt werden kann.
Unter Single-Tasking unterliegt es dem Geschick des Programmierers,
aus der Busmaster-F&auml;higkeit eines PCI-Ger&auml;tes Vorteile zu
ziehen. Ein Zugriff, der nur auf das Ende einer &uuml;bertragung
wartet, ist zwar einfacher zu implementieren, verschenkt durch
Leerlauf des Prozessors aber wieder die gewonnene Zeit. Das
busmasterf&auml;hige PCI-Ger&auml;t fordert den Bus durch Setzen
seiner /REQLeitung an. Ein Master darf /REQ allerdings nurf&uuml;r
seinen aktuellen Zugriff benutzen, nicht aber, um sich den Bus auf
Dauer zu sichern. Der Bus Arbiter des Host-Rechners teilt diesem
Ger&auml;t den Bus durch Setzen des entsprechenden /GNT-Signals zu.
Nachdem dem PCI-Ger&auml;t der Bus zugeteilt wurde, kann dieses seinen
DMA-Zugriff durch&uuml;hren. Wenn das PCI-Ger&auml;t nicht innerhalb
einer bestimmten Zeit den Bus wieder freigibt, kann der Host-Rechner
durch das Wegnehmen der /GNT-Leitung den Bus auch wieder frei
bekommen. Der Busmaster mu&szlig; dann n&auml;mlich augenblicklich den
Zugriff beenden.
<br>
<br>
</p>
<p><b> Interrupts am PCI-Bus: </b>
<br>
<br>
</p>
<p>Auf dem PCI-Bus sind insgesamt vier &quot;pegel&quot;-getriggerte
Interrupt-Leitungen vorhanden (INTA...INTD). Alle Ger&auml;te mit nur
einer Funktion d&uuml;rfen nur INTA verwenden, die anderen drei
Leitungen sindf&uuml;r den Betrieb sogenannter 'multi function
devices' vorgesehen. In der PCI-Spezifikation selbst ist die weitere
Verarbeitung der Interrupts nicht definiert und wird somit dem
jeweiligen Boardhersteller &uuml;berlassen. Die Interruptleitungen der
einzelnen Slots k&uuml;nnen daher entweder als
&quot;durchgeschleifte&quot; Busleitung (open drain) in jeder nur
erdenklichen Kombination verbunden sein, oder aber sie werden von
jedem Slot einzeln an den entsprechenden Interrupt Controller
herange&uuml;hrt. Nach einer Interruptanforderung ist dann der
jeweilige Treiber dieses PCI-Ger&auml;tes da&uuml;r verantwortlich,
die Ursache der Unterbrechungsanforderung zu beheben. Im Gegensatz zum
recht kranken Design des ISA-Busses ist es daher beim PCI-Bus
m&uuml;glich, da&szlig; sich mehrere Karten eine Interruptleitung
teilen (shared interrupt) - Engp&auml;sse, wie man sie fr&uuml;her von
den DOSen her kannte, werden damit vermieden. Allerdings m&uuml;ssen
dann die eingesetzten Softwaretreiberf&uuml;r die PCI-Karten auch
Interrupts bearbeiten k&uuml;nnen, bei denen sich mehrere Ger&auml;te
eine Interruptleitung teilen. Mehr zu diesem Thema gibt es dann bei
der Vorstellung des PCI-BIOS.
<br>
<br>
</p>
<p><b> Die Implementation des PCI-Bus im Milan: </b>
<br>
</p>
<p>Auch der Milan hat einen PCI-Bus mit einer Datenbreite von 32 Bit
bei maximal 33 MHz. Die Anbindung an die <a href="080108.htm" target="UDOcon">CPU</a> erfolgt &uuml;ber eine
PCI-Bridge der Firma PLX. Es sind insgesamt 4 Interruptleitungen
vorhanden, die zyklisch zwischen den Slots getauscht sind - dadurch
bekommt bei single function devices jede Karte einen eigenen
Interrupt, und erst bei multi function devices wird es n&uuml;tig,
Interrupts gemeinsam zu benutzen. Interrupts werden &uuml;ber die
Intel PCI-ISA-Bridge und die darin vorhandenen Interrupt-Controller
bearbeitet und als Autovektor-Interrupt an die <a href="080108.htm" target="UDOcon">CPU</a> weitergemeldet. Die
Busarbitrierung f&uuml;r die DMA-Zugriffe erfolgt in einem der
Glue-Chips - alle Slots (sowie die Onboard-Peripherie) sind
busmasterf&auml;hig. Es wird eine Arbitrierung mit rotierender
Priorit&auml;t verwendet, bei der die Karte, die gerade den Bus
besitzt, die niedrigste Priorit&auml;t hat, so da&szlig; eine Karte
den Bus nicht komplett blockieren kann.&amp;nbsp; Wenn niemand den Bus
anfordert, wird er bei dem Ger&auml;t, welches ihn zuletzt
besa&szlig;, geparkt - das spart Zeit, wenn danach das gleiche
Ger&auml;t den Bus wieder anfordert.
<br>
<br>
</p>
<p><b> Erweiterungs-ROM auf PCI-Karten: </b>
</p>
<p>Die PCI-Spezifikation beschreibt auch einen Mechanismus, mit dem
ein PCI-Ger&auml;t einen exekutierbaren ROM-Code f&uuml;r eine
ger&auml;tespezifische Initialisierung usw. anbieten kann. Dieses ROM
kann dabei mehrere verschiedene ROM-Images beinhalten, um die
verschiedensten Rechner und Prozessorarchitekturen zu
unterst&uuml;tzen. Der OPENBOOT Standard f&uuml;r PCI sieht
Fortran-Programme im ROM vor, so da&szlig; der ROM-Code zwar langsam
(weil interpretiert), aber da&uuml;r prozessorunabh&auml;ngig ist. Die
andere M&uuml;glichkeit sind native ROM-Images (&uuml;r die jeweilige
zu unterst&uuml;tzende Plattform), wovon die Hersteller aber keinen
Gebrauch machen (wohl weil sich dann nur noch schwer begr&uuml;nden
lie&szlig;e, warum z.B. dieselbe Grafikkartef&uuml;r einen PowerMac
meist 100% teurer ist als f&uuml;r den Intel PC). Nat&uuml;rlich
k&uuml;nnen OPENBOOT-Images und native Images gemeinsam in einem ROM
untergebracht werden. Am ATARI werden die ROMs auf den Karten im
Moment zwar noch nicht genutzt, aber dieser Umstand wird sich schon
demn&auml;chst &auml;ndern.
<br>
<br>
</p>
<p><b> Ein paar Worte zu Plug'n'Play: </b>
<br>
<br>
</p>
<p>Das Zauberwort 'Plug and Play' ist sehr eng mit dem PCI-Bus
verbunden. Denn erst hier ist das leidige Thema der Ressourcenvergabe
f&uuml;r die Hardware &uuml;ber ein geeignetes BIOS (PCI-BIOS) elegant
l&ouml;sbar. Im Idealfall sieht die <a href="0204.htm" target="UDOcon">Installation</a> einer neuen PCI-Karte
also folgenderma&szlig;en aus (im Gegensatz zum PC ist bei
ATARI-kompatiblen ein nochmaliges (oder gar mehrmaliges) Booten
w&auml;hrend der <a href="0204.htm" target="UDOcon">Installation</a> NICHT notwendig ;-)
<br>
<br>
</p>
<p>* Karte in einen freien Slot reinstecken
<br>
</p>
<p>* Rechner starten, das PCI-BIOS konfiguriert die Karte
<br>
</p>
<p>* Softwaretreiber f&uuml;r die PCI-Karte starten und fertig
<br>
<br>
</p>
<p>Der PCI-Bus ist eigentlich selbstkonfigurierend definiert.
Daf&uuml;r beinhaltet jedes PCI-Ger&auml;t einen Satz von Registern,
die w&auml;hrend des Boot-Vorgangs ausgelesen werden k&uuml;nnen.
Enthalten sind hier neben Informationen &uuml;ber das Ger&auml;t
selbst (Hersteller, Ger&auml;t, Typenklasse, M&uuml;glichkeiten,
Waitstates, Interrupt, ...) auch die ben&uuml;tigten Speicherbereiche.
Damit ist es dem BIOS m&uuml;glich, die Karte korrekt ins System
einzubinden, ohne da&szlig; Ressourcenkonflikte auftreten oder sich
der Benutzer mit DIPSchaltern, Jumpern etc. herumschlagen mu&szlig;.
Am Macintosh-Sektor (NuBus) und am Amiga-Sektor (Zorro II/III-Bus) ist
z.B. das Problem der Autokonfigurierung &uuml;brigens bereits seit der
Existenz der jeweiligen Bussysteme (also seit &uuml;ber 10 Jahren)
gel&uuml;st! Der PCI-Standard sieht mittlerweile auch optional die
&quot;Hot-Plug-F&auml;higkeit&quot; vor, so da&szlig; PCI-Karten sogar
im Betrieb gewechselt werden k&uuml;nnen. Das darf aber in keinem Fall
am Hades oder Milan gemacht werden, da dies zur Zerst&uuml;rung des
Mainboards oder der Karte &uuml;hren kann (&uuml;r dieses Feature sind
spezielle Voraussetzungen erforderlich).
<br>
<br>
<br>
</p>
<p><b> Sonder-Edition PCI-BIOS, Part 2 Stand: 09. 07. 1998 </b>
<br>
<br>
</p>
<p>Von:
<br>Markus Fichtenbauer
<br>
</p>
<p>
<br>
<br><b> Der PCI-Bus (Teil 2) </b>
<br>
<br>
</p>
<p>Wie bereits im ersten Teil dieser Serie erw&auml;hnt wurde, hat
jedes PCI-Ger&auml;t einen eigenen Registersatz. Ein Zugriff auf
diesen Konfigurationsbereich erfolgt immer durch paralleles Setzen der
IDSEL-Leitung des ensprechenden Slots und dem Anlegen der
Registeradresse und des Buskommandos Configuration Read oder
Configuration Write auf den Leitungen /C/BE[0..3]. Die IDSEL-Leitung
ist dabei f&uuml;r jeden Slot separat vorhanden und wird vom
Motherboard auskodiert. Nur mit dieser Art der Steuerung ist ein
Zugriff auf die einzelnen Karten direkt nach dem Reset
m&amp;ouml;glich, da zu diesem Zeitpunkt noch keine
Adre&amp;szlig;r&auml;ume zugeteilt wurden. Der Zugriff auf diese
Register wird auf dem PC vom PCI-BIOS &uuml;ber die Befehle
Configuration Read / Configuration Write bereitgestellt. Und in der
n&auml;chsten Folge m&ouml;chte ich dann s&auml;mtliche
M&ouml;glichkeiten eines ATARI PCI-BIOS vorstellen
<br>
<br>
</p>
<p><b> Der PCI Configuration Bereich: </b>
<br>
<br>
</p>
<p>Jede PCI-Karte enth&auml;lt einen Satz von definierten Registern,
die Informationen &uuml;ber die Karte bereitstellen und die die
automatische Vergabe von Ressourcen &uuml;berhaupt erst
erm&ouml;glichen. Der Registerbereich ist 256 Bytes lang und teilt
sich in einen von der PCI-SIG (PCI - Special Interest Group)
vordefinierten und in einen kartenspezifischen Bereich. Dabei
m&uuml;ssen in den jeweiligen PCI-Ger&auml;ten von den beiden
Bereichen nur die notwendigen Register implementiert werden Das
Speicherlayout des 64 Byte langen, vordefinierten Bereichs selbst
mu&amp;szlig; aber von jeder PCI-Karte eingehalten werden und
beinhaltet die Identifikationsdaten der Karte und die
M&ouml;glichkeiten zur generellen Kontrolle &uuml;ber die Karte. Die
folgenden 192 Bytes sind nicht durch die PCI-Spezifikation vorgegeben,
sondern k&ouml;nnen mit herstellerspezifischen Informationen
gef&uuml;llt und danach vom Softwaretreiber ausgewertet werden.
<br>
</p>
<p>Die Register werden w&auml;hrend der Initialisierung des
PCI-Busses ausgewertet und m&uuml;ssen daher schon direkt nach dem
Reset g&uuml;ltige Werte enthalten. Auch sp&auml;ter m&uuml;ssen die
Register im freien Zugriff verbleiben, da zum Beispiel die
<a href="15.htm" target="UDOcon">Systemsoftware</a> (PCI-BIOS) die Informationen &uuml;ber die
Adre&amp;szlig;r&auml;ume ben&ouml;tigt und eventuelle
Statusinformationen abgefragt werden m&uuml;ssen.
<br>
</p>
<p>Um herauszufinden, welche Karten nun am PCI-Bus angeschlossen
sind, kann man die Vendor ID in jedem der im System vorhandenen Slots
auslesen. Die Hostsystem mu&szlig; daher Zugriffe auf die
Konfigurationsbereiche nicht vorhandener Karten (ohne Fehlermeldung)
unterst&uuml;tzen. Da f&uuml;r eine Vendor ID der Wert FFFFhex nicht
erlaubt ist, reicht es daher v&ouml;llig, wenn die Systemhardware bei
Lesezugriffen auf den Konfigurations-Bereich nicht vorhandener Karten
eben diesen Wert zur&uuml;ckliefert.
<br>
</p>
<p>Jedes PCI-Ger&auml;t mu&szlig; Schreibzugriffe auf reservierte
oder nicht unterst&uuml;tzte Register ignorieren, d.h. der
Schreibzugriff mu&szlig; am PCI-Bus ohne Fehlermeldung abgeschlossen
werden. Die Daten selbst werden allerdings von der Karte verworfen.
Lesezugriffe auf reservierte oder nicht implementierte Register
m&uuml;ssen ebenfalls ohne Fehlermeldung am Bus abgeschlossen, und ein
Wert von 0000hex zur&uuml;ckgegeben werden.
<br>
</p>
<p>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 34: Die vordefinierten Konfigurationsregister</caption>
<tr>
  <td align=left valign=top>Configuration Register</td>
  <td align=left valign=top>Adress-Offset</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>Device ID</td>
  <td align=left valign=top></td>
  <td align=left valign=top>Vendor ID</td>
  <td align=left valign=top></td>
  <td align=left valign=top>00h</td>
</tr>
<tr>
  <td align=left valign=top>Status</td>
  <td align=left valign=top></td>
  <td align=left valign=top>Command</td>
  <td align=left valign=top></td>
  <td align=left valign=top>04h</td>
</tr>
<tr>
  <td align=left valign=top>Class Code</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>Revision ID</td>
  <td align=left valign=top>08h</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>BIST</td>
  <td align=left valign=top>Header Type</td>
  <td align=left valign=top>Latency Timer</td>
  <td align=left valign=top>Cache Line Size</td>
  <td align=left valign=top>0Ch</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Base Address Registers</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>10h</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>14h</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>18h</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>1Ch</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>20h</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>24h</td>
</tr>
<tr>
  <td align=left valign=top>Reserved</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>28h</td>
</tr>
<tr>
  <td align=left valign=top>Reserved</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>2Ch</td>
</tr>
<tr>
  <td align=left valign=top>Expansion ROM Base Address</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>30h</td>
</tr>
<tr>
  <td align=left valign=top>Reserved</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>34h</td>
</tr>
<tr>
  <td align=left valign=top>Reserved</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top>38h</td>
</tr>
<tr>
  <td align=left valign=top>Max_lat</td>
  <td align=left valign=top>Min_Gnt</td>
  <td align=left valign=top>Interrupt Pin</td>
  <td align=left valign=top>Interrupt Line</td>
  <td align=left valign=top>3Ch</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Tabelle 1 zeigt das Layout des von der PCI-SIG definierten
64Byte-Bereichs, das jede Karte unterst&uuml;tzen mu&szlig;. Jedem
PCI-Ger&auml;t ist es nat&uuml;rlich freigestellt, weitere
ger&auml;tespezifischen Register im nachfolgenden Bereich abzulegen.
Alle Felder, bestehend aus mehr als einem Byte, liegen dem Little
Endian (Intel)-Format zugrunde, d.h. die niederwertigere Adresse
beinhaltet auch das niederwertigere Byte. Die Treibersoftware
mu&szlig; mit bitcodierten Feldern sorgsam umgehen, da diese zumeist
reservierte Bitpositionen f&uuml;r eine etwaige sp&auml;tere
Verwendung beinhalten. Die Software mu&szlig; daher bei Lesezugriffen
Masken verwenden um die verwendeten Bits zu extrahieren, und darf sich
keinesfalls auf bestimmte Werte in reservierten Bits verlassen. Bei
Schreibzugriffen mu&szlig; die Software sicherstellen, da&szlig; die
Werte von reservierten Bits nicht ver&auml;ndert werden, d.h. ihr Wert
mu&szlig; vorher ausgelesen und zum gew&uuml;nschten Wert der anderen
Bits 'gemerged' werden. Auch dieser von der PCI-SIG vordefinierte
Bereich gliedert sich in zwei Bereiche. Der erste 16 Bytes lange
Bereich gilt f&uuml;r alle Arten von PCI-Ger&auml;ten und ist immer
gleich. Den verbleibenden 48 Bytes k&ouml;nnen in Abh&auml;ngigkeit
von der Funktion des PCI-Ger&auml;ts verschiedene Layouts zugewiesen
werden. Das Feld 'Header Type' an Adresse 0Ehex legt fest, um welches
Layout es sich in diesem zweiten Bereich handelt. Alle PCI-Ger&auml;te
m&uuml;ssen die Register f&uuml;r Vendor ID, Device ID, Command und
Status implementieren. Die Implementierung der anderen Register ist
optional und h&auml;ngt wieder einmal mehr von der Funktionalit&auml;t
des PCI-Ger&auml;ts ab. Nicht implementierte Register k&ouml;nnen vom
PCI-Ger&auml;t wie reservierte Register behandelt werden. Wenn
allerdings ein PCI-Ger&auml;t eine Funktion beinhaltet, deren
Verhalten durch eines der definierten Register festgelegt wird, so
mu&szlig; das PCI-Ger&auml;t dieses Register an der daf&uuml;r
definierten Stelle mit dem definierten Verhalten zur Verf&uuml;gung
stellen.
<br>
<br>
</p>
<p><b> Bedeutung der Konfigurations-Register: </b>
<br>
<br>
</p>
<p>Der PCI-Bus hat das Potential, die Konfiguration von Zusatzkarten
wesentlich zu vereinfachen. Dazu m&uuml;ssen aber diese
PCI-Ger&auml;te bestimmte Funktionen (&uuml;ber Register) der
Konfigurationssoftware (PCI-BIOS) zur Verf&uuml;gung stellen. Im
folgenden werden also die Register dieses vordefinierten
Konfigurations-Bereichs vorgestellt. Das exakte Format der Register
(d.h. die Anzahl der implementierten Bits usw.) h&auml;ngt wiederrum
vom jeweiligen PCI-Ger&auml;t ab. Jedoch m&uuml;ssen einige allgemeine
Regeln beachtet werden. So m&uuml;ssen alle Register die
M&ouml;glichkeit bieten, die eingestellten Werte zur&uuml;ckzulesen,
und diese gelesenen Daten m&uuml;ssen einen Wert repr&auml;sentieren,
den die Karte f&uuml;r die aktuellen Einstellungen gerade verwendet.
Die Konfigurationsregister werden zur Konfiguration, Initialisierung
und f&uuml;r die Behandlung schwerer Fehler verwendet, und sollten nur
von der Initialisierungssoftware (d.h. PCI-BIOS) und eventuellen
Fehlerbehandlungsroutinen verwendet werden. Die Ger&auml;tetreiber
selbst sollen nur Zugriffe auf I/O und/oder Memory Bereiche verwenden,
um ger&auml;tespezifische Register und damit die Funktionalit&auml;t
des PCI-Ger&auml;ts zu manipulieren.
<br>
<br>
</p>
<p><b> Die Identifikationsregister </b>
<br>
<br>
</p>
<p>F&uuml;nf Felder im vordefinierten Bereich sind f&uuml;r die
Identifikation des Ger&auml;ts vorgesehen. Alle PCI-Ger&auml;te
m&uuml;ssen diese Felder unterst&uuml;tzen. Die Konfigurationssoftware
kann somit leicht feststellen, welche Ger&auml;te am PCI-Bus des
Rechners verf&uuml;gbar sind. Alle diese Register sind 'read only'.
<br>
<br>
</p>
<p><b>Vendor ID: </b> Dieses Feld identifiziert den Hersteller des
PCI-Ger&auml;ts. G&uuml;ltige Kennungen werden von der PCI-SIG an
zahlende (!) Mitglieder vergeben, um eine Eindeutigkeit zu
gew&auml;hrleisten. Diese Herstellerkennung ist 16 Bit breit, wobei
der Wert FFFFhex eine ung&uuml;ltige Vendor ID darstellt und vom
Motherboard bei einem nicht belegten Slot zur&uuml;ckgeliefert wird.
Anhand dieses Wertes kann also das PCI-BIOS unterscheiden, ob in dem
betreffenden Slot eine Karte vorhanden ist oder nicht
<br>
<br>
</p>
<p><b> Device ID:</b> Dieses Feld identifiziert ein spezielles
Ger&auml;t. Die Kennung wird vom Hersteller der Karte selbst vergeben,
und dient zusammen mit der Vendor ID dem Softwaretreiber zum
eindeutigen Erkennen eines PCI-Ger&auml;tes. Die Funktion
FindPCIDevice eines PCI-BIOS macht von dieser M&ouml;glichkeit
Gebrauch. Ein spezielles Problem ergibt sich aber bei der Verwendung
von Standard Interface Chips wie dem PCI9060. Verwendet man
n&auml;mlich z.B. auf einer selbst gebauten Karte einen solchen
Interface Chip, so meldet sich dieser mit seiner eigenen Vendor und
Device ID und zu einer eindeutigen Erkennung und Unterscheidung
solcher Karten ist daher noch eine Subsystem Vendor ID sowie eine
Subsystem Device ID notwendig. Mit diesem Thema wird sich zu einem
sp&auml;teren Zeitpunkt ein weiterer Artikel besch&auml;ftigen.
<br>
<br>
</p>
<p><b> Revision ID:</b> Dieses Register beinhaltet eine
ger&auml;tespezifische Revisionsnummer. Der Wert selbst wird wieder
vom Hersteller der Karte vergeben, wobei auch die Revisionsnummer
00hex erlaubt ist. Dieses Feld sollte daher als herstellerspezifische
Erweiterung zur Device ID angesehen werden.
<br>
<br>
</p>
<p><b> Header Type: </b> Dieses Byte legt sowohl das Layout der
Bytes 10hex bis 3Fhex des Konfigurationsbereiches fest, als auch die
<a href="0205.htm" target="UDOcon">Information</a>, ob das Ger&auml;t weitere Funktionen beinhaltet. Bit 7
dieses Registers wird dazu verwendet, um sogenannte multi function
devices zu kennzeichnen. Ist das Bit 0, so handelt es sich bei diesem
Ger&auml;t um ein single function device, ist es hingegen gesetzt, so
hat dieses Ger&auml;t mehrere Funktionseinheiten. Bits 6..0 legen
schlie&szlig;lich das Format des zweiten Teils des
Konfigurationsbereiches fest. Das in Tabelle 1 gezeigt Layout gilt
f&uuml;r Standard-Ger&auml;te und ist mit Header Type 00hex
gekennzeichnet. Zur Zeit ist noch Header Type 01hex f&uuml;r PCI to
PCI-Bridges definiert.
<br>
<br>
</p>
<p><b> Class Code: </b> Das Class Code Register ist ebenfalls nur
'read only' und wird dazu verwendet, um die 'Gattung' (die generelle
Funktion) eines PCI-Ger&auml;tes festzulegen, sowie in einigen wenigen
F&auml;llen ein Register Interface. Das Register ist dazu in 3 Bytes
unterteilt. Das oberste Byte (an Adresse 0Bhex) stellt die Basisklasse
dar, welche die Funktion dieser Karte ganz allgemein beschreibt. Das
mittlere Byte (an Adresse 0Ahex) ist eine Subklasse, welches die in
der Basisklasse definierte Funktion genauer beschreibt. Im Falle von
Basisklasse 02hex f&uuml;r <a href="18.htm" target="UDOcon">Network</a> Controller wird hier z.B. weiter
zwischen Ethernet, Token Ring, FDDI und anderen Arten unterschieden.
Das niedrigste Byte (an Adresse 09hex) ist schlie&szlig;lich das
ger&auml;tespezifische Register Interface, &uuml;ber das
ger&auml;teunabh&auml;ngige Software mit dem Ger&auml;t kommunizieren
kann. Tabelle 2 zeigt die definierten Werte f&uuml;r die Basisklasse.
Der Class Code selbst erm&ouml;glicht &uuml;berhaupt erst die
Zusammenarbeit von ger&auml;teunabh&auml;ngiger Software mit
Standardkomponenten wie etwa einer Grafikkarte, da es eben eine
F&uuml;lle an verschiedenen Herstellern (Vendor ID) und verschiedenen
kompatiblen Grafikkarten (Device ID) gibt, die ein Treiber sonst alle
implementieren m&uuml;&szlig;te.
<br>
<br>
</p>
<p>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 35: Die Definition der Basisklassen</caption>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>PCI-Gr&auml;t wurde bereits vor der Definition der Class Codes gefertigt</td>
</tr>
<tr>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>Mass Storage controller</td>
</tr>
<tr>
  <td align=left valign=top>02h</td>
  <td align=left valign=top><a href="18.htm" target="UDOcon">Network</a> controller</td>
</tr>
<tr>
  <td align=left valign=top>03h</td>
  <td align=left valign=top>Display controller</td>
</tr>
<tr>
  <td align=left valign=top>04h</td>
  <td align=left valign=top>Multimedia device</td>
</tr>
<tr>
  <td align=left valign=top>05h</td>
  <td align=left valign=top>Memory controller</td>
</tr>
<tr>
  <td align=left valign=top>06h</td>
  <td align=left valign=top>Bridge controller</td>
</tr>
<tr>
  <td align=left valign=top>07h-FEh</td>
  <td align=left valign=top>Reserved</td>
</tr>
<tr>
  <td align=left valign=top>FFh</td>
  <td align=left valign=top>Ger&auml;t passt in keine andere Klasse</td>
</tr>
</table></div>

<p>
<br>
</p>
<p><b> Die Basisklasse 00 hex </b>
<br>
<br>
</p>
<p>Diese Basisklasse wurde definiert, um
Abw&auml;rtskompatibilit&auml;t f&uuml;r diejenigen PCI-Ger&auml;te zu
gew&auml;hrleisten, die bereits vor der Definition der Basisklassen
gebaut wurden. Neue Ger&auml;te d&uuml;rfen diesen Wert nicht mehr
verwenden, und &auml;ltere Ger&auml;te sollten soweit als m&ouml;glich
auf einen aussagekr&auml;ftigeren Wert umsteigen. F&uuml;r diese
Basisklasse existieren nur zwei Subklassen, alle anderen Werte sind
reserviert.
<br>
<br>
</p>
<p>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Alle PCI-Ger&auml;te ausser VGA-kompatible Ger&auml;te</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>VGA-kompatible Ger&auml;te</td>
</tr>
</table></div>

<p>
<br><b> Die Basisklasse 01 hex (Mass Storage controller) </b>
<br>
<br>
</p>
<p>Diese Basisklasse wurde f&uuml;r alle m&ouml;glichen
Massenspeicher-Anwendungen definiert. Bisher sind f&uuml;r diese
Ger&auml;te keinerlei Register Interfaces definiert
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>SCSI-Bus Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>IDE Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>02h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Floppy Disk Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>03h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>IPI Bus Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere Storage Controller</td>
</tr>
</table></div>

<p>
<br>
</p>
<p><b> Die Basisklasse 02 hex (<a href="18.htm" target="UDOcon">Network</a> controller </b>
<br>
<br>
</p>
<p>Diese Basisklasse wurde f&uuml;r die verschiedensten Arten an
Netzwerkkarten definiert. Auch hier gibt es bisher noch keine
definierten Register Interfaces.
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>02h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Ethernet Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Token Ring Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>02h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>FDDI Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere Netzwerk Controller</td>
</tr>
</table></div>

<p>
<br>
</p>
<p><b> Die Basisklasse 03 hex (Display controller) </b>
<br>
<br>
</p>
<p>Diese Basisklasse wurde f&uuml;r alle Arten an Grafikkarten
definiert. Dazu gibt es einige Subklassen, zu denen jeweils ein
eigenes Register Interface existiert.
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>03h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>VGA kompatibler Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>XGA Controller</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere Grafik Controller</td>
</tr>
</table></div>

<p>
<br>
</p>
<p><b> Die Basisklasse 04 hex (Multimedia device) </b>
<br>
<br>
</p>
<p>Diese Basisklasse definiert die m&ouml;glichen Typen von
Multimedia Ger&auml;ten,f&uuml;r die aber keinerlei spezifische
Register Interfaces definiert sind.
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>04h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top><a href="12.htm" target="UDOcon">Video</a></td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top><a href="1301.htm" target="UDOcon">Audio</a></td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere Multimedia Controller</td>
</tr>
</table></div>

<p>
<br>
</p>
<p><b> Die Basisklasse 05 hex (Memory controller) </b>
<br>
<br>
</p>
<p>Diese Basisklasse definiert alle m&ouml;glichen Arten an Memory
controllern. Es sind keine spezifischen Register Interfaces definiert.
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>05h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>RAM</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>FLASH</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere Memory Controller</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p><b> Die Basisklasse 06 hex (Bridge Device) </b>
<br>
<br>
</p>
<p>Diese Basisklasse definiert alle m&ouml;glichen Arten von
&quot;Bridge Devices&quot;. Eine solche PCI-Bridge ist ein
PCI-Ger&auml;t, das PCI-Ressourcen (Memory ode I/O) von der einen
Seite dieses Ger&auml;tes auf die andere Seite des Ger&auml;tes mappt.
Es gibt mehrere Subklassen und es sind keine spezifischen Register
Interfaces definiert.
<br>
<br>
<br>
<br>
</p>
<div align=center><table border=1 frame=box>
<tr>
  <td align=left valign=top>Basisklasse</td>
  <td align=left valign=top>Subklasse</td>
  <td align=left valign=top>Interface</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>06h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Host Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>ISA Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>02h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>EISA Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>03h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>MC Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>04h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>PCI to PCI Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>05h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>PCMCIA Bridge</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>80h</td>
  <td align=left valign=top>00h</td>
  <td align=left valign=top>Andere anderen Bridges</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p><b> Die Kontrollregister </b>
<br>
</p>
<p>Command:
<br>&Uuml;ber das Command Register k&ouml;nnen die verschiedenen
M&ouml;glichkeiten des PCI-Ger&auml;tes &uuml;ber einzelne Bits
freigeschalten werden, sofern das Ger&auml;t dies auch
unterst&uuml;tzt. Das Command Register stellt auch eine einfache
Kontrolle &uuml;ber das PCI-Ger&auml;t dar, ob es PCI-Cycles
generieren beziehungsweise darauf antworten darf. Schreibt man eine 0
in das Command Register, so ist dieses Ger&auml;t mit Ausnahme von
Zugriffen auf den Konfigurationsbereich logisch vom PCI-Bus getrennt.
Alle PCI-Ger&auml;te m&uuml;ssen diese Funktionalit&auml;t dem System
zur Verf&uuml;gung stellen. Die anderen Bits im Command Register
k&ouml;nnen in Abh&auml;ngigkeit der weiteren Funktionen und
M&ouml;glichkeiten der betreffenden Karte wahlweise implementiert
werden. Eine Karte, die z.B. keine I/O- Zugriffe erlaubt, wird auch
das Setzen des entsprechenden Bits im Register nicht zulassen. Die
PCI-Ger&auml;te beinhalten typisch den Wert 00hex nach dem Power up,
d.h. die Funktionen werden erst vom PCI-BIOS freigegeben (oder auch
nicht).
<br>
</p>
<p>
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 43: Bits im Command Register</caption>
<tr>
  <td align=left valign=top>Bit</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>IO Space</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t reagiert nicht auf I/O Zugriffe</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t reagiert auf I/O Zugriffe</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>Memory Space</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t reagiert nicht auf Memory Zugriffe</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t reagiert auf Memory Zugriffe</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>2</td>
  <td align=left valign=top>Bus Master</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t generiert keinerlei Zugriffe am PCI-Bus</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t darf als Busmaster auftreten</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>3</td>
  <td align=left valign=top>Special Cycles</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t ignoriert Special Cycle Operationen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t reagiert auf Special Cycle Operationen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>4</td>
  <td align=left valign=top>Memory Write and Invalidate Enable (als Busmaster)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t benutzt als Busmaster nur Memory Write Befehle</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t darf Memory Write and Invalidate verwenden.</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>5</td>
  <td align=left valign=top>VGA Palette Snooping (Bit mu&szlig; von allen VGA kompatiblen Ger&auml;ten zur Verf&uuml;gung gestellt werden)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t behandelt Paletten-Befehle wie alle anderen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t antwortet nicht auf Paletten-Befehle</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>6</td>
  <td align=left valign=top>Parity Error Response (Ger&auml;te, die auf Parity pr&uuml;fen, m&uuml;ssen dieses Bit unterst&uuml;tzen; Ger&auml;te</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>m&uuml;ssen das Parity Bit immer generieren, auch wenn die Funktion &uuml;ber dieses Bit deaktiviert ist)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t ignoriert Parity - Fehler</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t signalisiert und reagiert auf Parity - Fehler</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>7</td>
  <td align=left valign=top>Wait Cycle Control</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t arbeitet ohne Adress Data stepping</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t arbeitet mit Adress Data stepping</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>8</td>
  <td align=left valign=top>SERR# enable (Parity wird nur dann gemeldet, wenn auch dieses Bit gesetzt wurde)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t darf an Pin /SERR keinen System Error signalisieren</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t darf an Pin /SERR System Error signalisieren</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>9</td>
  <td align=left valign=top>Fast Back-to-Back Enable (legt fest, ob das PCI-Ger&auml;t als Busmaster Transaktionen zu</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>verschiedenen Targets durchf&uuml;hren darf; die Initialisierungssoftware setzt dieses Bit, wenn</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>alle Targets Fast Back-to-Back capable signalisieren)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t darf Fast Back-to-Back nicht verwenden</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t darf als Busmaster Fast Back-to-Back verwenden</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>10-15</td>
  <td align=left valign=top>reserviert</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Status:
<br>Das Status-Register wird dazu verwendet, um Informationen
bez&uuml;glich PCI Bus - relevanter Vorg&auml;nge zur Verf&uuml;gung
zu stellen. Die PCI-Ger&auml;te m&uuml;ssen wiederrum nicht alle Bits
implementieren, das h&auml;ngt wieder von der Funktionalit&auml;t der
Karte selbst ab. Wenn eine Karte z.B. als Target agiert, aber niemals
einen target abort signalisiert, wird auch dieses Bit von der Karte
nicht verwendet werden. Lesezugriffe auf diese Register verlaufen
normal, Schreibzugriffe auf dieses Register k&ouml;nnen Bits nur
l&ouml;schen, aber nicht setzen. Ein Bit in diesem Register wird
gel&ouml;scht, wenn man an der jeweiligen Position eine 1 schreibt.
Wenn man z.B. Bit 14 l&ouml;schen m&ouml;chte, ohne andere Register zu
beeintr&auml;chtigen, so schreibt man in dieses Register den Wert
4000hex. Im Gegensatz dazu kann das PCI-Ger&auml;t selbst diese Bits
nur setzen, aber nicht l&ouml;schen.
<br>
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 44: Bits im Status Register</caption>
<tr>
  <td align=left valign=top>Bit</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>0 - 6</td>
  <td align=left valign=top>reserviert</td>
</tr>
<tr>
  <td align=left valign=top>7</td>
  <td align=left valign=top>Fast Back-to-Back Capable (zeigt an, ob das PCI-Ger&auml;t als Target Fast Back-to-Back</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Transaktionen zu mehreren Targets verabeitet kann)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: keine Fast Back-to-Back Transaktionen als Target m&ouml;glich</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t versteht als Target auch Fast Back-to-Back Transaktionen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>8</td>
  <td align=left valign=top>Data Parity Detected (wird nur signalisiert, wenn ein Parit&auml;tsfehler w&auml;hrend eines</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Busmaster-Zugriffs auftritt, und durch das Command Register auch freigeschalten wurde)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: kein Parity Error bei Master Zugriff oder durch Command Register gesperrt</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Parity Error bei Master Zugriff aufgetreten</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>9 - 10</td>
  <td align=left valign=top>DEVSEL timing (ein PCI-Target zeigt an Pin /DEVSEL an, da&szlig; es einen Zugriff auf eine</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Adresse registriert hat, die sich in einem durch das Basisadre&szlig;register zugewiesenem</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Adre&szlig;bereich befindet; der Wert legt fest, zu welchem Zeitpunkt nach der Adre&szlig;phase der Pin</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>/DEVSEL von High nach Low wechselt.)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>00: schnell (nach einem PCI-Taktzyklus)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01: mittel (nach zwei PCI-Taktzyklen)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>10: langsam (nach drei PCI-Taktzyklen)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>11: reserviert</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>11</td>
  <td align=left valign=top>Signaled Target Abort (zeigt an, wenn das PCI-Ger&auml;t selbst die laufende Transaktion am</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>PCI-Bus abbricht)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: keine abgebrochene Transaktion</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t hat Transaktion mit 'Target Abort' abgebrochen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>12</td>
  <td align=left valign=top>Received Target Abort (zeigt an, wenn das PCI-Ger&auml;t als Busmaster agiert und die laufende</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Transaktion am PCI-Bus durch das Target abgebrochen wird)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: keine abgebrochene Transaktion</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Target hat Transaktion mit 'Target Abort' abgebrochen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>13</td>
  <td align=left valign=top>Received Master Abort (zeigt an, wenn das PCI-Ger&auml;t als Busmaster agiert und die laufende</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Transaktion mit Ausnahme von Special Cycle am PCI-Bus durch 'Master Abort' abgebrochen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>wird - alle Busmaster-f&auml;higen Ger&auml;te m&uuml;ssen dieses Bit implementieren)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: keine abgebrochene Transaktion</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Busmaster - Transaktion wurde durch 'Master Abort' abgebrochen</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>14</td>
  <td align=left valign=top>Signaled System Error (zeigt an, ob das Ger&auml;t an Pin /SERR einen System Error signalisiert hat)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: kein System Error</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: System Error signalisiert</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>15</td>
  <td align=left valign=top>Detected Parity Error (zeigt an, ob das Ger&auml;t einen Parity Error erkannt hat - auch wenn das</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Parity Handling durch das Command Register abgeschalten wurde)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: kein Parity Error erkannt</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Parity Error erkannt</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Verschiedene Funktionen
<br>Die nachfolgenden Register sind ger&auml;tespezifisch und
m&uuml;ssen nur von denjenigen Karten zur Verf&uuml;gung gestellt
werden, die die beschriebene Funktionalit&auml;t beinhalten. F&uuml;r
den Standardbetrieb sind diese Register nicht n&ouml;tig.
<br>
<br>
</p>
<p>Cache Line Size
<br>Dieses Register legt die Gr&ouml;&szlig;e der Cache Line in
Langworten (32 Bit) fest. Dieses Register mu&szlig; von allen
busmasterf&auml;higen Ger&auml;ten zur Verf&uuml;gung gestellt werden,
die das Kommando Write and Invalidate generieren k&ouml;nnen.
Ger&auml;te die am caching protocol beteiligt sind, verwenden dieses
Register um herauszufinden, wann Burst-Zugriffe an den Cache Grenzen
zu wiederholen sind. Wenn das Register auf 0 gesetzt ist, k&ouml;nnen
die jeweiligen Ger&auml;te die PCI Cache Leitungen /SDONE und /SBO
ignorieren. Ger&auml;te, die dieses Register zur Verf&uuml;gung
stellen, m&uuml;ssen dessen Wert bei Reset auf 0 setzen.
<br>
</p>
<p>Latency Timer
<br>Der Standardzugriff auf dem PCI-Bus ist der Burst. Ein
Einzelzugriff ist somit nichts anderes als ein nach dem ersten
Datenwort beendeter Burst. Sowohl der Master als auch der Slave
(Target) k&ouml;nnen einen Bursttransfer abbrechen. Der Busmaster
bricht dann einen Transfer ab, wenn ihm der Bus &uuml;ber /GNT
entzogen wird, und seine interne Verz&ouml;gerung (latency timer)
abgelaufen ist. Dieses Register legt den Wert des Latency Timers
f&uuml;r Busmaster fest, und mu&szlig; daher auch von allen
busmasterf&auml;higen Ger&auml;ten zur Verf&uuml;gung gestellt werden,
die mehr als zwei Datenphasen im Burst-Betrieb verarbeiten. Bei zwei
oder weniger Datenphasen im Burst-Betrieb kann dieses Register auch
als 'read-only' ausgef&uuml;hrt sein, der somit fixierte Wert sollte
allerdings kleiner gleich 16 (bus clocks) sein. Eine durchaus
verbreitete Implementierung sieht z.B. die untersten 3 Bits als
'read-only' vor, w&auml;hrend die oberen 5 Bits beliebig
ver&auml;ndert werden k&ouml;nnen. Dadurch ergibt sich eine
Aufl&ouml;sung des Latency Timers von 8 bus clocks. Ist dieses
Register allerdings nicht als reines 'read only'-Register
ausgef&uuml;hrt, mu&szlig; das PCI-Ger&auml;t dessen Wert bei Reset
auf 0 setzen.
<br>
<br>
</p>
<p>Built-in Self Test (BIST)
<br>Dieses optionale Register dient zur Steuerung eines auf der
PCI-Karte implementierten Eigentests, sofern dieser &uuml;berhaupt
vorhanden ist. PCI-Ger&auml;te die keinen Selbsttest zur
Verf&uuml;gung stellen, liefern in diesem Register den Wert 0
zur&uuml;ck. Ein Ger&auml;t, dessen Selbsttest gestartet wurde, darf
den Normalbetrieb des PCI-Busses in keinster Weise
beeintr&auml;chtigen.
<br>
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 45: Bits im BIST Register</caption>
<tr>
  <td align=left valign=top>Bit</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>7</td>
  <td align=left valign=top>BIST capable</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0: Ger&auml;t unterst&uuml;tzt keinen Selbsttest</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Ger&auml;t stellt einen eingebauten Selbsttest zur Verf&uuml;gung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>6</td>
  <td align=left valign=top>Start BIST</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1: Selbsttest starten. Nach Beendigung des Tests wird dieses Bit vom PCI-Ger&auml;t wieder auf 0</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>gesetzt. Trifft dies auch nach dem Ablauf von 2 Sekunden nicht zu, so ist diese Karte als</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>defekt einzustufen.</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>5 - 4</td>
  <td align=left valign=top>reserviert</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>3 - 0</td>
  <td align=left valign=top>Completion code</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0000: PCI-Ger&auml;t hat den Selbsttest bestanden.</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>Alle von 0000 verschiedenen Werte stellen ger&auml;tespezifische Fehlercodes dar.</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Interrupt Line:
<br>Dieses 8-bit breite Register wird vom Hostsystem dazu verwendet,
die <a href="0205.htm" target="UDOcon">Information</a> &uuml;ber den dem Ger&auml;t zugeteilten
Hardware-Interrupt allgemein zur Verf&uuml;gung zu stellen. Der Wert
in diesem Register zeigt an, welcher Eingang des Interruptcontrollers
mit dem Interrupt-Pin des PCI-Ger&auml;tes verbunden ist. Sowohl
Ger&auml;tetreiber als auch das <a href="0901.htm" target="UDOcon">Betriebssystem</a> selbst k&ouml;nnen
diese <a href="0205.htm" target="UDOcon">Information</a> dazu benutzen, um Interruptpriorit&auml;ten und
Vektorinformationen zu ermitteln. Die Werte in diesem Register
h&auml;ngen von der jeweilig verwendeten Systemarchitektur ab. Der
Wert FFhex wird dann verwendet, wenn keine Zuordnung zum Interrupt
Controller ermittelt werden konnte, oder wenn keine Verbindung zu
diesem besteht. Vom PCI-Ger&auml;t selbst wird dieses Register nicht
weiter beachtet.
<br>
</p>
<p>Interrupt Pin:
<br>Das Interrupt Pin Register kann nur gelesen werden. &Uuml;ber
dieses Register teilt das PCI-Ger&auml;t dem Hostsystem mit, welche
Interruptleitung des PCI-Busses es benutzt. PCI-Ger&auml;te, die keine
Interrupts generieren, m&uuml;ssen dieses Register auf 0 setzen.
(!nl!)
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 46: Interrupt Pin Register</caption>
<tr>
  <td align=left valign=top>Wert</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>PCI-Ger&auml;t generiert keine Interrupts</td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>PCI-Ger&auml;t verwendet Interrupt Pin /INTA</td>
</tr>
<tr>
  <td align=left valign=top>2</td>
  <td align=left valign=top>PCI-Ger&auml;t verwendet Interrupt Pin /INTB</td>
</tr>
<tr>
  <td align=left valign=top>3</td>
  <td align=left valign=top>PCI-Ger&auml;t verwendet Interrupt Pin /INTC</td>
</tr>
<tr>
  <td align=left valign=top>4</td>
  <td align=left valign=top>PCI-Ger&auml;t verwendet Interrupt Pin /INTD</td>
</tr>
<tr>
  <td align=left valign=top>5-255</td>
  <td align=left valign=top>reserviert</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>MIN_GNT und MAX_LAT
<br>Diese beiden 'read only' Register legen die Grenzwerte f&uuml;r
das Setzen des Latency Timers (nur f&uuml;r den Busmaster-Betrieb
n&ouml;tig) fest. Beide Register haben hierbei eine Aufl&ouml;sung von
0,25 Mikrosekunden. Ein Wert von 0 zeigt an, da&szlig; dieses
PCI-Ger&auml;t keine speziellen Anforderungen an die Konfiguration des
Latency Timers stellt. MIN_GNT zeigt an, wie lange das PCI-Ger&auml;t
f&uuml;r eine einzige Burst-Periode (nur eine Datenphase) in Bezug auf
eine PCI-Taktrate von 33 MHz mindestens ben&ouml;tigt. Dem
PCI-Ger&auml;t (als Busmaster) sollte also f&uuml;r mindestens diese
Zeit der Bus durch den Bus Arbiter zugeteilt werden. MAX_LAT
definiert, f&uuml;r wie lange das PCI-Ger&auml;t als Busmaster Zugriff
auf den PCI-Bus erwirken m&ouml;chte. Aus beiden Werten kann man dann
einen geeigneten Wert f&uuml;r das Latency Timer Register w&auml;hlen.
Der Busmaster gibt den Bus ja erst dann zur&uuml;ck, wenn ihm der Bus
Arbiter den PCI-Bus &uuml;ber /GNT entzieht, und der eigene latency
timer abgelaufen ist. Ein Master darf sich aber nicht durch
st&auml;ndiges Aktivieren der /REQ-Leitung den Bus auf Dauer sichern,
sondern nur f&uuml;r den aktuellen Zugriff benutzen. Der Algorithmus
zur Arbitrierung ist in der PCI-Spezifikation allerdings nicht
festgelegt. Die PCI-Ger&auml;te sollten daher auch solche Werte
angeben, die eine effektive Verwendung sowohl des PCI-Busses als auch
ihrer eigenen internen Ressourcen erm&ouml;glichen. (!nl!)
</p>
<p>Basis-Addressen:
<br>Die Basisadressen sind eine der wichtigsten Funktionen, um eine
einfache Konfiguration und Einbindung von PCI-Ger&auml;ten in das
Rechnersystem zu gew&auml;hrleisten. Die sechs
Basisadre&szlig;register enthalten die in der Initialisierungsphase
(vom PCI-BIOS) vergebenen Adressen zum Zugriff auf die einzelnen
Adre&szlig;r&auml;ume des PCI-Ger&auml;tes. Bit 0 in diesen
Adre&szlig;registern kann nur gelesen werden und zeigt an, ob der
Adre&szlig;raum im Memory-Bereich oder im I/O-Bereich liegt.
<br>
</p>
<p>Memory-Bereiche: (!nl!) Register, die einen Memory-Bereich
anfordern, m&uuml;ssen Bit 0 auf den Wert 0 setzen. Die Register
selbst sind dabei entweder 32 bit oder aber auch 64 bit breit. Zur
Auskodierung der Basisadresse verwendet das PCI-Ger&auml;t allerdings
nur Bit 4 bis Bit 31 bzw. Bit63, d.h. Memory-Bereiche beginnen stets
an 16 Byte - Grenzen. Die anderen Bits sind 'read only'. In Bit 3 des
Registers wird mitgeteilt, ob der Adressbereich 'prefetchable' ist,
und in Bit 2 und Bit 1 steht die gew&uuml;nschte Art des Memory
mappings in der Initialisierungsphase
<br>
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 47: Adre&szlig;register f&uuml;r Memory-Bereiche</caption>
<tr>
  <td align=left valign=top>Bit</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>31(63)..4</td>
  <td align=left valign=top>Memory-Basisadresse (32 oder 64 bit breit)</td>
</tr>
<tr>
  <td align=left valign=top>3</td>
  <td align=left valign=top>Prefetchable</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>2 - 1</td>
  <td align=left valign=top>Type (Gr&ouml;&szlig;e des Registers 32/64 bit, sowie gew&uuml;nschter Adre&szlig;raum)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>00: 32 bit breit, beliebig im 32 bit Adre&szlig;raum</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>01: 32 bit breit, Adre&szlig;raum unterhalb 1 MB</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>10: 64 bit breit, beliebig im 64 bit Adre&szlig;raum</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>11: reserviert</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>Memory Space Indicator = 0</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>I/O-Bereiche:
<br>Register, die einen I/O-Bereich anfordern, sind immer 32 Bit breit
und m&uuml;ssen in Bit 0 den Wert 1 zur&uuml;ckliefern. Bit 1 ist
reserviert (read only) und mu&szlig; immer gel&ouml;scht sein, alle
anderen Bits (Bit 2 bis Bit 31) beschreiben schlie&szlig;lich die
Adresse im I/O-Bereich, d.h. diese Bereiche beginnen stets an 4 Byte -
Grenzen.
<br>
<br>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 48: Adre&szlig;register f&uuml;r IO-Bereiche</caption>
<tr>
  <td align=left valign=top>Bit</td>
  <td align=left valign=top>Bedeutung</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>31..2</td>
  <td align=left valign=top>I/O-Basisadresse</td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>reserviert (immer 0)</td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>IO Space Indicator = 1</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Insgesamt ist im Konfigurationsbereich Platz f&uuml;r sechs
Adre&szlig;register. Das erste Adre&szlig;register beginnt immer an
Offset 10hex. Die Lage des zweiten Adre&szlig;registers h&auml;ngt
dann allerdings von der Gr&ouml;&szlig;e (32/64 Bit) des ersten
Registers ab, und beginnt demnach an Offset 14hex bzw. 18hex.
Grafikkarten fordern typischerweise einen I/O-Bereich f&uuml;r die
Kontrollregister und einen Memory-Bereich f&uuml;r den Grafikspeicher
an. Wenn ein PCI-Ger&auml;t seine Kontrollregister in den Memory- und
in den I/O-Bereich legen will, mu&szlig; es daf&uuml;r auch zwei
Adre&szlig;register 'spendieren'. Grunds&auml;tzlich sollten es alle
PCI-Ger&auml;te erm&ouml;glichen, Kontrollregister in den
Memory-Bereich zu mappen. Das ist aus der Unzul&auml;nglichkeit der
PC's entstanden, die einen viel zu kleinen I/O-Bereich besitzen.
<br>
</p>
<p>Anforderung von Adre&szlig;r&auml;umen
<br>Um nun zu bestimmen, wieviel Speicher das jeweilige Ger&auml;t
mittels der Adre&szlig;register anfordert, beschreibt das Hostsystem
jedes Adre&szlig;register mit dem Wert FFFF'FFFFhex und liest danach
das Register wieder zur&uuml;ck. Das PCI-Ger&auml;t liefert an jenen
Bitpositionen 0 zur&uuml;ck, die es zur Auskodierung des
gew&uuml;nschten Speicherbereichs verwendet. Fordert das Ger&auml;t
z.B. einen 1MB gro&szlig;en Memory-Bereich im 32-bit Adre&szlig;raum
und einen 256 Byte gro&szlig;en I/O-Bereich an, so findet man nach dem
Beschreiben mit FFFF'FFFFhex in einem Adre&szlig;register FFF0'0000hex
f&uuml;r den Memory-Bereich und in dem anderen FFFF'FF01hex f&uuml;r
den I/O-Bereich vor. Das Hostsystem kann danach die Basisadressen
f&uuml;r die jeweiligen PCI-Ger&auml;te vergeben. Ab diesem Zeitpunkt
dekodieren die PCI-Ger&auml;te die Zugriffe dann selbst aus. Die
Vergabe der Adre&szlig;r&auml;ume beim Booten des Rechnersystems ist
Aufgabe eines PCI-BIOS. Damit w&auml;ren nun die wichtigsten Register
vorgestellt und in der n&auml;chsten Folge k&ouml;nnen wir uns dann
endlich mit der Definition und den Aufgaben eines ATARI PCI-BIOS
besch&auml;ftigen. Die bereits in der ersten Folge bechriebene
M&ouml;glichkeit von Erweiterungs-ROMs auf den Karten werden zu einem
sp&auml;teren Zeitpunkt behandelt. (!nl!
</p>
<p>Milan-Homepage: http://www.milan-computer.de
<br>Milan-Newsletter bestellen/abbestellen:
http://www.milan-computer.de/html_d/letter.html
<br>
</p>
<p>Letzte &Auml;nderung am 08. JuLi 1998, 13:07
<br>
</p>
<p>
<br>
<br>
</p>
<p><b> Sonder-Edition PCI-BIOS, Part3 Stand: 09. 07. 1998 </b>
<br>
</p>
<p>
<br>
</p>
<p><b> Das PCI-BIOS 3 </b>
<br>
<br>
</p>
<p>Die Idee
<br>
<br>
</p>
<p>Die Idee zum PCI-BIOS f&uuml;r die ATARI-kompatiblen Rechner
entstand aus der Notwendigkeit der Zuordnung von Speicherbereichen zu
den I/O- und Memory-Bereichen der PCI-Ger&auml;te. Auf PC's und
Kompatiblen wird die PCI-Funktionalit&auml;t &uuml;ber eine
Bios-Erweiterung (das PCI-BIOS) standardisiert zur Verf&uuml;gung
gestellt. Das Bios hat zwei wesentliche Aufgaben. Zum einen die
Bereitstellung einer Schnittstelle f&uuml;r die Software f&uuml;r den
Zugriff auf die PCI-Ger&auml;te, zum anderen die Initialisierung und
die Verteilung der Resourcen der einzelnen PCI-Ger&auml;te. Die
Initialisierung l&auml;uft ohne Eingriffsm&ouml;glichkeiten des
Benutzers direkt nach dem Reset ab.
<br>
<br>
</p>
<p><b> Der Bootvorgang </b>
<br>
<br>
</p>
<p>Nach dem Reset fragt das Hostsystem zuerst das Vorhandensein der
installierten PCI-Ger&auml;te ab. Dies erfolgt durch den Zugriff auf
ein definiertes Register (Vendor ID). Zu diesem Zeitpunkt sind
Zugriffe auf die noch unbekannten Karten nur mit den Befehlen
Configuration Read und Configuration Write m&ouml;glich. Nachdem das
System herausbekommen hat, ob und wo Karten im Rechner stecken, werden
bei allen PCI-Ger&auml;ten die ben&ouml;tigten Adre&szlig;r&auml;ume
ermittelt. Dies geschieht wie bereits erw&auml;hnt durch das Schreiben
des Wertes FFFF'FFFFhex in das jeweilige Adre&szlig;register. Jedes
PCI-Ger&auml;t kann maximal 6 Speicherbereiche anfordern. Dabei wird
der jeweils ben&ouml;tigte Adre&szlig;bereich im Adre&szlig;register
bitweise ausmaskiert. Werden zur Kodierung zum Beispiel Bit 0 bis Bit
9 verwendet (auskodieren mit FFFF'FC00hex), ist der Bereich 2^10, also
1024 Bytes gro&szlig;. Es besteht die Wahl zwischen I/O-gemappten und
Memory-gemappten Bereichen (siehe Artikel in Ausgabe 5/98). F&uuml;r
ein PCI-Ger&auml;t unterscheiden sich die beiden Bereiche nur durch
die unterschiedlichen Kommandos an /C/BE[0..3]. Als Antwort teilt das
Hostsystem (BIOS) den einzelnen Ger&auml;ten jeweils
Adre&szlig;bereiche zu - sofern im Adre&szlig;raum genug Platz
vorhanden ist. Hier hat z.B. der Hades im Vergleich zum PC einiges
mehr zu bieten, da im PC der I/O-Bereich sehr begrenzt ist. Der Hades
bietet in unserem Fall 256 MB I/O-Bereich und 512 MB Memory-Bereich
an. Das sollte f&uuml;r den Anfang wirklich gen&uuml;gen ;-) Nach der
Anmeldung sind die PCI-Ger&auml;te dann selbst f&uuml;r die
Auskodierung ihrer Adre&szlig;r&auml;ume verantwortlich. Die
zugeteilten Adre&szlig;r&auml;ume lassen sich f&uuml;r die
sp&auml;teren Zugriffe auf I/O- und Memory-Bereich aus den
Konfigurationsregistern der Ger&auml;te auch wieder auslesen. In einem
Register des definierten Konfigurationsbereiches (Interrupt Pin) wird
von jedem PCI-Ger&auml;t die jeweils benutzte Interrupt-Leitung
mitgeteilt. Das BIOS vergibt daraufhin einen der vorhandenen
Interrupts und stellt die weitere Funktionalit&auml;t &uuml;ber
BIOS-Routinen zur Verf&uuml;gung.
<br>
<br>
</p>
<p><b> Wie sag' ich's meiner PCI-Karte </b>
<br>
<br>
</p>
<p>Der Treiber einer installierten PCI-Hardware durchl&auml;uft
demnach folgende Schritte f&uuml;r die Initialisierung und
anschlie&szlig;ende Verwendung eines PCI-Boards:
<br>
</p>
<dl>
<dt><b>*</b></dt><dd> Test auf vorhandenes PCI-BIOS und dessen Versionsnummer
<br>
<br>&nbsp;
<dt><b>*</b></dt><dd> PCI-Karte mit den Routinen find_pci_device oder
find_pci_classcode suchen die Karte mu&szlig; dann
ausschlie&szlig;lich &uuml;ber das vom PCI-BIOS vergebene
Ger&auml;te-Handle angesprochen werden.
<br>&nbsp;
<dt><b>*</b></dt><dd> entweder werden &uuml;ber get_resource die notwendigen
Informationen f&uuml;r den direkten Zugriff auf die jeweiligen
Speicherbereiche ausgelesen (der Treiber mu&szlig; hierbei eventuelle
Offsets, das Byte Ordering usw. selbst ber&uuml;cksichtigen), oder
aber man verwendet die vom PCI-BIOS zur Verf&uuml;gung gestellten
Lese- und Schreib- Routinen f&uuml;r Memory und I/O- Bereiche
<br>&nbsp;
<dt><b>*</b></dt><dd> eventuell weitere kartenspezifische Informationen auslesen und
entsprechend darauf reagieren
<br>&nbsp;
<dt><b>*</b></dt><dd> Karte schlie&szlig;lich &uuml;ber die Register in I/O- bzw.
Memory-Bereich ansteuern Der weitere Zugriff auf die angeschlossenen
PCI-Ger&auml;te nach der Initialisierung und Konfiguration erfolgt
also &uuml;ber Memory- und/oder I/O- Zugriffe auf die entsprechend
zugeteilten Adre&szlig;bereiche. F&uuml;r diesen Zugriff w&auml;re
zwar kein spezielles Bios mehr erforderlich, aber das PCI-BIOS bietet
aber eben auch hier eine einfache Zugriffsm&ouml;glichkeit auf diese
Speicherbereiche/Register eines PCI-Ger&auml;tes, ohne sich um etwaige
Offsets und Byte Orderings (Intel/Motorola) k&uuml;mmern zu
m&uuml;ssen.
<br>&nbsp;
</dl>
<p>
<br>
</p>
<p><b> Die PCI-Funktionen </b>
<br>
<br>
</p>
<p>Im folgenden wird also das Software-Interface beschrieben, das von
den PCI-Ger&auml;tetreibern und anderer <a href="15.htm" target="UDOcon">Systemsoftware</a> genutzt werden
kann, um Zugriff auf die PCI-Karten in ATARI-kompatiblen Systemen zu
erhalten. Dieser Artikel soll zun&auml;chst das Konzept und die
prinzipiellen M&ouml;glichkeiten aufzeigen, daher werden f&uuml;rs
Erste auch nicht s&auml;mtliche vom PCI-BIOS zur Verf&uuml;gung
gestellten Routinen beschrieben. Die restliche Funktionalit&auml;t und
weitere Einzelheiten k&ouml;nnen in der jeweils aktuellen Ausgabe der
ATARI PCI BIOS Specification nachgelesen werden. Aller Vorraussicht
nach wird man diese in naher Zukunft unter
http://www.milan-computer.de finden. Das PCI-Bios installiert einen
&quot;_PCI&quot;-Cookie, &uuml;ber den die BIOS-Routinen lokalisiert
und angesprochen werden k&ouml;nnen. F&uuml;r Programmierer gibt es
hierf&uuml;r bereits eine PCI-Library, die diese Aufgaben erledigt,
und damit einen sehr einfachen Zugriff erlaubt. Die jeweils aktuellen
Versionen des PCI-BIOS f&uuml;r den Hades und die entsprechende
PCI-Library sind unter http://www.wvnet.at/privat/97021702/ zu finden.
Weiters gibt es an dieser Stelle auch ein C-Beispielprogramm zur
Verwendung dieser Library. Sobald die allgemein g&uuml;ltige ATARI PCI
BIOS Specification im <a href="17.htm" target="UDOcon">Internet</a> erh&auml;ltlich ist, wird es hier auch
einen Link darauf geben. Beim Milan werden die BIOS-Routinen in einer
der n&auml;chsten Versionen des Milan-TOS fix integriert sein, ein
entsprechendes Programm im AUTO-Ordner ist im Gegensatz zum Hades also
dann nicht mehr n&ouml;tig. Ob und wann dies eventuell auch beim Hades
der Fall sein wird, kann zu diesem Zeitpunkt noch nicht gesagt werden.
<br>Jedem PCI-Ger&auml;t wird vom PCI-Bios eine Ger&auml;te-Handle
zugewiesen, mit dem diese Ger&auml;te dann angesprochen werden
k&ouml;nnen. R&uuml;ckschl&uuml;sse vom Ger&auml;te-Handle auf den
betreffenden PCI-Slot sind nicht m&ouml;glich, und auch nicht
erw&uuml;nscht. Im folgenden werden jeweils die Aufrufe in Assembler
und C dargestellt, die Informationen zu den verwendeten Parametern
erg&auml;nzen sich gegenseitig. S&auml;mtliche PCI-BIOS Routinen
m&uuml;ssen im Supervisor-Modus aufgerufen werden.
<br>
<br>
</p>
<p><b> Die PCI-BIOS Fehlercodes </b>
<br>
<br>
</p>
<p>Die folgende Fehlercodes k&ouml;nnen im Fehlerfall von den
BIOS-Routinen zur&uuml;ckgeliefert werden.
<br>
</p>
<p>Tabelle 1: Fehlercodes der BIOS-Routinen
<br>
</p>
<p>Die folgenden beiden Fehlercodes werden zwar nicht von den
BIOS-Routinen selbst verwendet, sind aber f&uuml;r eine PCI-Library
reserviert.
<br>
</p>
<p>Tabelle 2: Fehlercodes der PCI-Library
<br>
</p>
<p>
<br>
</p>
<p><b> Find PCI device </b>
<br>
<br>
</p>
<p>Diese Funktion dient dazu, ein bestimmtes PCI-Ger&auml;t (eine
PCI-Karte selbst kann ja wiederrum mehrere Funktionseinheiten =
Ger&auml;te beherbergen) &uuml;ber Device und Vendor ID zu suchen.
Damit findet ein Softwaretreiber also seine zugeh&ouml;rige Hardware,
sofern sie auch im Rechner installiert wurde. Sollte eine Hardware
mehrfach im System vorhanden sein, oder sich zwei Karten mit den
gleichen IDs melden, so werden die einzelnen Karten &uuml;ber ihren
Index abgefragt. Man beginnt dabei mit Index 0 und erh&ouml;ht ihn
dann solange, bis die Routine den Fehlercode PCI_DEVICE_NOT_FOUND
zur&uuml;ckliefert.
<br>
<br>Aufruf in Assembler:
<br>
</p>
<p>Eingang:
<br>
</p>
<p>D0.L Device ID in den Bits 31..16 (0 - $FFFF), Vendor ID in den
Bits 15..0 (0 - $FFFE)
<br>D1.W Index (0 bis Anzahl der PCI-Ger&auml;te mit dieser ID)
<br>
<br>Ausgang:(!nl)
</p>
<p>D0.L Ger&auml;te-Handle oder PCI-BIOS Fehlercode
<br>
<br>Aufruf in C:
<br>
</p>
<p>LONG handle = find_pci_device (ULONG id, UWORD index)
<br>
<br>id: Device und Vendor ID des PCI-Ger&auml;tes
<br>
<br>index: Index (bei mehreren gleichen Ger&auml;ten)
<br>Returnwert: positiv - Ger&auml;te-Handle
<br>
<br>negativ - PCI-BIOS Fehlercode
<br>
<br>
<br><b> Sonderfall: </b>
<br>
<br>mit Vendor ID FFFFhex kann man s&auml;mtliche im System vorhandene
PCI-Ger&auml;te suchen, die Device ID wird in diesem Fall ignoriert.
<br>
<br>
</p>
<p><b> Find PCI Classcode </b>
<br>
<br>Diese Funktion dient dazu, ein bestimmtes PCI-Ger&auml;t &uuml;ber
ihren Classcode zu suchen. Mit dieser Funktion ist es z.B.
m&ouml;glich, die Grafikkarte zu erreichen, ohne den Hersteller oder
die Device ID zu wissen. Diese Funktion f&uuml;hrt nat&uuml;rlich nur
dann zum Erfolg, wenn das PCI-Ger&auml;t auch einen der festgelegten
Class Codes benutzt. Gibt es mehrere PCI-Ger&auml;te mit dem gleichen
Classcode, so kann der Ger&auml;te-Treiber die weiteren Karten
&uuml;ber ihren Index abfragen. Man beginnt dabei mit Index 0 an und
erh&ouml;ht ihn dann solange, bis die Routine den Fehlercode
PCI_DEVICE_NOT_FOUND zur&uuml;ckliefert.
<br>
<br>Aufruf in Assembler:
<br>
</p>
<p>Eingang:
<br>D0.L Classcode:
<br>Bit 23..16 Base class (0 - $FF),
<br>Bit 15..8 Sub class (0 - $FF),
<br>Bit 7..0 Programming Interface (0)
<br>
<br>
</p>
<p>Flags:
<br>
</p>
<p>Bit 26 Base class 0:vergleichen 1:ignorieren
<br>
</p>
<p>Bit 25 Sub class 0:vergleichen 1:ignorieren
<br>
</p>
<p>Bit 24 Progr. interface: 0:vergleichen 1:ignorieren
<br>
<br>
</p>
<p>Mit den Bits 24..26 kann man also angeben, welche Teile des
Classcodes
<br>mit den gefundenen PCI-Ger&auml;ten &uuml;bereinstimmen
m&uuml;ssen
<br>D1.W Index (0 - Anzahl der PCI-Ger&auml;te mit diesem Classcode)
<br>
<br>Ausgang:
<br>
<br>D0.L Ger&auml;te-Handle oder PCI-BIOS Fehlercode
<br>
<br>Aufruf in C:
<br>
<br>
</p>
<p>LONG handle = find_pci_classcode (ULONG class, UWORD
index)&amp;nbsp;
<br>
</p>
<p>class: Classcode des PCI-Ger&auml;tes
<br>index: Index (bei mehreren gleichen Ger&auml;ten)
<br>Returnwert: positiv - Ger&auml;te-Handle
<br>negativ - PCI-BIOS Fehlercode
<br>Read Configuration {Byte|Word|Longword}
<br>
<br>
</p>
<p>Diese drei Funktionen erlauben Lesezugriffe auf die
Konfigurationsregister eines PCI-Ger&auml;tes, dessen
Ger&auml;te-Handle zuvor mittels find_pci_device oder
find_pci_classcode ermittelt wurde.
<br>
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>
</p>
<p>Eingang:
<br>
<br>
</p>
<p>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>A0.L Zeiger auf Ergebnisvariable
<br>D1.B Adresse des Konfigurationsregisters (0,1,2,... f&uuml;r
Byte-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,2,4,... f&uuml;r
Wort-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,4,8,... f&uuml;r
Langwort-Zugriffe)
<br>
<br>
</p>
<p>Ausgang:
<br>
</p>
<p>D0.L PCI-BIOS Fehlercode
<br>gelesene Daten stehen nach dem Aufruf in der Ergebnisvariable
<br>
<br>Aufruf in C:
<br>
</p>
<p>LONG errorcode = read_config_byte (LONG handle, UBYTE reg, UBYTE
*adresse)
<br>LONG errorcode = read_config_word (LONG handle, UBYTE reg, UWORD
*adresse)
<br>LONG errorcode = read_config_longword (LONG handle, UBYTE reg,
ULONG *adresse)
<br>handle: Ger&auml;te-Handle des gew&auml;hlten PCI-Ger&auml;tes
<br>reg: Adresse des Konfigurationsregisters
<br>adresse: Zeiger auf Ergebnisvariable
<br>Returnwert: PCI-BIOS Fehlercode
<br>Read Configuration {Byte|Word|Longword} FAST
<br>
<br>
</p>
<p>Diese drei Funktionen erlauben das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
</p>
<p>Plausibilit&auml;tschecks und sind daher auch etwas schneller als
ihre 3 Schwestern (daher besonders geeignet f&uuml;r
Interrupt-Routinen und wenn man ganz genau wei&szlig;, was man tut
;-). Der Registerinhalt wird im Returnwert abgelegt. Dadurch
k&ouml;nnen diese Funktionen in C-Programmen noch einfacher angewendet
werden.
<br>
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>Eingang:
<br>
</p>
<p>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>D1.B Adresse des Konfigurationsregisters (0,1,2,... f&uuml;r
Byte-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,2,4,... f&uuml;r
Wort-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,4,8,... f&uuml;r
Langwort-Zugriffe)
<br>
<br>
</p>
<p>Ausgang:
<br>
</p>
<p>D0 gelesener Wert (8, 16 oder 32 Bits)
<br>SR carry flag wird bei einem Fehler gesetzt (abh&auml;ngig von der
Implementation)
<br>
<br>Aufruf in C:
<br>
</p>
<p>UBYTE value = fast_read_config_byte (LONG handle, UBYTE reg)
<br>UWORD value = fast_read_config_word (LONG handle, UBYTE reg)
<br>ULONG value = fast_read_config_longword (LONG handle, UBYTE reg)
<br>handle: Ger&auml;te-Handle des gew&auml;hlten PCI-Ger&auml;tes
<br>reg: Adresse des Konfigurationsregisters
<br>Returnwert: Inhalt des Konfigurationsregisters
<br>
<br>
</p>
<p>Beispiele:
<br>
<br>
</p>
<p>1) device_vendor = fast_read_config_longword (handle, 0)
<br>liefert in den Bits 0-15 die Vendor ID und in den Bits 16-31 die
Device ID
<br>
<br>2) vendor = fast_read_config_word (handle, 0); liefert die Vendor
ID zur&uuml;ck
<br>
<br>3) device = fast_read_config_word (handle, 2); liefert die Device
ID zur&uuml;ck
<br>
<br>4) timer = fast_read_config_byte (handle, 13); liefert
schlie&szlig;lichen den Wert des Latency Timers
<br>
<br>Write Configuration {Byte|Word|Longword}
<br>
<br>Diese drei Routinen dienen zum Schreiben von
Konfigurationsregistern eines PCI-Ger&auml;tes.
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>Eingang:
<br>
<br>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>D1.B Adresse des Konfigurationsregisters (0,1,2,... f&uuml;r
Byte-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,2,4,... f&uuml;r
Wort-Zugriffe)
<br>D1.B Adresse des Konfigurationsregisters (0,4,8,... f&uuml;r
Langwort-Zugriffe)
<br>D2 zu schreibender Registerwert (8/16/32 bits)
<br>
<br>Ausgang:
<br>
<br>D0.L PCI-BIOS Fehlercode
<br>
<br>Aufruf in C:(!nl)
<br>
</p>
<p>LONG errorcode = write_config_byte (LONG handle, UBYTE reg, UBYTE
val)
<br>LONG errorcode = write_config_word (LONG handle, UBYTE reg, UWORD
val)
<br>LONG errorcode = write_config_longword (LONG handle, UBYTE reg,
ULONG val)
<br>
<br>handle: Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>reg: Adresse des Konfigurationsregisters
<br>val: zu schreibender Registerwert
<br>Returnwert: PCI-BIOS Fehlercode
<br>
<br>Was passiert nun bei einem Interrupt?
<br>
<br>F&uuml;r jeden PCI-Interrupt kann es eine ganze Kette von
Interrupt-Handlern geben, da sich ja auch mehrere PCI-Ger&auml;te den
selben Interrupt teilen k&ouml;nnen (siehe auch Artikel in der Ausgabe
4/98). &amp;Uuml;ber das Ger&auml;te-Handle kann nun ein
Ger&auml;te-Treiber seinen eigenen Interrupt-Handler per
hook_interrupt in die passende Kette eintragen lassen, ohne den
daf&uuml;r zust&auml;ndigen Interrupt wissen zu m&uuml;ssen.
<br>Tritt danach ein Interrupt auf, werden vom BIOS die in die Kette
eingetragenen Handler der Reihe nach aufgerufen. Jeder
Interrupt-Handler wird dabei mit jenem Parameter aufgerufen, der beim
Aufruf von hook_interrupt spezifiziert wurde. Dieser Parameter ist vom
Ger&auml;te-Treiber v&ouml;llig frei w&auml;hlbar, bei geeigneter Wahl
k&ouml;nnte man mit einem einzigen Treiber auch mehrere (baugleiche)
Ger&auml;te parallel bedienen. Die Interrupt-Handler m&uuml;ssen
unmittelbar nach ihrem Aufruf pr&uuml;fen, ob der Interrupt von der
von ihnen betreuten Karte ausgel&ouml;st wurde, und dementsprechend
reagieren. Das hei&szlig;t, die Interruptursache ist zu beheben, und
das entsprechende Bit des BIOS-internen Parameters ist zu setzen. Hat
das entsprechende Ger&auml;t den Interrupt nicht ausgel&ouml;st, darf
der Interrupt-Handler den BIOS-internen Parameter unter keinen
Umst&auml;nden ver&auml;ndern! Der Handler selbst ist als
gew&ouml;hnliche Prozedur zu betrachten, d.h. auch in Assembler wird
der Interrupt-Handler mit RTS abgeschlossen.
<br>
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>Eingang:
<br>
<br>A0.L Parameter, der mittels hook_interrupt spezifiziert wurde
(!nl)(!nl) D0.L BIOS-interner Parameter
<br>
<br>Ausgang:
<br>
<br>D0.L Bit 0 wird gesetzt, wenn der Interrupt von der betreuten
PCI-Karte ausgel&ouml;st wurde, anderenfalls darf dieser Parameter
nicht ge&auml;ndert werden
<br>
<br>Aufruf in C:
<br>
<br>
</p>
<p>LONG value = interrupt_handler (LONG *value, LONG internal)
<br>value: Parameter, der mittels hook_interrupt spezifiziert wurde
<br>internal: BIOS-interner Parameter
<br>Returnwert: BIOS-interner Parameter
<br>Hook Interrupt Vector
<br>
<br>
<br>H&auml;ngt den Interrupt-Handler des Treibers in die Kette des
entsprechenden Interrupt-Kanals. War vorher noch kein Handler in der
Kette, wird auch der betreffende PCI-Interrupt im Hostsystem
aktiviert. Nach Auftreten des jeweiligen Interrupts wird somit der
angegebene Interrupt-Handler aufgerufen. Allerdings ist insbesondere
darauf zu achten, da&szlig; die Interrupts auf dem PCI-Ger&auml;t erst
nach dem Aufruf dieser Funktion aktiviert werden d&uuml;rfen, da es
sonst zu spurious interrupts kommen kann. Ist f&uuml;r das
gew&auml;hlte PCI-Ger&auml;t bereits ein Interrupt-Handler angemeldet,
so erh&auml;lt man einen entsprechenden PCI-BIOS Fehlercode. Es ist
dringend davon abzuraten, per unhook_interrupt fremde Handler zu
entfernen. F&uuml;r diesen Zweck gibt es die Funktion get_card_used,
&uuml;ber die eine Callback-Routine des fremden Treibers ermittelt
werden kann. Der Aufruf dieser Callback-Routine gibt dem fremden
Treiber dann die M&ouml;glichkeit, sich sauber und r&uuml;ckstandsfrei
zu deinstallieren.
<br>
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>
</p>
<p>Eingang:
<br>
<br>
</p>
<p>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>A0.L Zeiger auf den Interrupt-Handler des Treibers
<br>A1.L Zeiger auf Parameter f&uuml;r Interrupt-Handler
<br>
<br>Ausgang:
<br>
<br>D0.L PCI-BIOS Fehlercode
<br>
</p>
<p>Aufruf in C:
<br>
<br>LONG errorcode = hook_interrupt (LONG handle, ULONG *routine,
ULONG *parameter)
<br>handle: Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>routine: Zeiger auf den Interrupt-Handler des Treibers
<br>parameter: Zeiger auf Parameter f&uuml;r Interrupt-Handler
<br>
</p>
<p>dies ist ein vom Treiber frei zu w&auml;hlender Wert, der bei
jedem Aufruf des Handlers vom BIOS mit&uuml;bergeben wird. Dadurch
k&ouml;nnte ein einziger Interrupt-Handler auch mehrere baugleiche
PCI-Ger&auml;te bedienen.
<br>
<br>Returnwert: PCI-BIOS Fehlercode
<br>
</p>
<p>
<br>Unhook Interrupt Vector(!nl)
<br>Mit dieser Routine kann man einen mittels hook_interrupt
angemeldeten Interrupt-Handler wieder entfernen. Der Treiber mu&szlig;
allerdings beachten, da&szlig; die Interrupts auf dem PCI-Ger&auml;t
schon vor dem Aufruf dieser BIOS-Funktion deaktiviert werden
m&uuml;ssen, da es sonst zu spurious interrupts kommen kann.
<br>
<br>
</p>
<p>Aufruf in Assembler:
<br>
<br>Eingang:
<br>
<br>
</p>
<p>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>
<br>Ausgang:
<br>
<br>D0.L PCI-BIOS Fehlercode
<br>
<br>Aufruf in C:
<br>
<br>LONG errorcode = unhook_interrupt (LONG handle)
<br>
<br>handle: Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>Returnwert: PCI-BIOS Fehlercode
<br>
<br>
</p>
<p><b> Get Resource Data </b>
<br>
<br>Liefert s&auml;mtliche Infos zu den Resourcen einer PCI-Karte
(bzw. eines PCI-Ger&auml;tes im Fall von Multifunktionskarten). Die
zur&uuml;ckgelieferten Infos d&uuml;rfen von den Ger&auml;te-Treibern
keinesfalls ver&auml;ndert werden. Der Ger&auml;te-Treiber kann an
Hand der angebotenen Informationen (Byte ordering usw.) die Karte dann
direkt ansprechen. Eine weitere M&ouml;glichkeit ist die Verwendung
der BIOS-Routinen read_mem_..., write_mem_..., read_io_... und
write_io_..., wobei man sich dann um keinerlei Nebenbedingungen selbst
k&uuml;mmern mu&szlig;. Die Routine liefert einen Zeiger auf den
ersten Resource Deskriptor des gew&uuml;nschten PCI-Ger&auml;tes. Der
Ger&auml;te-Treiber kann dann die weiteren Deskriptoren &uuml;ber
einen Offset (L&auml;nge eines Deskriptors) erreichen. Der letzte
Deskriptor des Ger&auml;ts ist wiederrum speziell markiert. Die
Reihenfolge der Despriptoren entspricht derer der
Basisadre&szlig;register im PCI-Konfigurationsbereich. Ein
PCI-Ger&auml;t kann auch mehrere Resourcen des gleichen Typs
anfordern/verwenden.
<br>
<br>Aufruf in Assembler:
<br>
<br>Eingang:
<br>
<br>D0.L Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>
<br>Ausgang:
<br>
</p>
<p>D0.L Zeiger auf ersten Resource Deskriptor bzw. PCI-BIOS
Fehlercode
<br>
<br>Aufruf in C:
<br>
<br>LONG pointer = get_resource (LONG handle)
<br>handle: Ger&auml;te-Handle des gew&uuml;nschten PCI-Ger&auml;tes
<br>Returnwert: positiv - Zeiger auf Resourcen-Informationen (erster
Deskriptor)
<br>negativ - PCI-BIOS Fehlercode
<br>
<br>
<br>Tabelle 3: Aufbau eines Resource Deskriptors
<br>
<br>
</p>
<p>BIOS-interne Daten, d&uuml;rfen nicht ver&auml;ndert werden
<br>
<br>
<br>
</p>
<p>Um den Deskriptor der n&auml;chsten Resource des PCI-Ger&auml;tes
zu ermitteln, mu&szlig; man zur Startadresse des aktuellen Deskriptors
das Feld next addieren. Das Feld start gibt den Beginn der
entsprechenden Resource im PCI-Adre&szlig;bereich an. Falls diese
Resource nicht direkt ansprechbar sein sollte, so steht in diesem Feld
die Adresse 0. &amp;Uuml;ber length kann man schlie&szlig;lich die
L&auml;nge dieser Resource bestimmen. Der PCI-Adre&szlig;bereich ist
im allgemeinen nicht mit der von der <a href="080108.htm" target="UDOcon">CPU</a> aus gesehenen Adresse
gleichzusetzen. Der Adre&szlig;-Offset, der zur PCI-Adresse zu
addieren ist, um die physikalische Adresse f&uuml;r die <a href="080108.htm" target="UDOcon">CPU</a> zu
ermitteln, ist im Feld offset abgelegt.Der Eintrag dmaoffset gibt
schlie&szlig;lich den Offset an, der zur PCI-Adresse addiert werden
mu&szlig;, wenn es sich um DMA-Transfers handelt.
<br>
<br>
</p>
<p>Tabelle 4: Die Flags im Resource-Deskriptor
<br>
<br>
</p>
<p><b> Quellenverzeichnis: </b>
<br>
</p>
<p>[1] PCI Local Bus Specification Revision 2.0
<br>[2] Elrad 3/97 und 4/97 (Bus Basics - Technische Grundlagen des
PCI-Bus)
<br>[3] PCI Special Interest Group P.O. Box 14070 OR 97214, Portland,
USA http://www.pcisig.com
<br>[4] AMCC - http://www.amcc.com
<br>[5] PLX Technology - http://www.plxtech.com
<br>[6] Xilinx - http://www.xilinx.com
<br>[7] Lattice Semiconductor - http://www.latticesemi.com
<br>
<br>
<br>
</p>
<p>Vielen Dank an Konstantin Woller f&uuml;r diese Infos.
<br>
</p>
<p>
<br>
<br>
</p>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img.gif" border=0 width="50" height="40"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de/">Robert Schaffner</a> (<a href="mailto:doit@doitarchive.de">doit@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Mai 2004</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="05.htm" target="UDOcon"><img src="udo_up.gif" alt="Milan Hardware" border=0 width="24" height="24"></a>
<a href="050a.htm" target="UDOcon"><img src="udo_lf.gif" alt="Milan PCI Hardware 1" border=0 width="24" height="24"></a>
<a href="050c.htm" target="UDOcon"><img src="udo_rg.gif" alt="Milan SCSI Hardware" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>

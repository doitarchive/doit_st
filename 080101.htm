<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.05.2004 -->
<html>
<head>
<title>
DOIT_ST - Tips u. Tricks zur Atari Serie: Atari ST MFP
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="doit@doitarchive.de">
<link rev=made href="mailto:doit@doitarchive.de" title="E-Mail">
<link rel=home href="doitst1h.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_lf.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080102.htm" target="UDOcon"><img src="udo_rg.gif" alt="Atari ST DMA" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="Atari_20ST_20MFP">8.1.1 Atari ST MFP</a></h1>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p><tt> Der MFP 68901 im Atari </tt>
<br>
<br>
</p>
<p><img src="image/deutsch.gif" border=0 width="35" height="22"></p><br>
<p><img src="image/english.gif" border=0 width="35" height="22"></p><br>
<p>MFP ist eine Abk&uuml;rzung, hinter der sich das folgende
&quot;Langwort&quot; Multi-Funktion-Peripheral-Baustein versteckt. was
auch nicht gelogen ist. Dieses IC ist ein kleines Wunderwerk, in dem
sich einige Funktionen verstecken.
<br>
</p>
<p>- 8 Bit Parallelport - Datenrichtung eines Portbits separat
Programmierbar - Verwendung eines Portbits als Interrupteingang (siehe
ST) - verschiedene Interruptquellen - Vier programmierbare universal
Timer und eine serielle Schnittstelle
</p>
<p>Diese Funktionen sind nun alle in einem Geh&auml;use
untergebracht, das dieses etwas Platz beansprucht f&auml;llt dann an
dem 52 poligen Baustein schnell auf. Ich will an dieser Stelle
f&uuml;r die mehr Hardware orientierten Freaks auch die komplette
Pinbelegung dieses und des MFP-Bausteines des alten ST ablichten. So
werden die Unterschiede am deutlichsten.
<br>
</p>
<pre>
Pinbelegung des MFP im ST und im Falcon F030:
Der MFP im ST befinden sich im 48 Pin DIL-Geh&auml;use.
Der MFP im Falcon besitzt hingegen ein 52 poliges PLCC-Geh&auml;use!

PIN    FUNKTION ST  FALCON       PIN    FUNKTION ST  FALCON
---------------------------------------------------------------
                                 52     -            CS
1      R/W          NC           51     -            DS
2      A1           RXW          50     -            DTACK
3      A2           RS1          49     -            IACK
4      A3           RS2          48     CS           D7
5      A4           RS3          47     DS           D6
6      A5           RS4          46     DTACK        D5
7      TC           RS5          45     IACK         D4
8      SO           TC           44     D7           D3
9      SI           SO           43     D6           D2
10     RC           SI           42     D5           D1
11     Vcc          RC           41     D4           D0
12     NC           Vcc          40     D3           GND
13     TA 0         NC           39     D2           CLK
14     TB 0         NC           38     D1           IE1
15     TC 0         TAO          37     D0           IE0
16     TD 0         TBO          36     Vss          IRQ
17     XTAL 1       TCO          35     CLK          NC
18     XTAL 2       TDO          34     IEI          NC
19     TA 1         XTAL1        33     IEO          NC
20     TB 1         XTAL2        32     INTR         IO7
21     RESET        NC           31     RR           IO6
22     I0           TAI          30     TR           IO5
23     I1           TBI          29     17           IO4
24     I2           Reset        28     16           IO3
25     13           IO0          26     14           IO1
26     14           IO1          27     15           IO2

</pre>
<p>Kommen wir nun zu den Funktionsbaugruppen des MFP-Bausteins:
<br>Beachten Sie bitte das die Beschreibung vom ST auf den MFP des
Falcons nicht immer zu 100% &uuml;bereinstimmt.
<br>
</p>
<dl>
<dt><b>GND,Vcc,CLK</b></dt><dd>
<br>&nbsp;
<br>An GND und Vcc wird der Baustein mit der Betriebsspannung
versorgt, der Pin CLK dient dazu den Baustein mit dem Systemtakt zu
versorgen (4Mhz)
<br>&nbsp;
<dt><b>DO-D7,CS,DS,DTACK,RS1-RS5,RESET</b></dt><dd>
<br>&nbsp;
<br>D0-D7 verbindet den MFP mit dem 8-Bit Datenbus CS-Chipselekt /
DS-Datastrobe / DTACK-Data Transfer Acknowledge / RS1-RS5 Register
Select / RESET.
<br>&nbsp;
<br>Das Restet Signal mu&szlig; 2uS stabil Anliegen um den MFP in
einen definierten Grundzustand zu versetzen.
<br>&nbsp;
<br>Die n&auml;chste und wichtige Gruppe sind die
Interruptanschl&uuml;sse. IRQ-Interrupt ReQuest / IACK-Interrupt
ACKnowledge / IEI,IEO-Interrupt Enable In/Out
<br>Der Anschluss IRQ wird LOW wenn ein Ereigniss innerhalb des MFP
einen Interrupt ausgel&ouml;st hat. Es wird dann dem Prozessor mittels
diesem Anschluss ein Interrupt signalisiert.
<br>&nbsp;
<dt><b>IACK</b></dt><dd>
<br>&nbsp;
<br>Legt bei LOW an IRQ u.IEI einen Interruptvector auf die
Datenleitungen. Jede der 16 Interruptquellen kann einen eigenen Vector
liefern, so da&szlig; die Behandlung dessen f&uuml;r den Prozessor
wesentlich vereinfacht und somit beschleunigt wird.
<br>&nbsp;
<dt><b>IEI,IEO</b></dt><dd>
<br>&nbsp;
<br>An diesen Pin's k&ouml;nnen mehre MFP's untereinander Verkettet
werden. Was aber im Atari nicht der Fall ist. Betrifft auch nur den
ST.
<br>&nbsp;
<dt><b>IO0 - IO7</b></dt><dd>
<br>&nbsp;
<br>Man kann diese Leitungen als normale Ein od. Ausgabeleitungen
verwenden. Die Datenrichtung ist mittels der Portbits frei
einstellbar, zus&auml;tzlich kann jedes Portbit als Interrupteingang
programmiert werden. Mit den internen Registern k&ouml;nnen f&uuml;r
jedes Bit getrennt die Flanke des ausl&ouml;senden Signals eingestellt
werden.
<br>&nbsp;
<dt><b>XTAL1 und XTAL2</b></dt><dd>
<br>&nbsp;
<br>Timer Quarz
<br>
<br>&nbsp;
<br>An diesen Pin k&ouml;nnen f&uuml;r die internen Timer ein Quarz
angeschlossen werden, welcher die Arbeitsfrequenz der internen Timer
festlegt
<br>&nbsp;
<dt><b>TA0,TB0,TC0,TD0</b></dt><dd>
<br>&nbsp;
<br>Timer Ausgang
<br>
<br>&nbsp;
<br>Die vier internen Timer verf&uuml;gen jeder &uuml;ber einen
eigenen Ausgang, an dem der Pegel wechselt wenn der Timer den
Z&auml;hlerstand von 01 nach 00 wechselt. Die Z&auml;hler arbeiten nur
als Abw&auml;rtsz&auml;hler !
<br>&nbsp;
<dt><b>SI, SO</b></dt><dd>
<br>&nbsp;
<br>serieller Eingang, serieller Ausgang
<br>&nbsp;
<dt><b>RC,TC</b></dt><dd>
<br>&nbsp;
<br>Receive Clock, Transmit Clock
<br>Die &Uuml;bertragungsgeschwindigkeit der Sende/Empfangsdaten wird
durch die an diesen Pin liegende Frequenz bestimmt.
<br>&nbsp;
<dt><b>RR,TR</b></dt><dd>
<br>&nbsp;
<br>Receiver Ready,Transmitter Ready
<br>Finden im <a href="0305.htm" target="UDOcon">Atari ST</a> und im Falcon keine Verwendung.
<br>&nbsp;
<dt><b>Reg 1 GPIP</b></dt><dd>
<br>&nbsp;
<br>General Purpose I/O Interrupt Port
<br>
<br>&nbsp;
<br>Datenregister des 8 Bit Ports, mit dieser Adresse werden die Daten
an die Portbits geschrieben / gelesen.
<br>&nbsp;
<dt><b>Reg 2 AER</b></dt><dd>
<br>&nbsp;
<br>Active Edge Register
<br>
<br>&nbsp;
<br>Falls die Portbits als Interrupteingang benutzt werden,wird mit
diesem Register festgelegt ob der Interrupt bei LOW od. HIGH Pegel
ausgel&ouml;st wird.
<br>&nbsp;
<dt><b>Reg 3 Data</b></dt><dd>
<br>&nbsp;
<br>Direction Register
<br>
<br>&nbsp;
<br>Dieses Register legt die Datenrichtung eines jeden Portbits fest.
Eine 0 bedeutet dabei &quot;Eingang&quot; eine 1 hingegen ein
&quot;Ausgang&quot;.
<br>&nbsp;
<dt><b>Reg 4,5</b></dt><dd>
<br>&nbsp;
<br>IERA,IERB Interrupt Enable Register
<br>
<br>&nbsp;
<br>Jede Interruptquelle kann hier separat Ein bzw. Ausgeschaltet
werden. Eine Interruptquelle an einem Ausgeschaltetem Kanal wird vom
MFP komplett ignoriert.
<br>&nbsp;
<dt><b>IERA</b></dt><dd>
<br>&nbsp;
<br>Bit 7 I/O Port Bit 7, h&ouml;chste Stufe
<br>Bit 6 I/O Port Bit 6
<br>Bit 5 Timer A
<br>Bit 4 Empf&auml;nger Buffer voll
<br>Bit 3 Empf&auml;nger Fehler
<br>Bit 2 Sender Buffer voll
<br>Bit 1 Sender Fehler
<br>Bit 0 Timer B
<br>
<br>&nbsp;
<dt><b>IERB</b></dt><dd>
<br>&nbsp;
<br>Bit 7 I/O Port Bit 5
<br>Bit 6 I/O Port Bit 4
<br>Bit 5 Timer C
<br>Bit 4 Timer D
<br>Bit 3 I/O Port Bit 3
<br>Bit 2 I/O Port Bit 2
<br>Bit 1 I/O Port Bit 1
<br>Bit 0 I/O Port Bit 0, niedriegste Stufe
<br>
<br>&nbsp;
<br>Diese Zuordnung findet auch Anwendung bei den IP,IM,u.IS
Registern.
<br>&nbsp;
<dt><b>Reg 6,7</b></dt><dd>
<br>&nbsp;
<br>IPRA,IPRB Interrupt Pending Register
<br>
<br>&nbsp;
<br>Wenn bei einem eingeschaltetem Kanal ein Interrupt auftritt, wird
das dem Kanal zugeordnete Bit im IPRA, IPRB Register auf &quot;1&quot;
gesetzt. Wenn das System gebrauch von der Vektor-Erzeugung macht, wird
das entsprechende Bit automatisch wieder gel&ouml;scht, sobald der MFP
die Vektornummer auf den Bus legt. Wenn das System von dieser
m&ouml;glichkeit keinen Gebrauch macht, mu&szlig; das IPR-Register
Softwarem&auml;ssig gel&ouml;scht werden. Zu diesem Zweck ist ein Byte
an den MFP zu schicken in dem alle Bits bis auf das zu l&ouml;schende
gesetzt sind.
<br>&nbsp;
<dt><b>Reg 8,9</b></dt><dd>
<br>&nbsp;
<br>ISRA,ISRB Interrupt In-Service Register
<br>
<br>&nbsp;
<br>Die Funktion dieser Register h&auml;ngen vom Bit 3 des Registers
12 ab. Dieses &quot;S&quot;-Bit bestimmt ob der MFP im Software
End-of-Interruptmodus (SEI) oder im Automatic End-of-Interruptmodus
(AEI) arbeitet. Im AEI Modus wird das IPR-Bit gel&ouml;scht,sobald der
Prozessor w&auml;hrend eines IACK-Zyklus die Vektornummer auf dem Bus
abholt. Auch das zugeh&ouml;rige In-Service Bit wird zu diesem
Zeitpunkt gel&ouml;scht. Danach k&ouml;nnen erneute Ereignisse
(Interrupts) auftreten. Im SEI-Modus dagegen wird das entsprechende
ISR-Bit gesetzt,wenn die Vektornummer des Interrupts, vom Prozessor
angefordert wird. Am Ende der Interruptroutine mu&szlig; das Bit
gel&ouml;scht werden, in dem ein Byte in dem alle Bits bis auf das zu
l&ouml;schende gesetzt sind, an den MFP geschickt wird. Wenn das
Sevice In-Bit gesetzt ist, sind alle Interrupts niedriger Stufe im MFP
ausmaskiert Da das IPR Bit des aktiven Kanals mit der &uuml;bergabe
der Vektornummer gel&ouml;scht wurde, kann jetzt ein gleichartiger
Interrupt sofort wieder auftreten. Allerdings werden dieser u.
niedrigere Interrupts erst wieder bearbeitet (l&ouml;sen IRQ aus) wenn
das gesetzte Service-In Bit gel&ouml;scht wird.
<br>&nbsp;
<dt><b>Reg 10,11</b></dt><dd>
<br>&nbsp;
<br>IMRA,IMRB Interrupt Mask Register
<br>
<br>&nbsp;
<br>Mit diesem Register k&ouml;nnen einzelne, in den IER geschaltete
Interruptquellen ausmaskiert werden. Die Ereignisse werden dann zwar
erkannt und dem IPR signalisiert, die IRQ-Leitung bleibt aber auf
High-Pegel.
<br>&nbsp;
<dt><b>Reg 12</b></dt><dd>
<br>&nbsp;
<br>VR Vektor Register
<br>
<br>&nbsp;
<br>Im Fall eines Ereigniss kann der MFP auf die Anforderung des
Prozessors im Interrupt-Acknowledge Zyklus eine der Ereigniss-Quellen
entspechende Vektornummer generieren. Jeder der 8 (16) Kan&auml;le
verf&uuml;gt &uuml;ber seinen eigenen Vektor. Die 8 (16) Kan&auml;le
werden entsprechend der Priorit&auml;t in den unteren 4 Bits der
Vektornummer codiert,die oberen 4 Bits des Vektors werden aus dem VR
Vektorregister kopiert. Dazu m&uuml;ssen diese Bits im VR gesetzt
sein. Das Bit 3 des VR ist das schon erl&auml;uterte S-Bit, welches
&uuml;ber die beiden Arbeitsmodi des MFP entscheidet.
<br>&nbsp;
<dt><b>Reg 13,14</b></dt><dd>
<br>&nbsp;
<br>TACR,TBCR Timer A/B Contoll Register
<br>
<br>&nbsp;
<br>Die internen Timer A und B verf&uuml;gen &uuml;ber die gleichen
M&ouml;glichkeiten. Sie bestehen aus je einem Datenregister, einem
programmierbaren Vorteiler und einem 8-bit Abw&auml;rtsz&auml;hler.
Der Inhalt des Z&auml;hlers wird bei jedem Impuls, der vom Vorteiler
geliefert wird um eins verringert. Wenn der Z&auml;hler auf 01 steht,
wechselt er beim n&auml;chsten Impuls am zugeh&ouml;rigen Ausgang
seinen Pegel. Zugleich wird der Timer mit dem Wert des
Timer-Datenregisters geladen. Ist bei diesem Kanal das IER-Bit
gesetzt, wird ausserdem ein Interrupt ausgel&ouml;st. Als Quelle des
Z&auml;hlertaktes wird &uuml;blicherweise die Frquenz genommen, die
als Quarz an den Anschl&uuml;ssen XTAL1/XTAL2 anliegt, diese Frequenz
wird auch als Delay-Mode bezeichnet. Das selbe trifft auch f&uuml;r
die Timer C und D zu. Doch k&ouml;nnen auch bei den Timern A und B
externe Impulse an den Timer- eing&auml;ngen TAI / TBI gez&auml;hlt
werden. Das wird dann als Event-Count-Mode bezeichnet. Beim
z&auml;hlen externer Impulse wird der Vorteiler abgeschaltet, um
wirklich jeden ankommenden Impuls exakt z&auml;hlen zu k&ouml;nnen.
Die Maximale Z&auml;hlfrequenz darf 1Mhz nicht &uuml;berschreiten, was
einem viertel der Betriebsfrequenz des MFP entspricht. Eine weitere
Besonderheit dieser Betriebsart ist das, die Timer-Eing&auml;nge den
Interrupts der I/O-Anschl&uuml;sse I3/I4 zugeordnet sind. Je nach
Programmierung der entsprechenden Bit's im Active Edge Register kann
durch einen Pegelsprung an den Timereing&auml;ngen ein Interrupt
ausgel&ouml;st werden. TAI ist I4,TBI ist I3 zugeordnet,I3 und I4
k&ouml;nnen dabei jedoch immer noch als I/O-Anschl&uuml;sse ohne
Interrupt benutzt werden. Timer A/B haben noch eine dritte
Betriebsart, die man Pulsweitenmessung nennt. Diese Betriebsart
&auml;hnelt dem Delay-Mode,als unterschied ist zu erkennen das mittels
der Timereing&auml;nge TAI /TBI die Timer ein/aus geschaltet werden
k&ouml;nnen. Auch bei dieser Betriebsart werden die AER-Bit's von
I3/I4 benutzt,um festzulegen ob die Timer bei High oder Low-Pegel an
den Timereing&auml;ngen arbeiten d&uuml;rfen. Wenn z.B das AER-Bit 4
gesetzt ist,arbeitet der Z&auml;hler,wenn TAI High ist. Wechselt TAI
von High nach Low, so wird ein Interrupt erzeugt, vorrausgesetzt, der
Interrupt des I4-Kanal's ist zugelassen.
<br>&nbsp;
<br>Die Programmierung von TACR und TBCR.
<br>In diesen beiden Registern werden nur f&uuml;nf der acht
m&ouml;glichen Bits genutzt. Die Bits 0 bis 3 bestimmen die
Betriebsart des entsprechenden Timers nach der Tabelle:
<br>&nbsp;
<br>Bit 3 2 1 0 Funktion
<br>-----------
<br>Bit 0 0 0 0 Timer Stop ,Keine Funktion
<br>Bit 0 0 0 1 Delay Modus ,Vorteiler teilt durch 4
<br>Bit 0 0 1 0 &quot; &quot; , &quot; &quot; &quot; 10
<br>Bit 0 0 1 1 &quot; &quot; &quot; &quot; &quot; 16
<br>Bit 0 1 0 0 &quot; &quot; &quot; &quot; &quot; 50
<br>Bit 0 1 0 1 &quot; &quot; &quot; &quot; &quot; 64
<br>Bit 0 1 1 0 &quot; &quot; &quot; &quot; &quot; 100
<br>Bit 0 1 1 1 &quot; &quot; &quot; &quot; &quot; 200
<br>Bit 1 0 0 0 Event Count Mode,
<br>Bit 1 0 0 1 Pulsweiten Mode , Vorteiler teilt durch 4
<br>Bit 1 0 1 0 &quot; &quot; &quot; &quot; &quot; 10
<br>Bit 1 0 1 1 &quot; &quot; &quot; &quot; &quot; 16
<br>Bit 1 1 0 0 &quot; &quot; &quot; &quot; &quot; 50
<br>Bit 1 1 0 1 &quot; &quot; &quot; &quot; &quot; 64
<br>Bit 1 1 1 0 &quot; &quot; &quot; &quot; &quot; 100
<br>Bit 1 1 1 1 &quot; &quot; &quot; &quot; &quot; 200
<br>
<br>&nbsp;
<dt><b>Reg 15</b></dt><dd>
<br>&nbsp;
<br>TCDCR Timer C und D Controll Register
<br>
<br>&nbsp;
<br>Bit 2 1 0 Funktion Timer D
<br>Bit 6 5 4 Funktion Timer C
<br>-----------
<br>Bit 0 0 0 Timer Stop , Keine Funktion
<br>Bit 0 0 1 Delay Modus, Vorteiler teilt durch 4
<br>Bit 0 1 0 &quot; &quot; &quot; &quot; &quot; 10
<br>Bit 0 1 1 &quot; &quot; &quot; &quot; &quot; 16
<br>Bit 1 0 0 &quot; &quot; &quot; &quot; &quot; 50
<br>Bit 1 0 1 &quot; &quot; &quot; &quot; &quot; 64
<br>Bit 1 1 0 &quot; &quot; &quot; &quot; &quot; 100
<br>Bit 1 1 1 &quot; &quot; &quot; &quot; &quot; 200
<br>
<br>&nbsp;
<br>Die Bits 3 u.7 in diesem Register haben keine Funktion.
<br>
<br>&nbsp;
<dt><b>Reg 16-19</b></dt><dd>
<br>&nbsp;
<br>TADR,TBDR,TCDR,TDDR Timer Data Register
<br>
<br>&nbsp;
<br>Die Timer Datenregister werden mit dem Wert programmiert der in
den Z&auml;hler geladen wird wenn er nach erreichen des
Z&auml;hlerstandes 01 einen Impuls bekommt. Von diesem Wert aus wird
dann kontinuierlich abw&auml;rts gez&auml;hlt.
<br>&nbsp;
<dt><b>Reg 20</b></dt><dd>
<br>&nbsp;
<br>SCR Syncron Character Register
<br>
<br>&nbsp;
<br>In diesem Register wird bei einer synchronen <a href="1507.htm" target="UDOcon">Daten&uuml;bertragung</a>
ein Wert geschrieben der beim Empfang den beginn der Daten
kennzeichnet. Anschliessend werden alle Daten mit diesem Wert
verglichen und nach &uuml;bereinstimmung in den Datenbuffer
&uuml;bertragen.
<br>&nbsp;
<dt><b>Reg 21</b></dt><dd>
<br>&nbsp;
<br>UCR,USART Controll Register
<br>
<br>&nbsp;
<br>Mit diesem Register werden alle Parameter der Schnittstelle
eingestellt. Ausgenommen der Baudrate.
<br>
<br>&nbsp;
<br>Bit 0 : nicht benutzt
<br>Bit 1 : 0 parity odd
<br>Bit 1 : 1 &quot; even
<br>
<br>&nbsp;
<br>Bit 2 : 0 keine parity (Bit 1 wird ignoriert)
<br>Bit 2 : 1 parity entsprechend Bit 1
<br>
<br>&nbsp;
<br>Bit 3,4: diese Bits bestimmen Start u. Stoppbits und das
gew&uuml;nschte Format.
<br>Bit 4 3 Start Stop Format
<br>Bit 0 0 0 0 Syncron
<br>Bit 0 1 1 1 Asyncron
<br>Bit 1 0 1 1,5 &quot;
<br>Bit 1 1 1 2 &quot;
<br>
<br>&nbsp;
<br>Bit 5,6: geben die Anzahl der zu &uuml;bertragenen Datenbits an.
<br>
<br>&nbsp;
<br>Bit 6 5 Wortl&auml;nge
<br>Bit 0 0 8 Bits
<br>Bit 0 1 7 &quot;
<br>Bit 1 0 6 &quot;
<br>Bit 1 1 5 &quot;
<br>
<br>&nbsp;
<br>Bit 7 : 0 = Frequenz an TC u. RC wird Direkt als
&Uuml;bertragungsfrequenz benutzt.
<br>Bit 7 : 1 = Frequenz wird intern durch 16 geteilt.
<br>
<br>&nbsp;
<dt><b>Reg 22</b></dt><dd>
<br>&nbsp;
<br>RSR Receiver Status Register
<br>
<br>&nbsp;
<br>Bit 0 Receiver Enable Bit
<br>
<br>&nbsp;
<br>Wenn dieses Bit gel&ouml;scht wird ist der Empfangsteil sofort
ausgeschaltet. Alle Flags im RSR werden automatisch gel&ouml;scht.
Wird das Bit wieder gesetzt arbeitet der Empf&auml;nger normal weiter.
<br>&nbsp;
<br>Bit 1 Syncronous Strip Enable
<br>
<br>&nbsp;
<br>Mit diesem Bit kann bei einem synchronem Datentransfer bestimmt
werden ob ein mit dem im SCR gespeicherten identischen Zeichen in den
Receiver Buffer &uuml;bertragen wird oder nicht.
<br>&nbsp;
<br>Bit 2 Match/Character In Progress
<br>
<br>&nbsp;
<br>Im synchronen &Uuml;bertragungsmodus wird mit diesem Bit angezeigt
da&szlig; ein mit dem SCR-Byte identisches Zeichen empfangen wurde. Im
asynchronen Modus wird dieses Bit gesetzt sobald das Startbit erkannt
wurde. Mit dem eintreffen des Stopbits wird das Flag sofort wieder
gel&ouml;scht.
<br>&nbsp;
<br>Bit 3 Found-Search/Break Detected
<br>
<br>&nbsp;
<br>Bit 3 im RSR zeigt an ob ein empfangenes Zeichen im synchon Modus
mit dem Zeichen in SCR &uuml;bereinstimmt. Diese Bedingung kann
&uuml;ber den Receiver Error Kanal einen Interrupt ausl&ouml;sen. In
der asynchronen Betriebsart wird das Bit gesetzt sobald ein Break
empfangen wird, die Break-Bedingung wir dann nur erf&uuml;llt wenn
nach dem Startbit nur Nullen empfangen werden. Zur Unterscheidung
zwischen einem Break und einer 'echten null' mu&szlig; die
Empf&auml;ngerleitung auch in der Zeit des Stop-Bits auf Low bleiben.
<br>&nbsp;
<br>Bit 4 Frame Error
<br>
<br>&nbsp;
<br>Ein Frame Error taucht auf wenn ein Byte empfangen wird das nicht
Null ist, dessen Stopbit aber eine Null ist.
<br>
<br>&nbsp;
<br>Bit 5 Parity Error
<br>
<br>&nbsp;
<br>Dieses Bit gibt an ob auch das letzte empfangene Zeichen den
Anforderungen der Parit&auml;t gerecht wurde. Wenn die
Parit&auml;tspr&uuml;fung beim Empfang ausgeschaltet wurde wird das
Bit 5 nicht beeinflusst.
<br>
<br>&nbsp;
<br>Bit 6 Overrun Error
<br>
<br>&nbsp;
<br>Das Bit 6 zeigt an das ein vollst&auml;ndiges Zeichen im Empfangs-
schieberegister bereit liegt, das zuvor empfangene Zeichen aber noch
nicht aus dem Empf&auml;ngerbuffer ausgelesen wurde. Dieser Fehler
kann einen Interrupt ausl&ouml;sen.
<br>
<br>&nbsp;
<br>Bit 7 Buffer Full
<br>
<br>&nbsp;
<br>Bit 7 wird gesetzt sobald, ein fertiges Zeichen aus dem
Schieberegister in den Empf&auml;ngerbuffer &uuml;bertragen wird.
Sobald der Prozessor das Byte ausliest wird das Bit gel&ouml;scht.
<br>&nbsp;
<dt><b>Reg 23</b></dt><dd>
<br>&nbsp;
<br>TSR Transmitter Status Register
<br>
<br>&nbsp;
<br>Bit 0 Transmitter Enable
<br>
<br>&nbsp;
<br>Wenn dieses Bit gel&ouml;scht wird,ist der Sendteil
vollst&auml;ndig abgeschaltet.Das End-Bit wird gel&ouml;scht und das
UE-Bit wird gesetzt.
<br>
<br>&nbsp;
<br>Bit 1,2 High, Low-Bit
<br>
<br>&nbsp;
<br>Mit diesen beiden Bits kann der Zustand des abgeschalteten
Senderausgangs beeinflusst werden,wenn beide Bits gel&ouml;scht sind
wird der Ausgang hochohmig. Wird das L-Bit gesetzt ist der Ausgang
Low. Im Gegenzug, also bei gesetztem H-Bit wird der Ausgang High. In
dem Falle das beide Bits gesetzt werden wird der Senderausgang mit dem
Empf&auml;ngereingang intern (Loop-Back-Modus)verbunden. Der Ausgang
selber liegt dann auf High-Pegel.
<br>
<br>&nbsp;
<br>Bit 3 Break
<br>
<br>&nbsp;
<br>Bit 3 hat im Synchron-Modus keine Bedeutung. Im
Asynchronen-Betrieb wird wenn das Bit gesetzt wird die Break Bedingung
ausgesendet.
<br>
<br>&nbsp;
<br>Bit 4 End of Transmitt
<br>
<br>&nbsp;
<br>Wird der Sendeteil w&auml;hrend der laufenden &Uuml;bertragung
ausgeschaltet so wird das End-Bit gesetzt nachdem das aktuelle Zeichen
vollst&auml;ndig gesendet wurde. Wird zum Zeitpunkt des Abschaltens
gerade kein Zeichen gesendet wird das End-Bit sofort gesetzt.
<br>
<br>&nbsp;
<br>Bit 5 Auto Turnaround
<br>
<br>&nbsp;
<br>Ist das Bit 5 gesetzt wird der Empf&auml;nger automatisch
eingeschaltet wenn der Sender das letzte Zeichen vollst&auml;ndig
gesendet hat.
<br>&nbsp;
<br>Bit 6 Underun Error
<br>
<br>&nbsp;
<br>Dieses Bit wird gesetzt wenn ein im Sendeschieberegister
enthaltenes Zeichen komplett gesendet wurde, bevor ein neues Zeichen
in den Sendebuffer geschrieben wurde.
<br>
<br>&nbsp;
<br>Bit 7 Buffer Empty
<br>
<br>&nbsp;
<br>Wird gesetzt, wenn ein Zeichen aus dem Senderbuffer in das
Schieberegister &uuml;bertragen wird. Das Bit wird gel&ouml;scht, wenn
neue Daten in den Sendebuffer gelangen.
<br>
<br>&nbsp;
<dt><b>Reg 24</b></dt><dd>
<br>&nbsp;
<br>UDR,USART Data Register
<br>
<br>&nbsp;
<br>In diesem Register werden Sende/Empfangsdaten &uuml;bertragen.
Beim hineinschreiben gelangen die Daten in den Sendebuffer und beim
Auslesen kommen sie automatisch aus dem Empfangsbuffer.
<br>
<br>&nbsp;
</dl>
<p>
<br>
</p>
<p>A smal english description of the MFP Chip follows.
<br>
</p>
<div align=center><tt> MC68901 Multi-Function Peripheral Chip
<br>
</div>
<div align=center>Jeff Rigby/SOTA Computers </tt>
<br>
</div>
<p>The 68901 is a very inexpensive very powerful multi-function chip.
In the ST it is responsible for the interrupt generation of the busy
line on the printer port, the interrupt signal from the hard drive
port and the prin- ter port, Midi port, keyboard, and RS-232 port as
well as the entire RS - 232 receive, transmit and controll lines (16
levels of interrupt ). In ad- dition, the MFP can be daisy chained ( a
second 68901 can be added allo - wing the interrupt levels to be
chained ). All this in a chip with a re - tail cost of about $12.00.
<br>
</p>
<p>How it works; the 68000 <a href="080108.htm" target="UDOcon">CPU</a> has 7 levels of interrupt, one of
those levels points to the 68901 MFP, when the <a href="080108.htm" target="UDOcon">CPU</a> is told that the
MFP needs servi - ceing, the address of the service routine is given
controll, it addresses $fffffa00 which the glue chip decodes and sends
a low on the chip select pin 48 of the MFP, then the routine sends an
address to the lower 5 lines of the address bus to select a register
in the MFP and the routine, depen- ding on what it needs to do writes
or reads the registers in the chip.
<br>
</p>
<p>The operating system has previously set the interrupt registers in
the MFP with the priorities the Interrupt lines I0-I7 and the internal
receive and transmit buffers require. The 68901 then talks directly to
the 68000 tel - ling it that one of it's interrupt's needs servicing,
giving the vector adress of the service routine, and this goes on
until all the 68901 inter- rupts are serviced then control is passed
back to the 68000 and the pro - cess starts all over again. If no
interrupts need servicing then control is passed back to the 68000
immediately.
<br>
</p>
<p>I'll try to make this as non-technical as possible.
<br>
</p>
<p>MFP tells the Glue chip that it needs servicing. Glue thinks and
says OK, I guess it is your turn. Glue tells <a href="080108.htm" target="UDOcon">CPU</a> that a IRQ level is
pending. <a href="080108.htm" target="UDOcon">CPU</a> to Glue &quot; what level is it &quot;. <a href="080108.htm" target="UDOcon">CPU</a> to Glue tell
the MFP it's his turn. Glue tells MFP to go ahead -&gt; CS on MFP goes
low MFP gives the <a href="080108.htm" target="UDOcon">CPU</a> the vector for the needed routine The routine
services the MFP and clears the Interrupt register. Control is passed
back to the <a href="080108.htm" target="UDOcon">CPU</a> and the next level down interrupt has a chance.
<br>
</p>
<p>Maybe that was too simple, the 68901 does alot more than that and
I could spend all day and 30 screens to tell you about it.
<br>
</p>
<p>Literature is available from Motorola on the MC68901, I believe
the 28 pa- ge technical booklet is #ADI-984, The great thing is that
we can add a se- cond RS-232 very cheaply by daisy chaining the IEI
and IEO pins on the 68901 and changing the vector addresses for the
service routines.
<br>
</p>
<p>A few suggestions for standards in the ST upgrades.
<br>
</p>
<dl>
<dt><b>1)</b></dt><dd> The output pin in the video out port be used for Monitor
switching (Mo no to Color).
<br>
<br>&nbsp;
<dt><b>2)</b></dt><dd> Pin 25 I3 of the 68901 MFP be used for an interrupt to tell
software
<br>that the power has been interrupted. In battery backups in the
1040 all
<br>power 12v and 5V can be provided for 10 min with C cell Ni-Cad.
The
<br>software has to be informed that power is out and to save the
data.
<br>
<br>&nbsp;
<br>Suggest a low for power interrupt on pin 25.
<br>
<br>&nbsp;
<dt><b>3)</b></dt><dd> Address $fffffb00 be used for a second 68901 MFP and the second
MFP be
<br>daisy chained using the IEO and IEI pins.
<br>
<br>&nbsp;
<dt><b>4)</b></dt><dd> An address for battery backup clocks be picked as standard. I
don't ha-
<br>ve any thoughts on this one but an address should be suggested.
Anyone
<br>have an address that is already being used for this purpose and
the
<br>reason it was chosen please respond.
<br>
<br>&nbsp;
</dl>
<p>As a hardware hacker, I am interested in other people's input on
this sub- ject. The great thing about PD software is that people build
upon the work of others and eventually the PD software can be better
than commercial software. I would like to see something like that
started on the technical side, if someone finds a flaw or a better way
to describe the 68901 please add it to this file and upload to CIS.
<br>
</p>
<p>Jeff Rigby/SOTA Computers
<br>3949 Sawyer Road
<br>SARASOTA, FL. 33583 (USA)
<br>
</p>
<p>
<br>
<br>
</p>
<p align=center><img src="image/mfp.gif" border=0 width="210" height="366"></p><br>
<div align=center><tt> Abbildung 1 - Atari MFP Chip </tt>
</div>
<p>
<br>
<br>
</p>
<p>
<br>
<br><b> MK68901 MFP (Multi-Function Peripheral) </b>
<br>
</p>
<p>Introduction
<br>
</p>
<p>The MK68901 MFP (Multi-Function Peripheral) is a combination of
many of the necessary peripheral functions in a microprocessor system.
Included are:
<br>
<br>Eight parallel I/O lines
<br>Interrupt controller for 16 sources
<br>Four timers
<br>Sungle channel full duplex USART
<br>
<br>The use of the MFP in a system can significantly reduce chip
count, thereby reducing system cost. The MFP is completely 68000 bus
compatible, and 24 directly addressable internal registers provide the
necessary control and status interface to the programmer.
<br>
</p>
<p>The MFP is a derivative of the MK3801, a Z80 family peripheral.
<br>
</p>
<p>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 49: Register MAP</caption>
<tr>
  <td align=left valign=top>Address</td>
  <td align=left valign=top>Abbreviation</td>
  <td align=left valign=top>Register Name</td>
</tr>
<tr>
  <td align=left valign=top>Port #</td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>0</td>
  <td align=left valign=top>GPIP</td>
  <td align=left valign=top>General purpose I/O</td>
</tr>
<tr>
  <td align=left valign=top>1</td>
  <td align=left valign=top>AER</td>
  <td align=left valign=top>Active edge register</td>
</tr>
<tr>
  <td align=left valign=top>2</td>
  <td align=left valign=top>DDR</td>
  <td align=left valign=top>Data direction register</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>3</td>
  <td align=left valign=top>IERA</td>
  <td align=left valign=top>Interrupt enable register A</td>
</tr>
<tr>
  <td align=left valign=top>4</td>
  <td align=left valign=top>IERB</td>
  <td align=left valign=top>Interrupt enable register B</td>
</tr>
<tr>
  <td align=left valign=top>5</td>
  <td align=left valign=top>IPRA</td>
  <td align=left valign=top>Interrupt pending register A</td>
</tr>
<tr>
  <td align=left valign=top>6</td>
  <td align=left valign=top>IPRB</td>
  <td align=left valign=top>Interrupt pending register B</td>
</tr>
<tr>
  <td align=left valign=top>7</td>
  <td align=left valign=top>ISRA</td>
  <td align=left valign=top>Interrupt in-service register A</td>
</tr>
<tr>
  <td align=left valign=top>8</td>
  <td align=left valign=top>ISRB</td>
  <td align=left valign=top>Interrupt in-service register B</td>
</tr>
<tr>
  <td align=left valign=top>9</td>
  <td align=left valign=top>IMRA</td>
  <td align=left valign=top>Interrupt mask register A</td>
</tr>
<tr>
  <td align=left valign=top>A</td>
  <td align=left valign=top>IMRB</td>
  <td align=left valign=top>Interrupt mask register B</td>
</tr>
<tr>
  <td align=left valign=top>B</td>
  <td align=left valign=top>VR</td>
  <td align=left valign=top>Vector register</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>C</td>
  <td align=left valign=top>TACR</td>
  <td align=left valign=top>Timer A control register</td>
</tr>
<tr>
  <td align=left valign=top>D</td>
  <td align=left valign=top>TBCR</td>
  <td align=left valign=top>Timer B control register</td>
</tr>
<tr>
  <td align=left valign=top>E</td>
  <td align=left valign=top>TCDCR</td>
  <td align=left valign=top>Timers C and D control registers</td>
</tr>
<tr>
  <td align=left valign=top>F</td>
  <td align=left valign=top>TADR</td>
  <td align=left valign=top>Timer A data register</td>
</tr>
<tr>
  <td align=left valign=top>10</td>
  <td align=left valign=top>TBDR</td>
  <td align=left valign=top>Timer B data register</td>
</tr>
<tr>
  <td align=left valign=top>11</td>
  <td align=left valign=top>TCDR</td>
  <td align=left valign=top>Timer C data register</td>
</tr>
<tr>
  <td align=left valign=top>12</td>
  <td align=left valign=top>TDDR</td>
  <td align=left valign=top>Timer D data register</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>13</td>
  <td align=left valign=top>SCR</td>
  <td align=left valign=top>Sync character register</td>
</tr>
<tr>
  <td align=left valign=top>14</td>
  <td align=left valign=top>UCR</td>
  <td align=left valign=top>USART control register</td>
</tr>
<tr>
  <td align=left valign=top>15</td>
  <td align=left valign=top>RSR</td>
  <td align=left valign=top>Receiver status register</td>
</tr>
<tr>
  <td align=left valign=top>16</td>
  <td align=left valign=top>TSR</td>
  <td align=left valign=top>Transmitter status register</td>
</tr>
<tr>
  <td align=left valign=top>17</td>
  <td align=left valign=top>UDR</td>
  <td align=left valign=top>USART data register</td>
</tr>
</table></div>

<p>
<br>
<br>
</p>
<p><b> Interrupts </b>
<br>
</p>
<p>The General Purpose I/O-Interrupt Port (GPIP) provides eight I/O
lines that may be operated either as inputs or outputs under software
control. In addition, each line may generate an interrupt on either a
positive going edge or a negative going edge of the input signal.
<br>
</p>
<p>The GPIP has three associated registers. One allows the programmer
to specify the Active Edge for each bit that will trigger an
interrupt. Another register specifies the Data Direction (input or
output) associated with each bit. The third register is the actual
data I/O register used to input or output data to the port. These
three registers are illustrated below.
<br>
</p>
<p>General Purpose I/O Registers
<br>
</p>
<pre>                    Active Edge Register
Port 1 (AER)  GPIP GPIP GPIP GPIP GPIP GPIP GPIP GPIP   1=Rising
               7    6    5    4    3    2    1    0     0=Falling

                    Data Direction Register
Port 2 (DDR)  GPIP GPIP GPIP GPIP GPIP GPIP GPIP GPIP   1=Output
               7    6    5    4    3    2    1    0     0=Input

                    General Purpose I/O Register
Port 3 (GPIP) GPIP GPIP GPIP GPIP GPIP GPIP GPIP GPIP
               7    6    5    4    3    2    1    0
</pre>
<p>The Active Edge Register (AER) allows each of the General Purpose
Interrupts to produce an interrupt on either a 1-0 transition or a 0-1
transition. Writing a zero to the appropriate bit of the AER causes
the associated input to produce an interrupt on the 1-0 transition,
while a 1 causes the interrupt on the 0-1 transition. The edge bit is
simply one input to an exclusive-or gate, with the other input coming
from the input buffer and the output going to a 1-0 transition
detector. Thus, depending upon the state of the input, writing the AER
can cause an interrupt-producing transition, which will cause an
interrupt on the associated channel, if that channnel is enabled. One
would than normally configure the AER before enabling interrupts via
IERA an IERB. Note: changing the edge bit, with the interrupt enabled,
may cause an interrupt on that channel.
<br>
</p>
<p>The Data Direction Register (DDR) is used to define I0-I7 as input
or as outputs on a bit by bit basis. Writing a zero into a bit of the
DDR causes the corresponding Interrupt I/O pin to be a Hi-Z Input.
Writing a one into a bit of the DDR causes the corresponding pin to be
configured as a push-pull output. When data is written into the GPIP,
those pins defined as inputs will remain in the Hi-Z state while those
pins defines as outputs will assume the state (high or low) of their
corresponding bit in the PIP. When the GPIP is read, the data read
will come directly from the corresponding bit of the GPIP register for
all pins defines as output, while the data read on all pins defined as
inputs will come from the input buffers.
<br>
</p>
<p>Each individual functions in the MK68901 is provided with a unique
interrupt vector that is presented to the system during the interrupt
acknowledge cycle. The interrupt vector returned during the interrrupt
acknowledge cycle is shown below.
<br>
<br>
</p>
<pre>Interrupt Vector
         V7   V6   V5   V4   V3   V2   V1   V0
         \-----------------/\----------------/
                  |                  |
                  |                  ------------ Vector bits 3-0 supplied
                  |                               by the MFP based upon the interrupting
                  |                               channel.
                  |
                  ------------------------------- 4 most significant bits. Copied
                                                  from the vector register.
Vector Register
         V7   V6   V5   V4    S    *    *    *
         \-----------------/  |
                  |           |
                  |           ------------------- S In-Service Register Enable
                  |
                  ------------------------------- Upper 4 bits of the Vector Register
                                                  Written into by the user.

There are 16 vector addresses generated internally by the MK68901, one for
each of the 16 interrupt channels.
</pre>
<p>
<br>
</p>
<p>The Interrupt Control Registers provide control of interrupt
processing for all I/O facilities of the MK68901. These registers
allow the programmer to enable or disable any or all of the 16
interrupts, providing masking for any interrupts, and provide access
to the pending and in-service status of the interrupts. Optional
end-of-interrupt modes are availble under software control.
<br>
<br>
</p>
<pre>
Interrupt Control Registers

                    Interrupt Enable Registers
Port 3 (IERA) GPIP  GPIP TIMER  RCV   RCV  XMIT   XMIT TIMER
               7     6     A    Full  Err  Empty  Err    B

Port 4 (IERB) GPIP  GPIP TIMER TIMER  GPIP  GPIP  GPIP  GPIP
               5     4     C     D     3     2     1     0

                    Interrupt Pending Registers
Port 5 (IPRA) GPIP  GPIP TIMER  RCV   RCV  XMIT   XMIT TIMER
               7     6     A    Full  Err  Empty  Err    B
Port 6 (IPRB) GPIP  GPIP TIMER TIMER  GPIP  GPIP  GPIP  GPIP
               5     4     C     D     3     2     1     0
                         Writing 0: Clear
                         Writing 1: Unchanged

                    Interrupt In-Service Registers
Port 7 (ISRA) GPIP  GPIP TIMER  RCV   RCV  XMIT   XMIT TIMER
               7     6     A    Full  Err  Empty  Err    B
Port 8 (ISRB) GPIP  GPIP TIMER TIMER  GPIP  GPIP  GPIP  GPIP
               5     4     C     D     3     2     1     0

                    Interrupt Mask Registers
Port 9 (IMRA) GPIP  GPIP TIMER  RCV   RCV  XMIT   XMIT TIMER
               7     6     A    Full  Err  Empty  Err    B
Port A (IMRB) GPIP  GPIP TIMER TIMER  GPIP  GPIP  GPIP  GPIP
               5     4     C     D     3     2     1     0
                    1: UnMasked    0: Masked

</pre>
<p>
<br>
</p>
<p>
<br>
<br>
</p>
<p>
<br>
</p>
<div align=center><table border=1 frame=box>
<caption align=bottom>Tabelle 50: Interrupt Control Register Definitions</caption>
<tr>
  <td align=left valign=top>Priority</td>
  <td align=left valign=top>Channel</td>
  <td align=left valign=top>Description</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
  <td align=left valign=top></td>
</tr>
<tr>
  <td align=left valign=top>Highest</td>
  <td align=left valign=top>1111</td>
  <td align=left valign=top>General Purpose Interrupt 7(I7)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1110</td>
  <td align=left valign=top>General Purpose Interrupt 6(I6)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1101</td>
  <td align=left valign=top>Timer A</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1100</td>
  <td align=left valign=top>Receive Buffer Full</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1011</td>
  <td align=left valign=top>Receive Error</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1010</td>
  <td align=left valign=top>Transmit Buffer Empty</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1001</td>
  <td align=left valign=top>Transmit Error</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>1000</td>
  <td align=left valign=top>Timer B</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0111</td>
  <td align=left valign=top>General Purpose Interrupt 5(I5)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0110</td>
  <td align=left valign=top>General Purpose Interrupt 4(I4)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0101</td>
  <td align=left valign=top>Timer C</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0100</td>
  <td align=left valign=top>Timer D</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0011</td>
  <td align=left valign=top>General Purpose Interrupt 3(I3)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0010</td>
  <td align=left valign=top>General Purpose Interrupt 2(I2)</td>
</tr>
<tr>
  <td align=left valign=top></td>
  <td align=left valign=top>0001</td>
  <td align=left valign=top>General Purpose Interrupt 1(I1)</td>
</tr>
<tr>
  <td align=left valign=top>Lowest</td>
  <td align=left valign=top>0000</td>
  <td align=left valign=top>General Purpose Interrupt 0(I0)</td>
</tr>
</table></div>

<p>
<br>
</p>
<p>Interrupts may be either polled or vectored. Each channel may be
individually enabled or disabled by writing a one or a zero in the
appropriate bit of the Interrupt Enable Registers (IERA,IERB). When
disabled, an interrupt channel is completely inactive. Any internal or
external action which would normally produce an interrupt on that
channel is ignored and any pending interrupt on that channel will be
cleared by disabling that channel. Disabling and interrupt channel has
no effect on the corresponding bit in Interrupt in-Service Registers
(ISRA,ISRB); thus, if the In-Service Registers are used and an
interrupt is in service on that channel when the channel is disabled,
it will remain in service until cleared in the normal manner. IERA and
IERB are also readable.
<br>
</p>
<p>When an interrupt is received on an enabled channel, its
corresponding bit in the pending register will be set. When that
channel is acknowledged it will pass its vector, and the corresponding
bit in the Interrupt Pending Register (IPRA or IPRB) will be cleared.
IPRA and IPRB are readable; thus by polling IPRA and IPRB, it can be
determind whether a channel has a pending interrupt. IPRA and IPRB are
also writeable and a pending interrupt can be cleared without going
through the acknowledge sequence by writing a zero to the appropriate
bit. This allows any one bit to be cleared, without altering any other
bits, simply by writing all ones except for the bit position to be
cleared on IPRA or IPRB. Thus a full polled interrupt scheme is
possible. Note: writing a one to IPRA, IPRB has no effect on the
interrupt pending register.
<br>
</p>
<p>The interrupt mask registers (IMRA and IMRB) may be used to block
a channel from making an interrupt request. Writing a zero into the
corresponding bit of the mask register will still allow the channel to
receive and interrupt and latch it into its pending bit (if that
channel is enabled), but will prevent that channel from making an
interrupt request. If that channel is causing an interrupt request at
the time the corresponding bit in the mask register is cleared, the
request will cease. If no other channel is making a request, INTR will
go inactive. If the mask bit is re-enabled, any pending interrupt is
now free to resume its request unless blocked by a higher priority
request for service. IMRA and iMRB are also readable.
<br>
</p>
<p>A conceptual circuit of an interrupt
<br>
</p>
<pre>
       Edge       Enable                     Mask
    Register    Register                   Register              S-Bit
       |           |                          |                    |
       |           |                          ----|---\            --|---\ |------------|
       |           o-----|---\ |-----------|      |    |---o---------|    ||S Interrupt |
       ---\\--\    |     |    ||S Pending Q|------|---/    |       --|---/ |   Service  |
          ||   |---|-----|---/ |     R     |               |       |       |------------|
 I7-------//--/    |           |-----------|               |       |
                   |                 |                 Interrupt   |
                 -----             /---\                Request    |
                 \   /             |   |                           |
                  \ /              /---\                           |
                   o                | |                            |
                   |                | |                            |
                   ------------------ -----------------------------o------ Pass Vector

</pre>
<p>
<br>There are two end-of-interrupt modes: the automatic
end-of-interrupt mode and the software end-of-interrupt mode. The mode
is selected by writing a one or a zero to the S bit of the Vector
Register (VR). If the S bit of the VR is a one, all channels operate
in the software end-of-interrupt mode. If the S bit is a zero, all
channels operate in the automatic end-of-interrupt mode, and a reset
is held on all in-service bits. In the automatic end-of-interrupt
mode, the pending bit is cleared when that channel passes its vector.
At that point, no further history of that interrupt remains in the
MK68901 MFP. In the software end-of-interrupt mode, the in-service bit
is set and the pending bit is cleared when the channel passes its
vector. With the in-service bit set, no lower priority channel is
allowed to request an interrupt or to pass its vector during an
acknowledge sequence, however, a lower priority channel may still
receive and interrupt and latch it into the pending bit. A higher
priority channel may stillrequest an interrupt and be acknowledged,
The in-service bit of a particular channel may be cleared by writing a
zero to the corresponding bit in ISRA or ISRB. Typically, this will be
done at the conclusion of the interrupt routine just before the
return. Thus no lower priority channel will be allowed to request
service until the higer priority channel is complete, while channels
of still higher priority will be allowed to request service. While the
in-service bit is set, a second interrupt on that channel may be
received and latched into the pending bit, though no service request
will be made in response to the second interrupt until the in-service
bit is cleared. ISRA and ISRB may be read at any time. Only a zero may
be written into any bit of ISRA and ISRB; thus the in-service may be
cleared in software but cannot be set in software. This allows any one
bit to be cleared, without altering any other bits, simply by writing
all ones except for the bit position to be cleared to ISRA or ISRB, as
with IPRA and IPRB.
<br>
</p>
<p>Each interrupt channel responds with a discrete 8-bit vector when
acknowledged. The upper four bits of the vector are set by writing the
upper four bits of the VR. The four low order bits (bit 3-bit 0) are
generated by the interrupt channel.
<br>
</p>
<p>To acknowledge an interrupt, IACK goes low, the IEI input must go
low (or be tied low) and the MK68901 MFP must have acknowledgeable
interrupt pending. The daisy chaining capability requires that all
parts in a chain have a command IACK. When the command IACK goes low
all parts freeze and prioritize interrupts in parallel. Then priority
is passed down the chain, via IEI and IEO, until a part which has a
pending interrupt is reached. The part with the pending interrupt,
passes a vector, does not propagate IEO, and generates DTACK.
<br>
</p>
<p>
<br>
<br>
</p>
<p><b> Timers </b>
<br>
</p>
<p>There are four timers on the MK68901 MFP. Two of the timers (Timer
A and Timer B) are full function timers which can perform the basic
delay function and can also perform event counting, pulse width
measurement and waveform generation. The other two timers (Timer C and
Timer D) are delay timers only. One or both of these timers can be
used to supply the baud rate clocks for the USART. All timers are
prescaler/counter timers with a common independent clock input (XTAL1,
XTAL2). In addition, all timers have a time-out output function that
toggles each time the timer times out.
<br>
</p>
<p>The four timers are programmed via three Timer Control Registers
and four Timer Data Registers. Timers A and B are controlled bu the
control registers TACR and TBCR, respectively, and by the data
registers TADR and TBDR. Timers C and D are controlled by the control
register TCDCR and two data registers TCDR and TDDR. Bits in the
control registers allow the selection of operational mode, prescale,
and control, while data registers are used to read the timer or write
into the time constant register. Timer A and B input pins, TAI and
TBI, are used for the event and pulse width modes for timers A and B.
<br>
</p>
<p>
<br>
</p>
<pre>
Timer Data Registers (A,B,C and D)

     Port F (TADR)    D7   D6   D5   D4   D3   D2   D1   D0

     Port 10 (TBDR)   D7   D6   D5   D4   D3   D2   D1   D0

     Port 11 (TCDR)   D7   D6   D5   D4   D3   D2   D1   D0

     Port 12 (TDDR)   D7   D6   D5   D4   D3   D2   D1   D0


Timer A and B Control Register

     Port C (TACR)    *    *    *  Reset AC3  AC2  AC1  AC0

     Port D (TBCR)    *    *    *  Reset BC3  BC2  BC1  BC0

              C3  C2  C1  C0
               0   0   0   0   Timer Stopped
               0   0   0   1   Delay Mode, /4 Prescale
               0   0   1   0   Delay Mode, /10 Prescale
               0   0   1   1   Delay Mode, /16 Prescale
               0   1   0   0   Delay Mode, /50 Prescale
               0   1   0   1   Delay Mode, /64 Prescale
               0   1   1   0   Delay Mode, /100 Prescale
               0   1   1   1   Delay Mode, /200 Prescale
               1   0   0   0   Event Count Mode
               1   0   0   1   Pulse Width Mode, /4 Prescale
               1   0   1   0   Pulse Width Mode, /10 Prescale
               1   0   1   1   Pulse Width Mode, /16 Prescale
               1   1   0   0   Pulse Width Mode, /50 Prescale
               1   1   0   1   Pulse Width Mode, /64 Prescale
               1   1   1   0   Pulse Width Mode, /100 Prescale
               1   1   1   1   Pulse Width Mode, /200 Prescale


Timer C and D Control Register

     Port E (TCDCR)   *   CC2  CC1  CC0   *   DC2  DC1  DC0

                  C2  C1  C0
                   0   0   0   Timer Stopped
                   0   0   1   Delay Mode, /4 Prescale
                   0   1   0   Delay Mode, /10 Prescale
                   0   1   1   Delay Mode, /16 Prescale
                   1   0   0   Delay Mode, /50 Prescale
                   1   0   1   Delay Mode, /64 Prescale
                   1   1   0   Delay Mode, /100 Prescale
                   1   1   1   Delay Mode, /200 Prescale

</pre>
<p>
<br>
</p>
<p>With the timer stopped, no counting can occur. The timer contents
will remain unaltered while the timer is stopped (unless reloaded by
writing the Timer Data Register), but any residual count in the
prescaler will be lost.
<br>
</p>
<p>In the delay mode, the prescaler is always active. A count pulse
will be applied to the main timer unit each time the prescribed number
of timer clock cycles has elapsed. Thus, if the prescaler is
programmed to divide by ten, a count pulse will be applied to the main
counter every ten cycles of the timer clock.
<br>
</p>
<p>Each time a count pulse is applied to the main counter, it will
decrement its contents. The main counter is initially loaded by
writing to the Timer Data Register. Each count pulse will cause the
current count to decrement. When the timer has decremented down to
'01', the next count pulse will not cause it to decrement to '00'.
Instead the next count pulse will cause the timer to be reloaded from
the Timer Data Register. Additionally, a 'Time Out' pulse will be
produced. This Time Out pulse is coupled to the timer interrupt
channel, and, if that channel is enabled an interrupt will be
produced. The Time Out pulse is also coupled to the timer output pin
and will cause the pin to change states. The output will remain in
this new state until the next Time Out pulse occurs. Thus the output
will complete one full cycle each two Time Out pulses.
<br>
</p>
<p>If, for example, the prescaler were programmed to divide by ten,
and the Timer Data Register were loaded will 100(decimal), the main
counter would decrement once for every ten cycles of the timer clock.
A Time Out pulse will occur(hence an interrupt if that channel is
enabled) every 1000 cycles of the timer clock, and the timer output
will complete one full cycle every 2000 cycles of the timer clock.
<br>
</p>
<p>The main counter is an 8-bit binary down counter. If may be read
at any time by reading the Timer Data Register. The information read
is the information last clocked into the timer read register when the
DS pin had last gone high prior to the current read cycle. When
written, data is loaded into the Timer Data Register, and the main
counter, if the timer is stopped. If the Timer Data Register is
written while the timer is running, the new word is not loaded into
the timer until it counts through H01. However, if the timer is
written while it is counting through H01, an indeterminate value will
be written into the time constant register. This may be circumvented
by ensuring that the daata register is not written when the count is
H01.
<br>
</p>
<p>If the main counter is loaded with 01, a Time Out Pulse will occur
every time the prescaler presents a count pulse to the main counter.
If loaded with 00, a Time Out pulse will occur after every 256 count
pulses.
<br>
</p>
<p>Changing the prescale value with the timer running can cause the
first Time Out pulse to occur at an indeterminate time, (no less than
one nor more than 200 timer clock cycles times the number in the time
constant register), but subsequent Time Out pulses will then occur at
the correct interval.
<br>
</p>
<p>In addition to the delay mode described above, Timers A and B can
also function in Pulse Width Measurement mode or in the Event Count
mode. In either of these two modes, an auxilary count signal is
required. The auxilary control input for Timer A is TAI, and for Timer
B, TBI is used. The interrupt channels associated with I4 and I3 are
used for TAI and TBI, respectively, in Pulse Width mode.
<br>
</p>
<p>The pulse width measurement mode functions much like the delay
mode. However, in this mode, the auxiliary control signal on TAI or
TBI acts as an enable to the timer. When the control signal on TAI or
TBI is inactive, the timer will be stopped. When it is active, the
prescaler and main counter are allowed to run. Thus the width of the
active pulse on TAI or TBI is determined by the number of timer counts
which occur while the pulse allows the timer to run. The active state
of the signal on TAI or TBI is dependent upon the associated Interrupt
Channels edge bit (GPIP4 for TAI and GPIP3 for TBI, see Active Edge
Register). If the edge bit associated with the TAI or TBI input is a
one, it will be active high, thus the timer will be allowed to run
when the input is at a high level. If the edge bit is a zero, the TAI
or TBI input will be active low. As previously stated, the interrupt
channel (I3 or I4) associated with the input still functions when the
timer is used in the pulse width measurement mode. However, if the
timer is programmed for the pulse width measurement mode, the
interrupt caused by transitions on the associated TAI or TBI input
will occur on the opposite transition.
<br>
</p>
<p>A conceptual circuit of the MFP timer in the pulse width
measurement mode
<br>
<br>
</p>
<pre>
                            |-----|
                            | TAI |
                            |-----|
                               |
                               -----------|---\
  Timer A                                 |    |----
  Pulse Width Mode ------------o----------|---/    |
                               |                   |---\---\      |-----------|
                               |                        |   |-----| Interrupt |
           |----|              |   |\              |---/---/      |  Channel  |
           | I4 |-------|      ----| o----|---\    |              |-----------|
           |----|       |          |/     |    |----
                        ------------------|---/


                        ------------------|---\
           |----|       |          |\     |    |----
           | I3 |-------|      ----| o----|---/    |
           |----|              |   |/              |---\---\      |-----------|
                               |                        |   |-----| Interrupt |
  Timer B                      |                   |---/---/      |  Channel  |
  Pulse Width Mode ------------o----------|---\    |              |-----------|
                                          |    |----
                               -----------|---/
                               |
                            |-----|
                            | TBI |
                            |-----|


</pre>
<p>
<br>
</p>
<p>For example, if the edge bit associated with the TAI input
(AER-GPIP 4) is a one, an interrupt would normally be generated on the
0-1 transition of the I4 input signal. If the timer associated with
this input (Timer A) is placed in the pulse width measurement mode,
the interrupt will occur on the 1-0 transition of the TAI signal
instead. Because the edge bit (AER-GPIP4) is a one, Timer A will be
allowed to count while the input is high. When the TAI input makes the
high to low transition, Timer A will stop, and it is at this point
that the interrupt will occur (assuming that the channel is enabled).
This allows the interrupt to signal the <a href="080108.htm" target="UDOcon">CPU</a> that the pulse being
measured has terminated this Timer A may now be read to determine the
pulse width. (Again note that I3 and I4 may still be used for I/O when
the timer is in the pulse width measurement mode). If Timer A is
re-programmed for another mode, interrupts will again occur on the
transition, as normally defined by the edge bit. Note that, like
changing the edge bit, placing the timer into or taking it out of
pulse width mode can produce a transition on the signal to the
interrupt channel and may cause an interrupt. If measuring consecutive
pulses, it is obvious that one must read the contents of the timer and
reinitalize the main counter by writing to the timer data register. If
the timer data register is written while the pulse is going to the
active state, the write operation may result in an indeterminate value
being written into the main counter. If the timer is written after the
pulse goes active, the timer counts from the previous contents, and
when it counts through H01, the correct value is written into the
timer. The pulse width then includes counts from before the timer was
reloaded.
<br>
</p>
<p>In the event count mode, the prescaler is disabled. Each time the
control input on TAI or TBI makes an active transition as defined by
the associated Interrupt Channel's edge bit, a count pulse will be
generated, and the main counter will decrement. In all other respects,
the timer functions as previously described. Altering the edge bit
while the timer is in the event count mode can produce a count pulse.
The interrupt channel associated with the input (I3 for TBI or I4 for
TAI) is allowed to function normally. To count transitions reliably,
the input must remain in each state (1/0) for a length of time equal
to four perioids of the timer clock; thus signals of a frequency up to
one fourth of the timer clock can be counted.
<br>
</p>
<p>The manner in which the timer output pins toggle states has
previously been described. All timer outputs will be forced low by a
device RESET. The output associated with Timers A and B will toggle on
each Time Out pulse regardless of the mode the timers are programmed
to. In addition, the outputs from Timers A and Timers B can be forced
low at any time by writing a 1 to the reset location in TACR and TBCR,
respectively. The output will be forced to the low state during the
WRITE operation, and at the conclusion of the operation, the output
will again be free to toggle each time a Time Out pulse occurs. This
feature will allow waveform generation.
<br>
</p>
<p>During reset, the Timer Data Registers and the main counters are
not reset. Also, if using the reset option on Timers A or B, one must
make sure to keep the other bits in the correct state so as not to
affect the operation of Timers A and B.
<br>
</p>
<p>
<br>
<br>
</p>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img.gif" border=0 width="50" height="40"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de/">Robert Schaffner</a> (<a href="mailto:doit@doitarchive.de">doit@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Mai 2004</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_up.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="0801.htm" target="UDOcon"><img src="udo_lf.gif" alt="Pin ST Serie" border=0 width="24" height="24"></a>
<a href="080102.htm" target="UDOcon"><img src="udo_rg.gif" alt="Atari ST DMA" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>
